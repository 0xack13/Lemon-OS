Binary file Kernel/build/.ninja_deps matches
Kernel/build/.ninja_log:216	327	1589017256	subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o	7ccb287b954daff9
Kernel/build/.ninja_log:38	167	1589017255	subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o	e81bde660874447a
Kernel/build/.ninja_log:1292	1391	1589167634	kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o	3d82306c2af62f9a
Kernel/build/.ninja_log:1050	1212	1589167634	kernel.sys@exe/subprojects_lai_core_exec-operand.c.o	104774dccdfb5386
Kernel/build/build.ninja: command = x86_64-lemon-gcc $ARGS -MD -MQ $out -MF '$DEPFILE' -o $out -c $in
Kernel/build/build.ninja: command = x86_64-lemon-gcc $ARGS -MD -MQ $out -MF '$DEPFILE' -o $out -c $in
Kernel/build/build.ninja: command = rm -f $out && x86_64-lemon-ar $LINK_ARGS $out $in
Kernel/build/build.ninja: command = x86_64-lemon-gcc $ARGS -o $out $in $LINK_ARGS
Kernel/build/build.ninja: command = /home/user/.local/bin/meson --internal regenerate /mnt/e/OneDrive/Lemon/Kernel /mnt/e/OneDrive/Lemon/Kernel/build --backend ninja
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja:build subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o: c_COMPILER ../subprojects/lai/core/exec-operand.c
Kernel/build/build.ninja: DEPFILE = subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o.d
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja:build subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o: c_COMPILER ../subprojects/lai/helpers/pc-bios.c
Kernel/build/build.ninja: DEPFILE = subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o.d
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja: ARGS = -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g
Kernel/build/build.ninja:build subprojects/lai/liblai.a: STATIC_LINKER subprojects/lai/cf89b58@@lai@sta/core_error.c.o subprojects/lai/cf89b58@@lai@sta/core_eval.c.o subprojects/lai/cf89b58@@lai@sta/core_exec.c.o subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o subprojects/lai/cf89b58@@lai@sta/core_libc.c.o subprojects/lai/cf89b58@@lai@sta/core_ns.c.o subprojects/lai/cf89b58@@lai@sta/core_object.c.o subprojects/lai/cf89b58@@lai@sta/core_opregion.c.o subprojects/lai/cf89b58@@lai@sta/core_os_methods.c.o subprojects/lai/cf89b58@@lai@sta/core_variable.c.o subprojects/lai/cf89b58@@lai@sta/core_vsnprintf.c.o subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o subprojects/lai/cf89b58@@lai@sta/helpers_pci.c.o subprojects/lai/cf89b58@@lai@sta/helpers_resource.c.o subprojects/lai/cf89b58@@lai@sta/helpers_sci.c.o subprojects/lai/cf89b58@@lai@sta/helpers_pm.c.o subprojects/lai/cf89b58@@lai@sta/drivers_ec.c.o subprojects/lai/cf89b58@@lai@sta/drivers_timer.c.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/entry.asm -o kernel.sys@exe/entry.asm.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/idt.asm -o kernel.sys@exe/idt.asm.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/scheduler.asm -o kernel.sys@exe/scheduler.asm.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/sse2.asm -o kernel.sys@exe/sse2.asm.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/tss.asm -o kernel.sys@exe/tss.asm.o
Kernel/build/build.ninja: COMMAND = /usr/bin/nasm -f elf64 -g -F dwarf -w+gnu-elf-extensions ../src/arch/x86_64/lock.asm -o kernel.sys@exe/lock.asm.o
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja:build kernel.sys@exe/subprojects_lai_core_exec-operand.c.o: c_COMPILER ../subprojects/lai/core/exec-operand.c
Kernel/build/build.ninja: DEPFILE = kernel.sys@exe/subprojects_lai_core_exec-operand.c.o.d
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja:build kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o: c_COMPILER ../subprojects/lai/helpers/pc-bios.c
Kernel/build/build.ninja: DEPFILE = kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o.d
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja: ARGS = -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja:build kernel.sys: cpp_LINKER kernel.sys@exe/entry.asm.o kernel.sys@exe/idt.asm.o kernel.sys@exe/scheduler.asm.o kernel.sys@exe/sse2.asm.o kernel.sys@exe/tss.asm.o kernel.sys@exe/lock.asm.o kernel.sys@exe/src_kernel.cpp.o kernel.sys@exe/src_characterbuffer.cpp.o kernel.sys@exe/src_devicemanager.cpp.o kernel.sys@exe/src_gpt.cpp.o kernel.sys@exe/src_gui.cpp.o kernel.sys@exe/src_lemon.cpp.o kernel.sys@exe/src_logging.cpp.o kernel.sys@exe/src_math.cpp.o kernel.sys@exe/src_panic.cpp.o kernel.sys@exe/src_runtime.cpp.o kernel.sys@exe/src_string.cpp.o kernel.sys@exe/src_video.cpp.o kernel.sys@exe/src_videoconsole.cpp.o kernel.sys@exe/src_sharedmem.cpp.o kernel.sys@exe/src_fs_fat32.cpp.o kernel.sys@exe/src_fs_filesystem.cpp.o kernel.sys@exe/src_fs_fsvolume.cpp.o kernel.sys@exe/src_fs_tar.cpp.o kernel.sys@exe/src_liballoc__liballoc.cpp.o kernel.sys@exe/src_liballoc_liballoc.c.o kernel.sys@exe/src_net_8254x.cpp.o kernel.sys@exe/src_storage_ahci.cpp.o kernel.sys@exe/src_storage_ahciport.cpp.o kernel.sys@exe/src_storage_ata.cpp.o kernel.sys@exe/src_storage_atadrive.cpp.o kernel.sys@exe/src_storage_diskdevice.cpp.o kernel.sys@exe/src_storage_nvme.cpp.o kernel.sys@exe/src_storage_partitiondevice.cpp.o kernel.sys@exe/src_tty_pty.cpp.o kernel.sys@exe/src_usb_xhci.cpp.o kernel.sys@exe/src_arch_x86_64_acpi.cpp.o kernel.sys@exe/src_arch_x86_64_apic.cpp.o kernel.sys@exe/src_arch_x86_64_cpuid.cpp.o kernel.sys@exe/src_arch_x86_64_hal.cpp.o kernel.sys@exe/src_arch_x86_64_idt.cpp.o kernel.sys@exe/src_arch_x86_64_keyboard.cpp.o kernel.sys@exe/src_arch_x86_64_mouse.cpp.o kernel.sys@exe/src_arch_x86_64_paging.cpp.o kernel.sys@exe/src_arch_x86_64_pci.cpp.o kernel.sys@exe/src_arch_x86_64_physicalallocator.cpp.o kernel.sys@exe/src_arch_x86_64_scheduler.cpp.o kernel.sys@exe/src_arch_x86_64_serial.cpp.o kernel.sys@exe/src_arch_x86_64_smp.cpp.o kernel.sys@exe/src_arch_x86_64_sse2.cpp.o kernel.sys@exe/src_arch_x86_64_ssp.cpp.o kernel.sys@exe/src_arch_x86_64_syscalls.cpp.o kernel.sys@exe/src_arch_x86_64_system.cpp.o kernel.sys@exe/src_arch_x86_64_timer.cpp.o kernel.sys@exe/src_arch_x86_64_tss.cpp.o kernel.sys@exe/src_arch_x86_64_elf.cpp.o kernel.sys@exe/subprojects_lai_core_error.c.o kernel.sys@exe/subprojects_lai_core_eval.c.o kernel.sys@exe/subprojects_lai_core_exec.c.o kernel.sys@exe/subprojects_lai_core_exec-operand.c.o kernel.sys@exe/subprojects_lai_core_libc.c.o kernel.sys@exe/subprojects_lai_core_ns.c.o kernel.sys@exe/subprojects_lai_core_object.c.o kernel.sys@exe/subprojects_lai_core_opregion.c.o kernel.sys@exe/subprojects_lai_core_os_methods.c.o kernel.sys@exe/subprojects_lai_core_variable.c.o kernel.sys@exe/subprojects_lai_core_vsnprintf.c.o kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o kernel.sys@exe/subprojects_lai_helpers_pci.c.o kernel.sys@exe/subprojects_lai_helpers_resource.c.o kernel.sys@exe/subprojects_lai_helpers_sci.c.o kernel.sys@exe/subprojects_lai_helpers_pm.c.o kernel.sys@exe/subprojects_lai_drivers_ec.c.o kernel.sys@exe/subprojects_lai_drivers_timer.c.o | /home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/libgcc.a /mnt/e/OneDrive/Lemon/Kernel/linkscript-x86_64.ld
Kernel/build/build.ninja: LINK_ARGS = -Wl,--as-needed -Wl,--no-undefined -m64 -T /mnt/e/OneDrive/Lemon/Kernel/linkscript-x86_64.ld -Wl,--start-group -lgcc -Wl,--end-group -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti
Kernel/build/build.ninja:build meson-test: CUSTOM_COMMAND all PHONY
Kernel/build/build.ninja: COMMAND = /home/user/.local/bin/meson test --no-rebuild --print-errorlogs
Kernel/build/build.ninja:build test: phony meson-test
Kernel/build/build.ninja:build meson-benchmark: CUSTOM_COMMAND all PHONY
Kernel/build/build.ninja: COMMAND = /home/user/.local/bin/meson test --benchmark --logbase benchmarklog --num-processes=1 --no-rebuild
Kernel/build/build.ninja:build benchmark: phony meson-benchmark
Kernel/build/build.ninja:build meson-install: CUSTOM_COMMAND PHONY | all
Kernel/build/build.ninja: COMMAND = /home/user/.local/bin/meson install --no-rebuild
Kernel/build/build.ninja:build install: phony meson-install
Kernel/build/build.ninja:build meson-dist: CUSTOM_COMMAND PHONY
Kernel/build/build.ninja:build dist: phony meson-dist
Kernel/build/build.ninja:build meson-uninstall: CUSTOM_COMMAND PHONY
Kernel/build/build.ninja: COMMAND = /home/user/.local/bin/meson --internal uninstall
Kernel/build/build.ninja:build uninstall: phony meson-uninstall
Kernel/build/build.ninja:build clean: phony meson-clean
Kernel/build/build.ninja:build meson-clean: CUSTOM_COMMAND PHONY
Kernel/build/build.ninja: COMMAND = /usr/bin/ninja -t clean
Kernel/build/build.ninja:build build.ninja: REGENERATE_BUILD ../meson.build ../subprojects/lai/meson.build /mnt/e/OneDrive/Lemon/Scripts/lemon-crossfile.txt meson-private/coredata.dat
Kernel/build/build.ninja:build ../meson.build ../subprojects/lai/meson.build /mnt/e/OneDrive/Lemon/Scripts/lemon-crossfile.txt meson-private/coredata.dat: phony 
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_error.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_error.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_error.c.o' -c ../subprojects/lai/core/error.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_eval.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_eval.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_eval.c.o' -c ../subprojects/lai/core/eval.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_exec.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_exec.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_exec.c.o' -c ../subprojects/lai/core/exec.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o' -c ../subprojects/lai/core/exec-operand.c",
Kernel/build/compile_commands.json:    "file": "../subprojects/lai/core/exec-operand.c"
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_libc.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_libc.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_libc.c.o' -c ../subprojects/lai/core/libc.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_ns.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_ns.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_ns.c.o' -c ../subprojects/lai/core/ns.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_object.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_object.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_object.c.o' -c ../subprojects/lai/core/object.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_opregion.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_opregion.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_opregion.c.o' -c ../subprojects/lai/core/opregion.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_os_methods.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_os_methods.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_os_methods.c.o' -c ../subprojects/lai/core/os_methods.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_variable.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_variable.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_variable.c.o' -c ../subprojects/lai/core/variable.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/core_vsnprintf.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/core_vsnprintf.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/core_vsnprintf.c.o' -c ../subprojects/lai/core/vsnprintf.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o' -c ../subprojects/lai/helpers/pc-bios.c",
Kernel/build/compile_commands.json:    "file": "../subprojects/lai/helpers/pc-bios.c"
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/helpers_pci.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/helpers_pci.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/helpers_pci.c.o' -c ../subprojects/lai/helpers/pci.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/helpers_resource.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/helpers_resource.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/helpers_resource.c.o' -c ../subprojects/lai/helpers/resource.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/helpers_sci.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/helpers_sci.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/helpers_sci.c.o' -c ../subprojects/lai/helpers/sci.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/helpers_pm.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/helpers_pm.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/helpers_pm.c.o' -c ../subprojects/lai/helpers/pm.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/drivers_ec.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/drivers_ec.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/drivers_ec.c.o' -c ../subprojects/lai/drivers/ec.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Isubprojects/lai/cf89b58@@lai@sta -Isubprojects/lai -I../subprojects/lai -I../subprojects/lai/include -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -MD -MQ 'subprojects/lai/cf89b58@@lai@sta/drivers_timer.c.o' -MF 'subprojects/lai/cf89b58@@lai@sta/drivers_timer.c.o.d' -o 'subprojects/lai/cf89b58@@lai@sta/drivers_timer.c.o' -c ../subprojects/lai/drivers/timer.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_kernel.cpp.o' -MF 'kernel.sys@exe/src_kernel.cpp.o.d' -o 'kernel.sys@exe/src_kernel.cpp.o' -c ../src/kernel.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_characterbuffer.cpp.o' -MF 'kernel.sys@exe/src_characterbuffer.cpp.o.d' -o 'kernel.sys@exe/src_characterbuffer.cpp.o' -c ../src/characterbuffer.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_devicemanager.cpp.o' -MF 'kernel.sys@exe/src_devicemanager.cpp.o.d' -o 'kernel.sys@exe/src_devicemanager.cpp.o' -c ../src/devicemanager.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_gpt.cpp.o' -MF 'kernel.sys@exe/src_gpt.cpp.o.d' -o 'kernel.sys@exe/src_gpt.cpp.o' -c ../src/gpt.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_gui.cpp.o' -MF 'kernel.sys@exe/src_gui.cpp.o.d' -o 'kernel.sys@exe/src_gui.cpp.o' -c ../src/gui.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_lemon.cpp.o' -MF 'kernel.sys@exe/src_lemon.cpp.o.d' -o 'kernel.sys@exe/src_lemon.cpp.o' -c ../src/lemon.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_logging.cpp.o' -MF 'kernel.sys@exe/src_logging.cpp.o.d' -o 'kernel.sys@exe/src_logging.cpp.o' -c ../src/logging.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_math.cpp.o' -MF 'kernel.sys@exe/src_math.cpp.o.d' -o 'kernel.sys@exe/src_math.cpp.o' -c ../src/math.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_panic.cpp.o' -MF 'kernel.sys@exe/src_panic.cpp.o.d' -o 'kernel.sys@exe/src_panic.cpp.o' -c ../src/panic.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_runtime.cpp.o' -MF 'kernel.sys@exe/src_runtime.cpp.o.d' -o 'kernel.sys@exe/src_runtime.cpp.o' -c ../src/runtime.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_string.cpp.o' -MF 'kernel.sys@exe/src_string.cpp.o.d' -o 'kernel.sys@exe/src_string.cpp.o' -c ../src/string.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_video.cpp.o' -MF 'kernel.sys@exe/src_video.cpp.o.d' -o 'kernel.sys@exe/src_video.cpp.o' -c ../src/video.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_videoconsole.cpp.o' -MF 'kernel.sys@exe/src_videoconsole.cpp.o.d' -o 'kernel.sys@exe/src_videoconsole.cpp.o' -c ../src/videoconsole.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_sharedmem.cpp.o' -MF 'kernel.sys@exe/src_sharedmem.cpp.o.d' -o 'kernel.sys@exe/src_sharedmem.cpp.o' -c ../src/sharedmem.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_fs_fat32.cpp.o' -MF 'kernel.sys@exe/src_fs_fat32.cpp.o.d' -o 'kernel.sys@exe/src_fs_fat32.cpp.o' -c ../src/fs/fat32.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_fs_filesystem.cpp.o' -MF 'kernel.sys@exe/src_fs_filesystem.cpp.o.d' -o 'kernel.sys@exe/src_fs_filesystem.cpp.o' -c ../src/fs/filesystem.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_fs_fsvolume.cpp.o' -MF 'kernel.sys@exe/src_fs_fsvolume.cpp.o.d' -o 'kernel.sys@exe/src_fs_fsvolume.cpp.o' -c ../src/fs/fsvolume.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_fs_tar.cpp.o' -MF 'kernel.sys@exe/src_fs_tar.cpp.o.d' -o 'kernel.sys@exe/src_fs_tar.cpp.o' -c ../src/fs/tar.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_liballoc__liballoc.cpp.o' -MF 'kernel.sys@exe/src_liballoc__liballoc.cpp.o.d' -o 'kernel.sys@exe/src_liballoc__liballoc.cpp.o' -c ../src/liballoc/_liballoc.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_liballoc_liballoc.c.o' -MF 'kernel.sys@exe/src_liballoc_liballoc.c.o.d' -o 'kernel.sys@exe/src_liballoc_liballoc.c.o' -c ../src/liballoc/liballoc.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_net_8254x.cpp.o' -MF 'kernel.sys@exe/src_net_8254x.cpp.o.d' -o 'kernel.sys@exe/src_net_8254x.cpp.o' -c ../src/net/8254x.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_ahci.cpp.o' -MF 'kernel.sys@exe/src_storage_ahci.cpp.o.d' -o 'kernel.sys@exe/src_storage_ahci.cpp.o' -c ../src/storage/ahci.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_ahciport.cpp.o' -MF 'kernel.sys@exe/src_storage_ahciport.cpp.o.d' -o 'kernel.sys@exe/src_storage_ahciport.cpp.o' -c ../src/storage/ahciport.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_ata.cpp.o' -MF 'kernel.sys@exe/src_storage_ata.cpp.o.d' -o 'kernel.sys@exe/src_storage_ata.cpp.o' -c ../src/storage/ata.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_atadrive.cpp.o' -MF 'kernel.sys@exe/src_storage_atadrive.cpp.o.d' -o 'kernel.sys@exe/src_storage_atadrive.cpp.o' -c ../src/storage/atadrive.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_diskdevice.cpp.o' -MF 'kernel.sys@exe/src_storage_diskdevice.cpp.o.d' -o 'kernel.sys@exe/src_storage_diskdevice.cpp.o' -c ../src/storage/diskdevice.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_nvme.cpp.o' -MF 'kernel.sys@exe/src_storage_nvme.cpp.o.d' -o 'kernel.sys@exe/src_storage_nvme.cpp.o' -c ../src/storage/nvme.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_storage_partitiondevice.cpp.o' -MF 'kernel.sys@exe/src_storage_partitiondevice.cpp.o.d' -o 'kernel.sys@exe/src_storage_partitiondevice.cpp.o' -c ../src/storage/partitiondevice.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_tty_pty.cpp.o' -MF 'kernel.sys@exe/src_tty_pty.cpp.o.d' -o 'kernel.sys@exe/src_tty_pty.cpp.o' -c ../src/tty/pty.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_usb_xhci.cpp.o' -MF 'kernel.sys@exe/src_usb_xhci.cpp.o.d' -o 'kernel.sys@exe/src_usb_xhci.cpp.o' -c ../src/usb/xhci.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_acpi.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_acpi.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_acpi.cpp.o' -c ../src/arch/x86_64/acpi.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_apic.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_apic.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_apic.cpp.o' -c ../src/arch/x86_64/apic.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_cpuid.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_cpuid.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_cpuid.cpp.o' -c ../src/arch/x86_64/cpuid.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_hal.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_hal.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_hal.cpp.o' -c ../src/arch/x86_64/hal.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_idt.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_idt.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_idt.cpp.o' -c ../src/arch/x86_64/idt.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_keyboard.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_keyboard.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_keyboard.cpp.o' -c ../src/arch/x86_64/keyboard.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_mouse.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_mouse.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_mouse.cpp.o' -c ../src/arch/x86_64/mouse.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_paging.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_paging.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_paging.cpp.o' -c ../src/arch/x86_64/paging.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_pci.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_pci.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_pci.cpp.o' -c ../src/arch/x86_64/pci.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_physicalallocator.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_physicalallocator.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_physicalallocator.cpp.o' -c ../src/arch/x86_64/physicalallocator.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_scheduler.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_scheduler.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_scheduler.cpp.o' -c ../src/arch/x86_64/scheduler.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_serial.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_serial.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_serial.cpp.o' -c ../src/arch/x86_64/serial.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_smp.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_smp.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_smp.cpp.o' -c ../src/arch/x86_64/smp.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_sse2.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_sse2.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_sse2.cpp.o' -c ../src/arch/x86_64/sse2.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_ssp.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_ssp.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_ssp.cpp.o' -c ../src/arch/x86_64/ssp.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_syscalls.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_syscalls.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_syscalls.cpp.o' -c ../src/arch/x86_64/syscalls.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_system.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_system.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_system.cpp.o' -c ../src/arch/x86_64/system.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_timer.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_timer.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_timer.cpp.o' -c ../src/arch/x86_64/timer.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_tss.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_tss.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_tss.cpp.o' -c ../src/arch/x86_64/tss.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wnon-virtual-dtor -g -Wno-write-strings -Wno-pointer-arith -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/src_arch_x86_64_elf.cpp.o' -MF 'kernel.sys@exe/src_arch_x86_64_elf.cpp.o.d' -o 'kernel.sys@exe/src_arch_x86_64_elf.cpp.o' -c ../src/arch/x86_64/elf.cpp",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_error.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_error.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_error.c.o' -c ../subprojects/lai/core/error.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_eval.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_eval.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_eval.c.o' -c ../subprojects/lai/core/eval.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_exec.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_exec.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_exec.c.o' -c ../subprojects/lai/core/exec.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_exec-operand.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_exec-operand.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_exec-operand.c.o' -c ../subprojects/lai/core/exec-operand.c",
Kernel/build/compile_commands.json:    "file": "../subprojects/lai/core/exec-operand.c"
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_libc.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_libc.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_libc.c.o' -c ../subprojects/lai/core/libc.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_ns.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_ns.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_ns.c.o' -c ../subprojects/lai/core/ns.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_object.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_object.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_object.c.o' -c ../subprojects/lai/core/object.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_opregion.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_opregion.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_opregion.c.o' -c ../subprojects/lai/core/opregion.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_os_methods.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_os_methods.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_os_methods.c.o' -c ../subprojects/lai/core/os_methods.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_variable.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_variable.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_variable.c.o' -c ../subprojects/lai/core/variable.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_core_vsnprintf.c.o' -MF 'kernel.sys@exe/subprojects_lai_core_vsnprintf.c.o.d' -o 'kernel.sys@exe/subprojects_lai_core_vsnprintf.c.o' -c ../subprojects/lai/core/vsnprintf.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o' -MF 'kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o.d' -o 'kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o' -c ../subprojects/lai/helpers/pc-bios.c",
Kernel/build/compile_commands.json:    "file": "../subprojects/lai/helpers/pc-bios.c"
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_helpers_pci.c.o' -MF 'kernel.sys@exe/subprojects_lai_helpers_pci.c.o.d' -o 'kernel.sys@exe/subprojects_lai_helpers_pci.c.o' -c ../subprojects/lai/helpers/pci.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_helpers_resource.c.o' -MF 'kernel.sys@exe/subprojects_lai_helpers_resource.c.o.d' -o 'kernel.sys@exe/subprojects_lai_helpers_resource.c.o' -c ../subprojects/lai/helpers/resource.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_helpers_sci.c.o' -MF 'kernel.sys@exe/subprojects_lai_helpers_sci.c.o.d' -o 'kernel.sys@exe/subprojects_lai_helpers_sci.c.o' -c ../subprojects/lai/helpers/sci.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_helpers_pm.c.o' -MF 'kernel.sys@exe/subprojects_lai_helpers_pm.c.o.d' -o 'kernel.sys@exe/subprojects_lai_helpers_pm.c.o' -c ../subprojects/lai/helpers/pm.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_drivers_ec.c.o' -MF 'kernel.sys@exe/subprojects_lai_drivers_ec.c.o.d' -o 'kernel.sys@exe/subprojects_lai_drivers_ec.c.o' -c ../subprojects/lai/drivers/ec.c",
Kernel/build/compile_commands.json:    "command": "x86_64-lemon-gcc -Ikernel.sys@exe -I. -I.. -I../include -I../subprojects/lai/include -I../include/arch/x86_64 -fdiagnostics-color=always -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -g -Wno-write-strings -Wno-pointer-arith -DLemon64 -ffreestanding -nostdlib -mcmodel=large -mno-red-zone -fno-pic -mno-mmx -mno-sse -mno-sse2 -z max-page-size=0x1000 -fno-stack-protector -fno-exceptions -fno-rtti -MD -MQ 'kernel.sys@exe/subprojects_lai_drivers_timer.c.o' -MF 'kernel.sys@exe/subprojects_lai_drivers_timer.c.o.d' -o 'kernel.sys@exe/subprojects_lai_drivers_timer.c.o' -c ../subprojects/lai/drivers/timer.c",
Binary file Kernel/build/kernel.sys matches
Binary file Kernel/build/kernel.sys@exe/entry.asm.o matches
Binary file Kernel/build/kernel.sys@exe/idt.asm.o matches
Binary file Kernel/build/kernel.sys@exe/scheduler.asm.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_acpi.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_apic.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_cpuid.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_elf.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_hal.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_idt.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_keyboard.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_lai.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_mouse.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_paging.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_pci.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_physicalallocator.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_scheduler.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_serial.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_smp.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_sse2.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_ssp.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_syscalls.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_system.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_timer.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_arch_x86_64_tss.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_characterbuffer.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_devicemanager.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_fs_fat32.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_fs_filesystem.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_fs_fsvolume.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_fs_initrd.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_fs_tar.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_gpt.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_gui.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_kernel.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_lemon.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_liballoc_liballoc.c.o matches
Binary file Kernel/build/kernel.sys@exe/src_liballoc__liballoc.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_logging.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_math.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_net_8254x.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_panic.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_runtime.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_sharedmem.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_ahci.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_ahciport.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_ata.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_atadrive.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_diskdevice.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_nvme.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_storage_partitiondevice.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_string.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_tty_pty.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_usb_xhci.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_video.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/src_videoconsole.cpp.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_error.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_eval.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_exec-operand.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_exec.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_libc.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_ns.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_object.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_opregion.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_os_methods.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_variable.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_core_vsnprintf.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_drivers_ec.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_drivers_timer.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_helpers_pc-bios.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_helpers_pci.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_helpers_pm.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_helpers_resource.c.o matches
Binary file Kernel/build/kernel.sys@exe/subprojects_lai_helpers_sci.c.o matches
Kernel/build/meson-info/intro-buildoptions.json:[{"name": "auto_features", "value": "auto", "section": "core", "machine": "any", "choices": ["enabled", "disabled", "auto"], "type": "combo", "description": "Override value of all 'auto' features"}, {"name": "backend", "value": "ninja", "section": "core", "machine": "any", "choices": ["ninja", "vs", "vs2010", "vs2015", "vs2017", "vs2019", "xcode"], "type": "combo", "description": "Backend to use"}, {"name": "buildtype", "value": "debug", "section": "core", "machine": "any", "choices": ["plain", "debug", "debugoptimized", "release", "minsize", "custom"], "type": "combo", "description": "Build type to use"}, {"name": "debug", "value": true, "section": "core", "machine": "any", "type": "boolean", "description": "Debug"}, {"name": "default_library", "value": "shared", "section": "core", "machine": "any", "choices": ["shared", "static", "both"], "type": "combo", "description": "Default library type"}, {"name": "install_umask", "value": 18, "section": "core", "machine": "any", "type": "integer", "description": "Default umask to apply on permissions of installed files"}, {"name": "layout", "value": "mirror", "section": "core", "machine": "any", "choices": ["mirror", "flat"], "type": "combo", "description": "Build directory layout"}, {"name": "optimization", "value": "0", "section": "core", "machine": "any", "choices": ["0", "g", "1", "2", "3", "s"], "type": "combo", "description": "Optimization level"}, {"name": "strip", "value": false, "section": "core", "machine": "any", "type": "boolean", "description": "Strip targets on install"}, {"name": "unity", "value": "off", "section": "core", "machine": "any", "choices": ["on", "off", "subprojects"], "type": "combo", "description": "Unity build"}, {"name": "warning_level", "value": "1", "section": "core", "machine": "any", "choices": ["0", "1", "2", "3"], "type": "combo", "description": "Compiler warning level to use"}, {"name": "werror", "value": false, "section": "core", "machine": "any", "type": "boolean", "description": "Treat warnings as errors"}, {"name": "wrap_mode", "value": "default", "section": "core", "machine": "any", "choices": ["default", "nofallback", "nodownload", "forcefallback"], "type": "combo", "description": "Wrap mode"}, {"name": "cmake_prefix_path", "value": [], "section": "core", "machine": "host", "type": "array", "description": "T.List of additional prefixes for cmake to search"}, {"name": "pkg_config_path", "value": [], "section": "core", "machine": "host", "type": "array", "description": "T.List of additional paths for pkg-config to search"}, {"name": "build.cmake_prefix_path", "value": [], "section": "core", "machine": "build", "type": "array", "description": "T.List of additional prefixes for cmake to search"}, {"name": "build.pkg_config_path", "value": [], "section": "core", "machine": "build", "type": "array", "description": "T.List of additional paths for pkg-config to search"}, {"name": "backend_max_links", "value": 0, "section": "backend", "machine": "any", "type": "integer", "description": "Maximum number of linker processes to run or 0 for no limit"}, {"name": "b_asneeded", "value": true, "section": "base", "machine": "any", "type": "boolean", "description": "Use -Wl,--as-needed when linking"}, {"name": "b_colorout", "value": "always", "section": "base", "machine": "any", "choices": ["auto", "always", "never"], "type": "combo", "description": "Use colored output"}, {"name": "b_coverage", "value": false, "section": "base", "machine": "any", "type": "boolean", "description": "Enable coverage tracking."}, {"name": "b_lto", "value": false, "section": "base", "machine": "any", "type": "boolean", "description": "Use link time optimization"}, {"name": "b_lundef", "value": true, "section": "base", "machine": "any", "type": "boolean", "description": "Use -Wl,--no-undefined when linking"}, {"name": "b_ndebug", "value": "false", "section": "base", "machine": "any", "choices": ["true", "false", "if-release"], "type": "combo", "description": "Disable asserts"}, {"name": "b_pch", "value": true, "section": "base", "machine": "any", "type": "boolean", "description": "Use precompiled headers"}, {"name": "b_pgo", "value": "off", "section": "base", "machine": "any", "choices": ["off", "generate", "use"], "type": "combo", "description": "Use profile guided optimization"}, {"name": "b_pie", "value": false, "section": "base", "machine": "any", "type": "boolean", "description": "Build executables as position independent"}, {"name": "b_sanitize", "value": "none", "section": "base", "machine": "any", "choices": ["none", "address", "thread", "undefined", "memory", "address,undefined"], "type": "combo", "description": "Code sanitizer to use"}, {"name": "b_staticpic", "value": true, "section": "base", "machine": "any", "type": "boolean", "description": "Build static libraries as position independent"}, {"name": "c_args", "value": [], "section": "compiler", "machine": "host", "type": "array", "description": "Extra arguments passed to the c compiler"}, {"name": "c_link_args", "value": [], "section": "compiler", "machine": "host", "type": "array", "description": "Extra arguments passed to the c linker"}, {"name": "c_std", "value": "none", "section": "compiler", "machine": "host", "choices": ["none", "c89", "c99", "c11", "c17", "c18", "gnu89", "gnu99", "gnu11", "gnu17", "gnu18"], "type": "combo", "description": "C language standard to use"}, {"name": "cpp_args", "value": [], "section": "compiler", "machine": "host", "type": "array", "description": "Extra arguments passed to the cpp compiler"}, {"name": "cpp_debugstl", "value": false, "section": "compiler", "machine": "host", "type": "boolean", "description": "STL debug mode"}, {"name": "cpp_eh", "value": "default", "section": "compiler", "machine": "host", "choices": ["none", "default", "a", "s", "sc"], "type": "combo", "description": "C++ exception handling type."}, {"name": "cpp_link_args", "value": [], "section": "compiler", "machine": "host", "type": "array", "description": "Extra arguments passed to the cpp linker"}, {"name": "cpp_rtti", "value": true, "section": "compiler", "machine": "host", "type": "boolean", "description": "Enable RTTI"}, {"name": "cpp_std", "value": "none", "section": "compiler", "machine": "host", "choices": ["none", "c++98", "c++03", "c++11", "c++14", "c++17", "c++1z", "c++2a", "gnu++03", "gnu++11", "gnu++14", "gnu++17", "gnu++1z", "gnu++2a"], "type": "combo", "description": "C++ language standard to use"}, {"name": "build.c_args", "value": [], "section": "compiler", "machine": "build", "type": "array", "description": "Extra arguments passed to the c compiler"}, {"name": "build.c_link_args", "value": [], "section": "compiler", "machine": "build", "type": "array", "description": "Extra arguments passed to the c linker"}, {"name": "build.c_std", "value": "none", "section": "compiler", "machine": "build", "choices": ["none", "c89", "c99", "c11", "gnu89", "gnu99", "gnu11"], "type": "combo", "description": "C language standard to use"}, {"name": "build.cpp_args", "value": [], "section": "compiler", "machine": "build", "type": "array", "description": "Extra arguments passed to the cpp compiler"}, {"name": "build.cpp_debugstl", "value": false, "section": "compiler", "machine": "build", "type": "boolean", "description": "STL debug mode"}, {"name": "build.cpp_eh", "value": "default", "section": "compiler", "machine": "build", "choices": ["none", "default", "a", "s", "sc"], "type": "combo", "description": "C++ exception handling type."}, {"name": "build.cpp_link_args", "value": [], "section": "compiler", "machine": "build", "type": "array", "description": "Extra arguments passed to the cpp linker"}, {"name": "build.cpp_rtti", "value": true, "section": "compiler", "machine": "build", "type": "boolean", "description": "Enable RTTI"}, {"name": "build.cpp_std", "value": "none", "section": "compiler", "machine": "build", "choices": ["none", "c++98", "c++03", "c++11", "c++14", "c++17", "c++1z", "c++2a", "gnu++03", "gnu++11", "gnu++14", "gnu++17", "gnu++1z", "gnu++2a"], "type": "combo", "description": "C++ language standard to use"}, {"name": "bindir", "value": "bin", "section": "directory", "machine": "any", "type": "string", "description": "Executable directory"}, {"name": "datadir", "value": "share", "section": "directory", "machine": "any", "type": "string", "description": "Data file directory"}, {"name": "includedir", "value": "include", "section": "directory", "machine": "any", "type": "string", "description": "Header file directory"}, {"name": "infodir", "value": "share/info", "section": "directory", "machine": "any", "type": "string", "description": "Info page directory"}, {"name": "libdir", "value": "lib", "section": "directory", "machine": "any", "type": "string", "description": "Library directory"}, {"name": "libexecdir", "value": "libexec", "section": "directory", "machine": "any", "type": "string", "description": "Library executable directory"}, {"name": "localedir", "value": "share/locale", "section": "directory", "machine": "any", "type": "string", "description": "Locale data directory"}, {"name": "localstatedir", "value": "var", "section": "directory", "machine": "any", "type": "string", "description": "Localstate data directory"}, {"name": "mandir", "value": "share/man", "section": "directory", "machine": "any", "type": "string", "description": "Manual page directory"}, {"name": "prefix", "value": "/home/user/.local/share/lemon/sysroot", "section": "directory", "machine": "any", "type": "string", "description": "Installation prefix"}, {"name": "sbindir", "value": "sbin", "section": "directory", "machine": "any", "type": "string", "description": "System executable directory"}, {"name": "sharedstatedir", "value": "com", "section": "directory", "machine": "any", "type": "string", "description": "Architecture-independent data directory"}, {"name": "sysconfdir", "value": "etc", "section": "directory", "machine": "any", "type": "string", "description": "Sysconf data directory"}, {"name": "errorlogs", "value": true, "section": "test", "machine": "any", "type": "boolean", "description": "Whether to print the logs from failing tests"}, {"name": "stdsplit", "value": true, "section": "test", "machine": "any", "type": "boolean", "description": "Split stdout and stderr in test logs"}]
Kernel/build/meson-info/intro-targets.json:[{"name": "lai", "id": "cf89b58@@lai@sta", "type": "static library", "defined_in": "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/meson.build", "filename": ["/mnt/e/OneDrive/Lemon/Kernel/build/subprojects/lai/liblai.a"], "build_by_default": true, "target_sources": [{"language": "c", "compiler": ["x86_64-lemon-gcc"], "parameters": ["-I/mnt/e/OneDrive/Lemon/Kernel/build/subprojects/lai/cf89b58@@lai@sta", "-I/mnt/e/OneDrive/Lemon/Kernel/build/subprojects/lai", "-I/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai", "-I/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/include", "-fdiagnostics-color=always", "-pipe", "-D_FILE_OFFSET_BITS=64", "-Wall", "-Winvalid-pch", "-g"], "sources": ["/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/error.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/eval.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/exec.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/exec-operand.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/libc.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/ns.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/object.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/opregion.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/os_methods.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/variable.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/vsnprintf.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pc-bios.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pci.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/resource.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/sci.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pm.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/drivers/ec.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/drivers/timer.c"], "generated_sources": []}], "subproject": "lai", "installed": false}, {"name": "kernel.sys", "id": "kernel.sys@exe", "type": "executable", "defined_in": "/mnt/e/OneDrive/Lemon/Kernel/meson.build", "filename": ["/mnt/e/OneDrive/Lemon/Kernel/build/kernel.sys"], "build_by_default": true, "target_sources": [{"language": "cpp", "compiler": ["x86_64-lemon-gcc"], "parameters": ["-I/mnt/e/OneDrive/Lemon/Kernel/build/kernel.sys@exe", "-I/mnt/e/OneDrive/Lemon/Kernel/build", "-I/mnt/e/OneDrive/Lemon/Kernel", "-I/mnt/e/OneDrive/Lemon/Kernel/include", "-I/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/include", "-I/mnt/e/OneDrive/Lemon/Kernel/include/arch/x86_64", "-fdiagnostics-color=always", "-pipe", "-D_FILE_OFFSET_BITS=64", "-Wall", "-Winvalid-pch", "-Wnon-virtual-dtor", "-g", "-Wno-write-strings", "-Wno-pointer-arith", "-ffreestanding", "-nostdlib", "-mcmodel=large", "-mno-red-zone", "-fno-pic", "-mno-mmx", "-mno-sse", "-mno-sse2", "-z", "max-page-size=0x1000", "-fno-stack-protector", "-fno-exceptions", "-fno-rtti", "-Wno-write-strings", "-Wno-pointer-arith", "-DLemon64", "-ffreestanding", "-nostdlib", "-mcmodel=large", "-mno-red-zone", "-fno-pic", "-mno-mmx", "-mno-sse", "-mno-sse2", "-z", "max-page-size=0x1000", "-fno-stack-protector", "-fno-exceptions", "-fno-rtti"], "sources": ["/mnt/e/OneDrive/Lemon/Kernel/src/kernel.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/characterbuffer.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/devicemanager.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/gpt.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/gui.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/lemon.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/logging.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/math.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/panic.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/runtime.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/string.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/video.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/videoconsole.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/sharedmem.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/fs/fat32.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/fs/filesystem.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/fs/fsvolume.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/fs/tar.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/liballoc/_liballoc.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/net/8254x.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/ahci.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/ahciport.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/ata.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/atadrive.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/diskdevice.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/nvme.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/storage/partitiondevice.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/tty/pty.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/usb/xhci.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/acpi.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/apic.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/cpuid.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/hal.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/idt.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/keyboard.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/mouse.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/paging.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/pci.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/physicalallocator.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/scheduler.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/serial.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/smp.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/sse2.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/ssp.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/syscalls.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/system.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/timer.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/tss.cpp", "/mnt/e/OneDrive/Lemon/Kernel/src/arch/x86_64/elf.cpp"], "generated_sources": []}, {"language": "c", "compiler": ["x86_64-lemon-gcc"], "parameters": ["-I/mnt/e/OneDrive/Lemon/Kernel/build/kernel.sys@exe", "-I/mnt/e/OneDrive/Lemon/Kernel/build", "-I/mnt/e/OneDrive/Lemon/Kernel", "-I/mnt/e/OneDrive/Lemon/Kernel/include", "-I/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/include", "-I/mnt/e/OneDrive/Lemon/Kernel/include/arch/x86_64", "-fdiagnostics-color=always", "-pipe", "-D_FILE_OFFSET_BITS=64", "-Wall", "-Winvalid-pch", "-g", "-Wno-write-strings", "-Wno-pointer-arith", "-DLemon64", "-ffreestanding", "-nostdlib", "-mcmodel=large", "-mno-red-zone", "-fno-pic", "-mno-mmx", "-mno-sse", "-mno-sse2", "-z", "max-page-size=0x1000", "-fno-stack-protector", "-fno-exceptions", "-fno-rtti"], "sources": ["/mnt/e/OneDrive/Lemon/Kernel/src/liballoc/liballoc.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/error.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/eval.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/exec.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/exec-operand.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/libc.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/ns.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/object.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/opregion.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/os_methods.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/variable.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/core/vsnprintf.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pc-bios.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pci.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/resource.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/sci.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/helpers/pm.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/drivers/ec.c", "/mnt/e/OneDrive/Lemon/Kernel/subprojects/lai/drivers/timer.c"], "generated_sources": []}], "subproject": null, "installed": false}]
Kernel/build/meson-info/meson-info.json:{"meson_version": {"full": "0.53.2", "major": 0, "minor": 53, "patch": 2}, "directories": {"source": "/mnt/e/OneDrive/Lemon/Kernel", "build": "/mnt/e/OneDrive/Lemon/Kernel/build", "info": "/mnt/e/OneDrive/Lemon/Kernel/build/meson-info"}, "introspection": {"version": {"full": "1.0.0", "major": 1, "minor": 0, "patch": 0}, "information": {"benchmarks": {"file": "intro-benchmarks.json", "updated": true}, "buildoptions": {"file": "intro-buildoptions.json", "updated": true}, "buildsystem_files": {"file": "intro-buildsystem_files.json", "updated": true}, "dependencies": {"file": "intro-dependencies.json", "updated": true}, "installed": {"file": "intro-installed.json", "updated": true}, "projectinfo": {"file": "intro-projectinfo.json", "updated": true}, "targets": {"file": "intro-targets.json", "updated": true}, "tests": {"file": "intro-tests.json", "updated": true}}}, "build_files_updated": true, "error": false}
Kernel/build/meson-logs/meson-log.txt:Build started at 2020-05-11T13:33:21.712583
Kernel/build/meson-logs/meson-log.txt:Build Options: -Dbackend=ninja
Kernel/build/meson-logs/meson-log.txt:C compiler for the build machine: cc (gcc 7.5.0 "cc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0")
Kernel/build/meson-logs/meson-log.txt:C++ compiler for the build machine: c++ (gcc 7.5.0 "c++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0")
Kernel/build/meson-logs/meson-log.txt:C compiler for the host machine: x86_64-lemon-gcc (gcc 8.2.0 "x86_64-lemon-gcc (GCC) 8.2.0")
Kernel/build/meson-logs/meson-log.txt:C linker for the host machine: x86_64-lemon-gcc ld.bfd 2.32
Kernel/build/meson-logs/meson-log.txt:C++ compiler for the host machine: x86_64-lemon-gcc (gcc 8.2.0 "x86_64-lemon-gcc (GCC) 8.2.0")
Kernel/build/meson-logs/meson-log.txt:C++ linker for the host machine: x86_64-lemon-gcc ld.bfd 2.32
Kernel/build/meson-logs/meson-log.txt:C compiler for the build machine: cc (gcc 7.5.0 "cc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0")
Kernel/build/meson-logs/meson-log.txt:C compiler for the host machine: x86_64-lemon-gcc (gcc 8.2.0 "x86_64-lemon-gcc (GCC) 8.2.0")
Kernel/build/meson-logs/meson-log.txt:C linker for the host machine: x86_64-lemon-gcc ld.bfd 2.32
Kernel/build/meson-logs/meson-log.txt:Found ninja-1.8.2 at /usr/bin/ninja
Kernel/build/meson-logs/meson-log.txt:Working directory:  /mnt/e/OneDrive/Lemon/Kernel/build/meson-private/tmpgyha10s3
Kernel/build/meson-logs/meson-log.txt:Command line:  x86_64-lemon-gcc /mnt/e/OneDrive/Lemon/Kernel/build/meson-private/tmpgyha10s3/testfile.cpp -o /mnt/e/OneDrive/Lemon/Kernel/build/meson-private/tmpgyha10s3/output.obj -pipe -c -D_FILE_OFFSET_BITS=64 -O0 -fpermissive --print-search-dirs 
Kernel/build/meson-logs/meson-log.txt: install: /home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/
Kernel/build/meson-logs/meson-log.txt:programs: =/home/user/.local/share/lemon/libexec/gcc/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/libexec/gcc/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/libexec/gcc/x86_64-lemon/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/../../../../x86_64-lemon/bin/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/../../../../x86_64-lemon/bin/
Kernel/build/meson-logs/meson-log.txt:libraries: =/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/../../../../x86_64-lemon/lib/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/lib/gcc/x86_64-lemon/8.2.0/../../../../x86_64-lemon/lib/:/home/user/.local/share/lemon/sysroot/lib/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/sysroot/lib/:/home/user/.local/share/lemon/sysroot/lib/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/sysroot/lib/:/home/user/.local/share/lemon/sysroot/usr/lib/x86_64-lemon/8.2.0/:/home/user/.local/share/lemon/sysroot/usr/lib/
Binary file Kernel/build/meson-private/build.dat matches
Kernel/build/meson-private/cmd_line.txt:cross_file = ['../Scripts/lemon-crossfile.txt']
Binary file Kernel/build/meson-private/coredata.dat matches
Binary file Kernel/build/meson-private/coredata.dat.prev matches
Binary file Kernel/build/meson-private/install.dat matches
Binary file Kernel/build/meson-private/sanitycheckc.exe matches
Binary file Kernel/build/meson-private/sanitycheckcpp.exe matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_error.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_eval.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_exec-operand.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_exec.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_libc.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_ns.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_object.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_opregion.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_os_methods.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_variable.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/core_vsnprintf.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/drivers_ec.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/drivers_timer.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/helpers_pc-bios.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/helpers_pci.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/helpers_pm.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/helpers_resource.c.o matches
Binary file Kernel/build/subprojects/lai/cf89b58@@lai@sta/helpers_sci.c.o matches
Binary file Kernel/build/subprojects/lai/liblai.a matches
Kernel/include/ahci.h:	FIS_TYPE_REG_H2D	= 0x27,	// Register FIS - host to device
Kernel/include/ahci.h:	FIS_TYPE_REG_D2H	= 0x34,	// Register FIS - device to host
Kernel/include/ahci.h:	FIS_TYPE_DMA_ACT	= 0x39,	// DMA activate FIS - device to host
Kernel/include/ahci.h:	FIS_TYPE_DMA_SETUP	= 0x41,	// DMA setup FIS - bidirectional
Kernel/include/ahci.h:	FIS_TYPE_DATA		= 0x46,	// Data FIS - bidirectional
Kernel/include/ahci.h:	FIS_TYPE_BIST		= 0x58,	// BIST activate FIS - bidirectional
Kernel/include/ahci.h:	FIS_TYPE_PIO_SETUP	= 0x5F,	// PIO setup FIS - device to host
Kernel/include/ahci.h:	FIS_TYPE_DEV_BITS	= 0xA1,	// Set device bits FIS - device to host
Kernel/include/ahci.h:	uint8_t  d:1;		// Data transfer direction, 1 - device to host
Kernel/include/ahci.h:	uint8_t  d:1;		// Data transfer direction, 1 - device to host
Kernel/include/ahci.h:	uint8_t  a:1;            // Auto-activate. Specifies if DMA Activate FIS is needed
Kernel/include/ahci.h:	uint32_t clb;		// 0x00, command list base address, 1K-byte aligned
Kernel/include/ahci.h:	uint32_t fb;		// 0x08, FIS base address, 256-byte aligned
Kernel/include/ahci.h:	uint32_t fbs;		// 0x40, FIS-based switch control
Kernel/include/ahci.h:	// 0x00 - 0x2B, Generic Host Control
Kernel/include/ahci.h:	// 0x2C - 0x9F, Reserved
Kernel/include/ahci.h:	uint8_t  rsv[0xA0-0x2C];
Kernel/include/ahci.h:	// 0xA0 - 0xFF, Vendor specific registers
Kernel/include/ahci.h:	uint8_t  vendor[0x100-0xA0];
Kernel/include/ahci.h:	// 0x100 - 0x10FF, Port control registers
Kernel/include/ahci.h:	uint8_t   	rsv[0x100-0xA0];
Kernel/include/ahci.h:	// DW4 - 7
Kernel/include/ahci.h:    	port->cmd &= ~HBA_PxCMD_ST;
Kernel/include/ahci.h:		while (port->cmd & HBA_PxCMD_CR);
Kernel/include/ahci.h:		port->cmd |= HBA_PxCMD_FRE;
Kernel/include/ahci.h:		port->cmd |= HBA_PxCMD_ST; 
Kernel/include/ahci.h:		port->cmd &= ~HBA_PxCMD_ST;
Kernel/include/ahci.h:			if (port->cmd & HBA_PxCMD_CR)
Kernel/include/ahci.h:		port->cmd &= ~HBA_PxCMD_FRE;
Kernel/include/arch/x86/elf.h:#define EI_CLASS 4 // 0 - Invalid, 1 - 32-bit, 2 - 64-bit
Kernel/include/arch/x86_64/acpi.h:typedef struct LocalAPIC{ // Local APIC - Type 0
Kernel/include/arch/x86_64/acpi.h:  uint32_t flags; // Flags - (bit 0 = enabled, bit 1 = online capable)
Kernel/include/arch/x86_64/acpi.h:typedef struct IOAPIC{ // I/O APIC - Type 1
Kernel/include/arch/x86_64/acpi.h:typedef struct ISO{ // Interrupt Source Override - Type 2
Kernel/include/arch/x86_64/acpi.h:typedef struct NMI{ // Non-maskable Interrupt - Type 4
Kernel/include/arch/x86_64/acpi.h:typedef struct LocalAPICAddressOverride { // Local APIC Address Override - Type 5
Kernel/include/arch/x86_64/acpi.h:  uint64_t address; // 64-bit Address of Local APIC
Kernel/include/arch/x86_64/apic.h:#define LOCAL_APIC_ISR 0x100 // In-service Register
Kernel/include/arch/x86_64/paging.h:#define IO_VIRTUAL_BASE (KERNEL_VIRTUAL_BASE - 0x100000000ULL) // KERNEL_VIRTUAL_BASE - 4GB
Kernel/include/atadrive.h:        int drive; // 0 - Master, 1 - Slave
Kernel/include/fat32.h:                name[nameIndex++] = ent->characters0[j];
Kernel/include/fat32.h:               name[nameIndex++] = ent->characters1[j];
Kernel/include/fat32.h:            name[nameIndex++] = ent->characters2[0];
Kernel/include/fat32.h:            name[nameIndex++] = ent->characters2[1];
Kernel/include/fsvolume.h:            mountPoint = link->mountPoint;
Kernel/include/fsvolume.h:            mountPoint.link = &link->mountPoint;
Kernel/include/fsvolume.h:            volumeParent = link->volumeParent;
Kernel/include/gui.h:	int x, y, width, height, pitch; // Self-explanatory
Kernel/include/list.h:		while (node->next) {
Kernel/include/list.h:		while (node && node->next) {
Kernel/include/list.h:			ListNode<T>* n = node->next;
Kernel/include/list.h:		node->obj = obj;
Kernel/include/list.h:			back->next = node;
Kernel/include/list.h:			node->prev = back;
Kernel/include/list.h:		node->obj = obj;
Kernel/include/list.h:			front->prev = node;
Kernel/include/list.h:			node->next = front;
Kernel/include/list.h:		for (unsigned int i = 0; i < pos && i < num && current->next; i++) current = current->next;
Kernel/include/list.h:		return current->obj;
Kernel/include/list.h:		for (unsigned int i = 0; i < pos; i++) current = current->next;
Kernel/include/list.h:			current->obj = obj;
Kernel/include/list.h:		for (unsigned int i = 0; i < pos && current; i++) current = current->next;
Kernel/include/list.h:		T obj = current->obj;
Kernel/include/list.h:		if (current->next) current->next->prev = current->prev;
Kernel/include/list.h:		if (current->prev) current->prev->next = current->next;
Kernel/include/list.h:		if (pos == 0) front = current->next;
Kernel/include/list.h:		if (pos == --num) back = current->prev;
Kernel/include/list.h:		return front->obj;
Kernel/include/list.h:		return back->obj;
Kernel/include/tar.h:    int entryCount; // For Directories - Amount of child nodes
Kernel/include/tar.h:    ino_t* children; // For Directories - Inodes of children
Kernel/include/xhci.h:#define USB_STS_HCH (1 << 0) // HCHalted - 0 if CMD_RS is 1
Kernel/include/xhci.h:#define USB_STS_HSE (1 << 2) // Host System Error - set to 1 on error
Kernel/include/xhci.h:#define USB_STS_SSS (1 << 8) // Save State Status - 1 when CMD_CSS is 1
Kernel/include/xhci.h:#define USB_STS_RSS (1 << 9) // Restore State Status - 1 when CMD_CRS is 1
Kernel/include/xhci.h:#define USB_STS_SRE (1 << 10) // Save/Restore Error - 1 when error during save or restore operation
Kernel/include/xhci.h:#define USB_STS_CNR (1 << 11) // Controller Not Ready - 0 = Ready, 1 = Not Ready
Kernel/linkscript-x86.ld:OUTPUT_FORMAT(elf32-i386)
Kernel/linkscript-x86.ld:   .text ALIGN(4096) : AT(ADDR(.text) - KERNEL_VIRTUAL_BASE) {
Kernel/linkscript-x86.ld:   .data ALIGN (4096) : AT(ADDR(.data) - KERNEL_VIRTUAL_BASE) {
Kernel/linkscript-x86.ld:   .bss ALIGN (4096) : AT(ADDR(.bss) - KERNEL_VIRTUAL_BASE) {
Kernel/linkscript-x86_64.ld:    .text : AT(ADDR(.text) - KERNEL_VMA)
Kernel/linkscript-x86_64.ld:   .data : AT(ADDR(.data) - KERNEL_VMA)
Kernel/linkscript-x86_64.ld:   .eh_frame : AT(ADDR(.eh_frame) - KERNEL_VMA)
Kernel/linkscript-x86_64.ld:   .bss : AT(ADDR(.bss) - KERNEL_VMA)
Kernel/meson.build:        '-f', 'elf64',
Kernel/meson.build:        '-g', '-F', 'dwarf', '-w+gnu-elf-extensions',
Kernel/meson.build:        '-o', '@OUTPUT@'])
Kernel/meson.build:kernel_cpp_args = ['-Wno-write-strings', '-Wno-pointer-arith',
Kernel/meson.build:    '-DLemon64',
Kernel/meson.build:    '-ffreestanding', '-nostdlib',
Kernel/meson.build:    '-mcmodel=large', '-mno-red-zone', '-fno-pic',
Kernel/meson.build:    '-mno-mmx', '-mno-sse', '-mno-sse2',
Kernel/meson.build:    '-z', 'max-page-size=0x1000',
Kernel/meson.build:    '-fno-stack-protector', '-fno-exceptions', '-fno-rtti']
Kernel/meson.build:    '-m64',
Kernel/meson.build:    '-T', meson.current_source_dir() + '/linkscript-x86_64.ld',
Kernel/meson.build:    '-lgcc'
Kernel/meson.build:    cpp_args : kernel_cpp_args, link_args: kernel_link_args, link_depends: 'linkscript-x86_64.ld')
Kernel/src/arch/x86/entry.asm:CHECKSUM    equ -(MAGIC + FLAGS)
Kernel/src/arch/x86/gdt.cpp:		gdt_ptr.limit = sizeof(gdt_entry_t) * 5 - 1;
Kernel/src/arch/x86/idt.cpp:		idt_ptr.limit = sizeof(idt_entry_t) * 256 - 1;
Kernel/src/arch/x86/idt.cpp:		if (interrupt_handlers[regs->int_num] != 0) {
Kernel/src/arch/x86/idt.cpp:			interrupt_handlers[regs->int_num](regs);
Kernel/src/arch/x86/idt.cpp:		} else if(regs->int_num == 0x69){
Kernel/src/arch/x86/idt.cpp:			//Log::Info(itoa(regs->int_num));
Kernel/src/arch/x86/idt.cpp:			Log::Error(itoa(regs->eip,0,16));
Kernel/src/arch/x86/idt.cpp:			Log::Error(itoa(regs->err_code,0,16));
Kernel/src/arch/x86/idt.cpp:		if (regs->int_num >= 40) {
Kernel/src/arch/x86/idt.cpp:		if (interrupt_handlers[regs->int_num] != 0) {
Kernel/src/arch/x86/idt.cpp:			handler = interrupt_handlers[regs->int_num];
Kernel/src/arch/x86/keyboard.cpp:	'9', '0', '-', '=', '\b',	/* Backspace */
Kernel/src/arch/x86/keyboard.cpp:	0,			/* 29   - Control */
Kernel/src/arch/x86/keyboard.cpp:	0,	/* 59 - F1 key ... > */
Kernel/src/arch/x86/keyboard.cpp:	0,	/* 69 - Num lock*/
Kernel/src/arch/x86/keyboard.cpp:	'-',
Kernel/src/arch/x86/keyboard.cpp:	0,	/* 79 - End key*/
Kernel/src/arch/x86/keyboard.cpp:            test[0] = keymap_us[(key >> 7) ? key-128 :key];
Kernel/src/arch/x86/keyboard.cpp:            wmKeyMessage.id = 0x1BEEF; // Desktop Event - Key Press
Kernel/src/arch/x86/keyboard.cpp:        wmKeyMessage.id = 0x1BEEF; // Desktop Event - Key Press
Kernel/src/arch/x86/mouse.cpp:			while (timeout--) //Data
Kernel/src/arch/x86/mouse.cpp:			while (timeout--) //Signal
Kernel/src/arch/x86/paging.cpp:						SetPDEFrame(&((*dir.page_directory)[page_dir_index]),(uint32_t)&(dir.page_tables[page_dir_index]) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:						counter--;
Kernel/src/arch/x86/paging.cpp:						SetPDEFrame(&((*dir.page_directory)[page_dir_index]),(uint32_t)&(dir.page_tables[page_dir_index]) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:						counter--;
Kernel/src/arch/x86/paging.cpp:						SetPDEFrame(&(kernelPageDirectory[page_dir_index]),(uint32_t)&(kernelPageTables[page_dir_index]) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:						counter--;
Kernel/src/arch/x86/paging.cpp:			SetPDEFrame(&((*currentPageDirectory)[pdindex]), (uint32_t)&(currentPageTables[pdindex]) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:			SetPDEFrame(&(kernelPageDirectory[pdindex]), ((uint32_t)&(kernelPageTables[pdindex])) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:			SetPDEFrame(&(kernelPageDirectory[pdindex]), ((uint32_t)(&(kernelPageTables[pdindex]))) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:		SwitchPageDirectory((uint32_t)kernelPageDirectory - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:		SwitchPageDirectory((uint32_t)kernelPageDirectory - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:		return (uint32_t)kernelPageDirectory - 0xC0000000;
Kernel/src/arch/x86/paging.cpp:			SetPDEFrame(&((*ptr.page_directory)[i]), (uint32_t)&(kernelPageTables[i]) - 0xC0000000);
Kernel/src/arch/x86/paging.cpp:		int present = !(regs->err_code & 0x1); // Page not present
Kernel/src/arch/x86/paging.cpp:		int rw = regs->err_code & 0x2;           // Attempted write to read only page
Kernel/src/arch/x86/paging.cpp:		int us = regs->err_code & 0x4;           // Processor was in user-mode and tried to access kernel page
Kernel/src/arch/x86/paging.cpp:		int reserved = regs->err_code & 0x8;     // Overwritten CPU-reserved bits of page entry
Kernel/src/arch/x86/paging.cpp:		int id = regs->err_code & 0x10;          // Caused by an instruction fetch
Kernel/src/arch/x86/paging.cpp:		Log::Info(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86/paging.cpp:		Log::Info(regs->eip);
Kernel/src/arch/x86/paging.cpp:		char* reasons[]{"Page Fault","EIP: ", itoa(regs->eip, temp, 16),"Address: ",itoa(faultAddress, temp2, 16), "Process:", itoa(Scheduler::GetCurrentProcess()->pid,temp3,10)};;
Kernel/src/arch/x86/pci.cpp:			for(int i = 0; i < devices->get_length(); i++){
Kernel/src/arch/x86/pci.cpp:				if(devices->get_at(i).deviceID == device.deviceID && devices->get_at(i).vendorID == device.vendorID){
Kernel/src/arch/x86/pci.cpp:					dev = devices->get_at(i);
Kernel/src/arch/x86/pci.cpp:					devices->replace_at(i, dev);
Kernel/src/arch/x86/pci.cpp:			for(int i = 0; i < devices->get_length(); i++){
Kernel/src/arch/x86/pci.cpp:				if(devices->get_at(i).classCode == device.classCode && devices->get_at(i).subclass == device.subclass){
Kernel/src/arch/x86/pci.cpp:					dev = devices->get_at(i);
Kernel/src/arch/x86/pci.cpp:					devices->replace_at(i, dev);
Kernel/src/arch/x86/pci.cpp:					devices->add_back(device);
Kernel/src/arch/x86/physicalallocator.cpp:        multiboot_memory_map_t* mem_map = mem_info->mem_map;
Kernel/src/arch/x86/physicalallocator.cpp:        multiboot_memory_map_t* mem_map_end = (multiboot_memory_map_t*)(mem_info->mem_map + mem_info->memory_map_len);
Kernel/src/arch/x86/physicalallocator.cpp:            if (mem_map->type == 1)
Kernel/src/arch/x86/physicalallocator.cpp:                MarkMemoryRegionFree(mem_map->base, mem_map->length);
Kernel/src/arch/x86/physicalallocator.cpp:            mem_map = (multiboot_memory_map_t*)((uint32_t)mem_map + mem_map->size + sizeof(mem_map->size));
Kernel/src/arch/x86/physicalallocator.cpp:        maxPhysicalBlocks = mem_info->memory_high * 1024 / PHYSALLOC_BLOCK_SIZE;
Kernel/src/arch/x86/physicalallocator.cpp:        for (uint32_t blocks = size / PHYSALLOC_BLOCK_SIZE + 1, align = base / PHYSALLOC_BLOCK_SIZE; blocks > 0; blocks--, usedPhysicalBlocks++)
Kernel/src/arch/x86/physicalallocator.cpp:        for (uint32_t blocks = size / PHYSALLOC_BLOCK_SIZE + 1, align = base / PHYSALLOC_BLOCK_SIZE; blocks > 0; blocks--, usedPhysicalBlocks++)
Kernel/src/arch/x86/physicalallocator.cpp:        usedPhysicalBlocks--;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess->pageDirectory.page_directory_phys = Memory::GetKernelPageDirectory();
Kernel/src/arch/x86/scheduler.cpp:        processEntryPoint = currentProcess->threads[0].registers.eip;
Kernel/src/arch/x86/scheduler.cpp:        processStack = currentProcess->threads[0].registers.esp;
Kernel/src/arch/x86/scheduler.cpp:        processBase = currentProcess->threads[0].registers.ebp;
Kernel/src/arch/x86/scheduler.cpp:        processPageDirectory = currentProcess->pageDirectory.page_directory_phys;
Kernel/src/arch/x86/scheduler.cpp:        index.owner_pid = currentProcess->pid;
Kernel/src/arch/x86/scheduler.cpp:        handles->add_back(index);
Kernel/src/arch/x86/scheduler.cpp:        for(int i = 0; i < handles->get_length(); i++){
Kernel/src/arch/x86/scheduler.cpp:        if(pid == proc->pid) return proc;
Kernel/src/arch/x86/scheduler.cpp:            proc = proc->next;
Kernel/src/arch/x86/scheduler.cpp:            if(pid == proc->pid) return proc;
Kernel/src/arch/x86/scheduler.cpp:            proc = proc->next;
Kernel/src/arch/x86/scheduler.cpp:        proc->messageQueue.add_back(msg);
Kernel/src/arch/x86/scheduler.cpp:        proc->messageQueue.add_back(msg); // Add message to queue
Kernel/src/arch/x86/scheduler.cpp:        if(proc->messageQueue.get_length() <= 0){
Kernel/src/arch/x86/scheduler.cpp:        return proc->messageQueue.remove_at(0);
Kernel/src/arch/x86/scheduler.cpp:            proc->next = proc;
Kernel/src/arch/x86/scheduler.cpp:        else if(processQueueStart->next){ // More than 1 process in queue?
Kernel/src/arch/x86/scheduler.cpp:            proc->next = processQueueStart->next;
Kernel/src/arch/x86/scheduler.cpp:            processQueueStart->next = proc;
Kernel/src/arch/x86/scheduler.cpp:            processQueueStart->next = proc;
Kernel/src/arch/x86/scheduler.cpp:            proc->next = processQueueStart;
Kernel/src/arch/x86/scheduler.cpp:        process_t* _proc = proc->next;
Kernel/src/arch/x86/scheduler.cpp:        process_t* nextProc = proc->next;
Kernel/src/arch/x86/scheduler.cpp:        while(_proc->next && _proc != proc){
Kernel/src/arch/x86/scheduler.cpp:            if(_proc->next == proc){
Kernel/src/arch/x86/scheduler.cpp:                _proc->next = nextProc;
Kernel/src/arch/x86/scheduler.cpp:            _proc = _proc->next;
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->pid = nextPID++; // Set Process ID to the next availiable
Kernel/src/arch/x86/scheduler.cpp:        proc->priority = 1;
Kernel/src/arch/x86/scheduler.cpp:        proc->thread_count = 1;
Kernel/src/arch/x86/scheduler.cpp:        proc->state = PROCESS_STATE_ACTIVE;
Kernel/src/arch/x86/scheduler.cpp:        proc->thread_count = 1;
Kernel/src/arch/x86/scheduler.cpp:        //proc->pageDirectory = Memory::CreateAddressSpace(); So far this function is only used for idle task, we don't need an address space
Kernel/src/arch/x86/scheduler.cpp:        proc->timeSliceDefault = 1;
Kernel/src/arch/x86/scheduler.cpp:        proc->timeSlice = proc->timeSliceDefault;
Kernel/src/arch/x86/scheduler.cpp:        thread_t* thread = proc->threads;
Kernel/src/arch/x86/scheduler.cpp:        thread->stack = 0;
Kernel/src/arch/x86/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86/scheduler.cpp:        thread->priority = 1;
Kernel/src/arch/x86/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86/scheduler.cpp:        regs32_t* registers = &thread->registers;
Kernel/src/arch/x86/scheduler.cpp:        registers->eflags = 0x200;
Kernel/src/arch/x86/scheduler.cpp:        thread->stack = stack + 16384;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.esp = (uint32_t)thread->stack;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.ebp = (uint32_t)thread->stack;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.eip = (uint32_t)entry;
Kernel/src/arch/x86/scheduler.cpp:        return proc->pid;
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->fileDescriptors.add_back(NULL);
Kernel/src/arch/x86/scheduler.cpp:        proc->pid = nextPID++;
Kernel/src/arch/x86/scheduler.cpp:        proc->priority = 1;
Kernel/src/arch/x86/scheduler.cpp:        proc->thread_count = 1;
Kernel/src/arch/x86/scheduler.cpp:        proc->state = PROCESS_STATE_ACTIVE;
Kernel/src/arch/x86/scheduler.cpp:        proc->pageDirectory = Memory::CreateAddressSpace();
Kernel/src/arch/x86/scheduler.cpp:        proc->timeSliceDefault = 15;
Kernel/src/arch/x86/scheduler.cpp:                proc->programHeaders.add_back(elf_ph);
Kernel/src/arch/x86/scheduler.cpp:                    Memory::MapVirtualPages(phys,elf_ph.p_vaddr + i * PAGE_SIZE, 1/*, currentProcess->pageDirectory*/);
Kernel/src/arch/x86/scheduler.cpp:                    Memory::MapVirtualPages(phys,elf_ph.p_vaddr + i * PAGE_SIZE, 1, proc->pageDirectory);
Kernel/src/arch/x86/scheduler.cpp:                Memory::SwitchPageDirectory(currentProcess->pageDirectory.page_directory_phys);
Kernel/src/arch/x86/scheduler.cpp:        thread_t* thread = proc->threads;
Kernel/src/arch/x86/scheduler.cpp:        thread->stack = 0;
Kernel/src/arch/x86/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86/scheduler.cpp:        thread->priority = 1;
Kernel/src/arch/x86/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86/scheduler.cpp:        regs32_t* registers = &thread->registers;
Kernel/src/arch/x86/scheduler.cpp:        registers->eflags = 0x200;
Kernel/src/arch/x86/scheduler.cpp:        thread->stack = stack + 16384;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.esp = (uint32_t)thread->stack;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.ebp = (uint32_t)thread->stack;
Kernel/src/arch/x86/scheduler.cpp:        thread->registers.eip = elf_hdr.e_entry;
Kernel/src/arch/x86/scheduler.cpp:        return proc->pid;
Kernel/src/arch/x86/scheduler.cpp:        for(int i = 0; i < process->fileDescriptors.get_length(); i++){
Kernel/src/arch/x86/scheduler.cpp:            if(process->fileDescriptors[i])
Kernel/src/arch/x86/scheduler.cpp:                process->fileDescriptors[i]->close(process->fileDescriptors[i]);
Kernel/src/arch/x86/scheduler.cpp:        process->fileDescriptors.clear();
Kernel/src/arch/x86/scheduler.cpp:        for(int i = 0; i < process->programHeaders.get_length(); i++){
Kernel/src/arch/x86/scheduler.cpp:            elf32_program_header_t programHeader = process->programHeaders[i];
Kernel/src/arch/x86/scheduler.cpp:        currentProcess = process->next;
Kernel/src/arch/x86/scheduler.cpp:        processEntryPoint = currentProcess->threads[0].registers.eip;
Kernel/src/arch/x86/scheduler.cpp:        processStack = currentProcess->threads[0].registers.esp;
Kernel/src/arch/x86/scheduler.cpp:        processBase = currentProcess->threads[0].registers.ebp;
Kernel/src/arch/x86/scheduler.cpp:        processPageDirectory = currentProcess->pageDirectory.page_directory_phys;
Kernel/src/arch/x86/scheduler.cpp:        if(currentProcess->timeSlice > 0) {
Kernel/src/arch/x86/scheduler.cpp:            currentProcess->timeSlice--;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess->timeSlice = currentProcess->timeSliceDefault;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess->threads[0].registers.esp = currentESP;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess->threads[0].registers.eip = currentEIP;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess->threads[0].registers.ebp = currentEBP;
Kernel/src/arch/x86/scheduler.cpp:        currentProcess = currentProcess->next;
Kernel/src/arch/x86/scheduler.cpp:        processEntryPoint = currentProcess->threads[0].registers.eip;
Kernel/src/arch/x86/scheduler.cpp:        processStack = currentProcess->threads[0].registers.esp;
Kernel/src/arch/x86/scheduler.cpp:        processBase = currentProcess->threads[0].registers.ebp;
Kernel/src/arch/x86/scheduler.cpp:        processPageDirectory = currentProcess->pageDirectory.page_directory_phys;
Kernel/src/arch/x86/serial.cpp:	outportb(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
Kernel/src/arch/x86/sse2.cpp:	memcpy(dest, src, 0x10 - start_overflow);		
Kernel/src/arch/x86/sse2.cpp:	dest = dest; + 0x10-start_overflow;
Kernel/src/arch/x86/sse2.cpp:	count -= 0x10 - start_overflow;*/
Kernel/src/arch/x86/sse2.cpp:	size_t size_aligned = (count - overflow); // Size rounded DOWN to lowest multiple of 128 bits
Kernel/src/arch/x86/syscalls.cpp:	char* filepath = (char*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:		fs_node_t* node = current_node->findDir(current_node,file);
Kernel/src/arch/x86/syscalls.cpp:		if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/arch/x86/syscalls.cpp:	uint8_t* buffer = (uint8_t*)kmalloc(current_node->size);
Kernel/src/arch/x86/syscalls.cpp:	uint32_t a = current_node->read(current_node, 0, current_node->size, buffer);
Kernel/src/arch/x86/syscalls.cpp:	fs_node_t* node = Scheduler::GetCurrentProcess()->fileDescriptors[r->ebx];
Kernel/src/arch/x86/syscalls.cpp:	if(!node){ Log::Warning("read failed! file descriptor: "); Log::Info(r->ebx, false); return 1; }
Kernel/src/arch/x86/syscalls.cpp:	uint8_t* buffer = (uint8_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t count = r->edx;
Kernel/src/arch/x86/syscalls.cpp:	int ret = node->read(node, 0, count, buffer);
Kernel/src/arch/x86/syscalls.cpp:	*(int*)r->esi = ret;
Kernel/src/arch/x86/syscalls.cpp:	fs_node_t* node = Scheduler::GetCurrentProcess()->fileDescriptors[r->ebx];
Kernel/src/arch/x86/syscalls.cpp:		Log::Warning(r->ebx);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ecx && r->edx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	uint8_t* buffer = (uint8_t*)kmalloc(r->edx);
Kernel/src/arch/x86/syscalls.cpp:	memcpy(buffer, (uint8_t*)r->ecx, r->edx);
Kernel/src/arch/x86/syscalls.cpp:	int ret = fs::Write(node, 0, r->edx, buffer);
Kernel/src/arch/x86/syscalls.cpp:	if(r->esi){
Kernel/src/arch/x86/syscalls.cpp:		*((int*)r->esi) = ret;
Kernel/src/arch/x86/syscalls.cpp:	char* filepath = (char*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:		fd = Scheduler::GetCurrentProcess()->fileDescriptors.get_length();
Kernel/src/arch/x86/syscalls.cpp:		Scheduler::GetCurrentProcess()->fileDescriptors.add_back(root);
Kernel/src/arch/x86/syscalls.cpp:		*((uint32_t*)r->ecx) = fd;
Kernel/src/arch/x86/syscalls.cpp:		fs_node_t* node = current_node->findDir(current_node,file);
Kernel/src/arch/x86/syscalls.cpp:		if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/arch/x86/syscalls.cpp:		fd = Scheduler::GetCurrentProcess()->fileDescriptors.get_length();
Kernel/src/arch/x86/syscalls.cpp:		Scheduler::GetCurrentProcess()->fileDescriptors.add_back(node);
Kernel/src/arch/x86/syscalls.cpp:	*((uint32_t*)r->ecx) = fd;
Kernel/src/arch/x86/syscalls.cpp:	int fd = r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	fs_node_t* node = Scheduler::GetCurrentProcess()->fileDescriptors[fd];
Kernel/src/arch/x86/syscalls.cpp:		Log::Warning(r->ebx);
Kernel/src/arch/x86/syscalls.cpp:// SendMessage(message_t* msg) - Sends an IPC message to a process
Kernel/src/arch/x86/syscalls.cpp:	uint32_t pid = r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t id = r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t data = r->edx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t data2 = r->esi;
Kernel/src/arch/x86/syscalls.cpp:	message.senderPID = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86/syscalls.cpp:// RecieveMessage(message_t* msg) - Grabs next message on queue and copies it to msg
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1; // Was given null pointers
Kernel/src/arch/x86/syscalls.cpp:	message_t* msg = (message_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* queueSize = (uint32_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	*queueSize = Scheduler::GetCurrentProcess()->messageQueue.get_length();
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	else strcpy((char*)r->ebx, Lemon::versionString);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t virt = Memory::AllocateVirtualPages(r->ebx, Scheduler::GetCurrentProcess()->pageDirectory);
Kernel/src/arch/x86/syscalls.cpp:	for(uint32_t i = 0; i < r->ebx; i++){
Kernel/src/arch/x86/syscalls.cpp:		Memory::MapVirtualPages(phys,virt + i * PAGE_SIZE, 1, Scheduler::GetCurrentProcess()->pageDirectory);
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* addr = (uint32_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->esi)){
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* ret = (uint32_t*)r->esi;
Kernel/src/arch/x86/syscalls.cpp:	int fd = r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	if(fd >= Scheduler::GetCurrentProcess()->fileDescriptors.get_length() || !Scheduler::GetCurrentProcess()->fileDescriptors[fd]){
Kernel/src/arch/x86/syscalls.cpp:	switch(r->edx){
Kernel/src/arch/x86/syscalls.cpp:		*ret = Scheduler::GetCurrentProcess()->fileDescriptors[fd]->size;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* pid_ptr = (uint32_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	*pid_ptr = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	handle_t* handle_ptr = (handle_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	surface_t* surface_ptr = (surface_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	desktop->windows = new List<window_t*>();
Kernel/src/arch/x86/syscalls.cpp:	desktop->surface.buffer = (uint8_t*)kmalloc(HAL::videoMode.pitch*HAL::videoMode.height);
Kernel/src/arch/x86/syscalls.cpp:	desktop->surface.height = HAL::videoMode.height;
Kernel/src/arch/x86/syscalls.cpp:	desktop->surface.width = HAL::videoMode.width;
Kernel/src/arch/x86/syscalls.cpp:	surface_ptr->width = HAL::videoMode.width;
Kernel/src/arch/x86/syscalls.cpp:	surface_ptr->height = HAL::videoMode.height;
Kernel/src/arch/x86/syscalls.cpp:	surface_ptr->depth = 32;
Kernel/src/arch/x86/syscalls.cpp:	handle_t* handlePtr = (handle_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ecx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	win_info_t winfo = *(win_info_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	win->info = winfo;
Kernel/src/arch/x86/syscalls.cpp:	strcpy(win->info.title, winfo.title);
Kernel/src/arch/x86/syscalls.cpp:	win->info.ownerPID = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86/syscalls.cpp:	//win->buffer = (uint8_t*)kmalloc(win->info.width*win->info.height*4+4);
Kernel/src/arch/x86/syscalls.cpp:	int horizontalSizePadded = winfo.width * 4 + (0x10 - ((winfo.width * 4) % 0x10));
Kernel/src/arch/x86/syscalls.cpp:	//surface.linePadding = (0x10 - ((winfo.width * 4) % 0x10));
Kernel/src/arch/x86/syscalls.cpp:	win->surface = surface;
Kernel/src/arch/x86/syscalls.cpp:	GetDesktop()->windows->add_back((window_t*)handle);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	handle_t handle = (handle_t)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	surface_t* surface = (surface_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	memcpy_optimized(/*desktop->surface.buffer*/(void*)HAL::videoMode.address,surface->buffer,desktop->surface.width*desktop->surface.height*4);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	handle_t handle = (handle_t)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	surface_t* surface = (surface_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	memcpy_optimized(window->surface.buffer,surface->buffer,(window->info.width * 4 /*+ window->surface.linePadding*/)*window->info.height);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ecx)){
Kernel/src/arch/x86/syscalls.cpp:	win_info_t* infoStruct = (win_info_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	window_t* window = (*(GetDesktop()->windows))[r->ebx];
Kernel/src/arch/x86/syscalls.cpp:	*infoStruct = window->info;
Kernel/src/arch/x86/syscalls.cpp:	//strcpy(infoStruct->title, window->info.title);
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	*((uint32_t*)r->ebx) = GetDesktop()->windows->get_length();
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	if(!r->edx) offset = {0,0};
Kernel/src/arch/x86/syscalls.cpp:	else offset = *((vector2i_t*)r->edx);
Kernel/src/arch/x86/syscalls.cpp:	handle_t handle = (handle_t)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	if(!r->edx) windowRegion = {{0,0},{window->info.width,window->info.height}};
Kernel/src/arch/x86/syscalls.cpp:	else windowRegion = *((rect_t*)r->esi);
Kernel/src/arch/x86/syscalls.cpp:	surface_t* dest = (surface_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	int rowSize = ((dest->width - offset.x) > windowRegion.size.x) ? windowRegion.size.x : (dest->width - offset.x);
Kernel/src/arch/x86/syscalls.cpp:	for(int i = windowRegion.pos.y; i < windowRegion.size.y && i < dest->height - offset.y; i++){
Kernel/src/arch/x86/syscalls.cpp:		uint8_t* bufferAddress = dest->buffer + (i + offset.y) * (dest->width * 4 /*+ dest->linePadding*/)+ offset.x * 4;
Kernel/src/arch/x86/syscalls.cpp:			memcpy_optimized(bufferAddress, window->surface.buffer + i * (window->info.width * 4 /*+ window->surface.linePadding*/) + windowRegion.pos.x * 4, rowSize * 4);
Kernel/src/arch/x86/syscalls.cpp:		//	memcpy(bufferAddress, window->surface.buffer + i * window->info.width * 4, rowSize*4);
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx && r->ecx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	unsigned int fd = r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	if(fd > Scheduler::GetCurrentProcess()->fileDescriptors.get_length()) return 2;
Kernel/src/arch/x86/syscalls.cpp:	fs_dirent_t* direntPointer = (fs_dirent_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	unsigned int count = r->edx;
Kernel/src/arch/x86/syscalls.cpp:	fs_dirent_t* dirent = fs::ReadDir(Scheduler::GetCurrentProcess()->fileDescriptors[fd],count);
Kernel/src/arch/x86/syscalls.cpp:		if(r->esi) *((uint32_t*)r->esi) = 0;
Kernel/src/arch/x86/syscalls.cpp:	direntPointer->inode = dirent->inode;
Kernel/src/arch/x86/syscalls.cpp:	direntPointer->type = dirent->type;
Kernel/src/arch/x86/syscalls.cpp:	strcpy(direntPointer->name,dirent->name);
Kernel/src/arch/x86/syscalls.cpp:	direntPointer->name[strlen(dirent->name)] = 0;
Kernel/src/arch/x86/syscalls.cpp:	if(r->esi) *((uint32_t*)r->esi) = 1;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* seconds = (uint32_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	uint32_t* milliseconds = (uint32_t*)r->ecx;
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	video_mode_t* v = (video_mode_t*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	if(!(r->ebx)) return 1;
Kernel/src/arch/x86/syscalls.cpp:	handle_t handle = (handle_t)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:	for(int i = 0; i < GetDesktop()->windows->get_length(); i++){
Kernel/src/arch/x86/syscalls.cpp:		if((*(desktop->windows))[i] == win)
Kernel/src/arch/x86/syscalls.cpp:			desktop->windows->remove_at(i);
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	PTY* pty = GrantPTY(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86/syscalls.cpp:	*((uint32_t*)r->ebx) = currentProcess->fileDescriptors.get_length();
Kernel/src/arch/x86/syscalls.cpp:	currentProcess->fileDescriptors.add_back(&pty->masterFile);
Kernel/src/arch/x86/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(0, &pty->slaveFile); // Stdin
Kernel/src/arch/x86/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(1, &pty->slaveFile); // Stdout
Kernel/src/arch/x86/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(2, &pty->slaveFile); // Stderr
Kernel/src/arch/x86/syscalls.cpp:	char* filepath = (char*)r->ebx;
Kernel/src/arch/x86/syscalls.cpp:		fs_node_t* node = current_node->findDir(current_node,file);
Kernel/src/arch/x86/syscalls.cpp:		if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/arch/x86/syscalls.cpp:	uint8_t* buffer = (uint8_t*)kmalloc(current_node->size);
Kernel/src/arch/x86/syscalls.cpp:	uint32_t a = current_node->read(current_node, 0, current_node->size, buffer);
Kernel/src/arch/x86/syscalls.cpp:	proc->fileDescriptors.clear();
Kernel/src/arch/x86/syscalls.cpp:	for(int i = 0; i < currentProc->fileDescriptors.get_length(); i++){
Kernel/src/arch/x86/syscalls.cpp:		proc->fileDescriptors.add_back(currentProc->fileDescriptors[i]);
Kernel/src/arch/x86/syscalls.cpp:	if(!r->ebx) return 1;
Kernel/src/arch/x86/syscalls.cpp:	memcpy((void*)r->ebx, &sysInfo, sizeof(sys_info_t));
Kernel/src/arch/x86/syscalls.cpp:	Log::Info((char*)r->ebx);
Kernel/src/arch/x86/syscalls.cpp:	Log::Info(r->ecx);
Kernel/src/arch/x86/syscalls.cpp:	if (regs->eax >= NUM_SYSCALLS) // If syscall is non-existant then return
Kernel/src/arch/x86/syscalls.cpp:	int ret = syscalls[regs->eax](regs); // Call syscall
Kernel/src/arch/x86/syscalls.cpp:		Log::Info(regs->eax, false);
Kernel/src/arch/x86/syscalls.cpp:	regs->eax = ret;
Kernel/src/arch/x86/timer.cpp:            ticks -= frequency;
Kernel/src/arch/x86/timer.cpp:        // Divisor has to be sent byte-wise, so split here into upper/lower bytes.
Kernel/src/arch/x86_64/acpi.cpp:		int entries = (rsdtHeader->header.length - sizeof(acpi_header_t)) / 4;
Kernel/src/arch/x86_64/acpi.cpp:		uint32_t* sdtPointers = rsdtHeader->tables;//(uint32_t*)(((uintptr_t)rsdtHeader) + sizeof(RSDTHeader));
Kernel/src/arch/x86_64/acpi.cpp:		if(memcmp("DSDT", signature, 4) == 0) return (void*)Memory::GetIOMapping(fadt->dsdt);
Kernel/src/arch/x86_64/acpi.cpp:			if (memcmp(h->signature, signature, 4) == 0 && _index++ == index)
Kernel/src/arch/x86_64/acpi.cpp:		void* madtEnd = madt + madtHeader->header.length;
Kernel/src/arch/x86_64/acpi.cpp:			switch(entry->type){
Kernel/src/arch/x86_64/acpi.cpp:					if(((apic_local_t*)entry)->flags & 0x3) {
Kernel/src/arch/x86_64/acpi.cpp:						Log::Info("[ACPI] Found Processor, APIC ID: %d, Enabled: %d", localAPIC->apicID, localAPIC->flags & 0x2);
Kernel/src/arch/x86_64/acpi.cpp:					Log::Info("[ACPI] Interrupt Source Override, IRQ: %d, GSI: %d", interruptSourceOverride->irqSource, interruptSourceOverride->gSI);
Kernel/src/arch/x86_64/acpi.cpp:				Log::Error("Invalid MADT Entry, Type: %d", entry->type);
Kernel/src/arch/x86_64/acpi.cpp:			madtEntry += entry->length;
Kernel/src/arch/x86_64/acpi.cpp:		rsdtHeader = ((acpi_rsdt_t*)Memory::GetIOMapping(desc->rsdt));
Kernel/src/arch/x86_64/acpi.cpp:		memcpy(oem,rsdtHeader->header.oem,6);
Kernel/src/arch/x86_64/acpi.cpp:		Log::Info("[ACPI] Revision: %d", rsdtHeader->header.revision);
Kernel/src/arch/x86_64/acpi.cpp:		lai_set_acpi_revision(rsdtHeader->header.revision);
Kernel/src/arch/x86_64/acpi.cpp:			if(totalTicksNew - totalTicks == (int)delayInTicks){
Kernel/src/arch/x86_64/elf.cpp:        for(int j = 0; j < (((elfPHdr.memSize + (elfPHdr.vaddr & (PAGE_SIZE_4K-1))) / PAGE_SIZE_4K)) + 1; j++){
Kernel/src/arch/x86_64/elf.cpp:            Memory::MapVirtualMemory4K(phys,base + elfPHdr.vaddr + j * PAGE_SIZE_4K, 1, proc->addressSpace);
Kernel/src/arch/x86_64/entry.asm:CHECKSUM    equ -(MAGIC + FLAGS)
Kernel/src/arch/x86_64/entry.asm:GDT64:                           ; Global Descriptor Table (64-bit).
Kernel/src/arch/x86_64/entry.asm:    .Null: equ $ - GDT64         ; The null descriptor.
Kernel/src/arch/x86_64/entry.asm:    .Code: equ $ - GDT64         ; The code descriptor.
Kernel/src/arch/x86_64/entry.asm:    .Data: equ $ - GDT64         ; The data descriptor.
Kernel/src/arch/x86_64/entry.asm:    .UserCode: equ $ - GDT64     ; The usermode code descriptor.
Kernel/src/arch/x86_64/entry.asm:    .UserData: equ $ - GDT64     ; The usermode data descriptor.
Kernel/src/arch/x86_64/entry.asm:    .TSS: ;equ $ - GDT64         ; TSS Descriptor
Kernel/src/arch/x86_64/entry.asm:    dw 108                       ; TSS Length - the x86_64 TSS is 108 bytes loong
Kernel/src/arch/x86_64/entry.asm:    .Pointer:                    ; The GDT-pointer.
Kernel/src/arch/x86_64/entry.asm:    dw $ - GDT64 - 1             ; Limit.
Kernel/src/arch/x86_64/entry.asm:    .Pointer64:                    ; The GDT-pointer.
Kernel/src/arch/x86_64/entry.asm:    dw .Pointer - GDT64 - 1             ; Limit.
Kernel/src/arch/x86_64/entry.asm:  jmp 0x8:entry64 - KERNEL_VIRTUAL_BASE
Kernel/src/arch/x86_64/hal.cpp:        multibootModulesAddress = Memory::GetIOMapping(multibootInfo.modsAddr); // Grub loads the kernel as 32-bit so modules will be <4GB
Kernel/src/arch/x86_64/hal.cpp:                .size = mod.mod_end - mod.mod_start,
Kernel/src/arch/x86_64/idt.cpp:		idt_ptr.limit = sizeof(idt_entry_t) * 256 - 1;
Kernel/src/arch/x86_64/idt.cpp:		else if(!(regs->ss & 0x3)){ // Check the CPL of the segment, caused by kernel?
Kernel/src/arch/x86_64/idt.cpp:			Log::Info(regs->rip);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rax);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rbx);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rcx);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rdx);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rsi);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rdi);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rsp);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rbp);
Kernel/src/arch/x86_64/idt.cpp:			uint64_t* stack = (uint64_t*)regs->rbp;
Kernel/src/arch/x86_64/idt.cpp:			const char* reasons[]{"Generic Exception","RIP: ", itoa(regs->rip, temp, 16),"Exception: ",itoa(int_num, temp2, 16), "Process:", itoa(Scheduler::GetCurrentProcess() ? (Scheduler::GetCurrentProcess()->pid) : 0,temp3,10)};;
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86_64/idt.cpp:			Log::Write(regs->rip);
Kernel/src/arch/x86_64/keyboard.cpp:	'9', '0', '-', '=', '\b',	/* Backspace */
Kernel/src/arch/x86_64/keyboard.cpp:	0,			/* 29   - Control */
Kernel/src/arch/x86_64/keyboard.cpp:	0,	/* 59 - F1 key ... > */
Kernel/src/arch/x86_64/keyboard.cpp:	0,	/* 69 - Num lock*/
Kernel/src/arch/x86_64/keyboard.cpp:	'-',
Kernel/src/arch/x86_64/keyboard.cpp:	0,	/* 79 - End key*/
Kernel/src/arch/x86_64/keyboard.cpp:            wmKeyMessage.recieverPID = GetDesktop()->pid; // Window Manager
Kernel/src/arch/x86_64/keyboard.cpp:            wmKeyMessage.msg = 0x1BEEF; // Desktop Event - Key Press
Kernel/src/arch/x86_64/mouse.cpp:			while (timeout--) //Data
Kernel/src/arch/x86_64/mouse.cpp:			while (timeout--) //Signal
Kernel/src/arch/x86_64/paging.cpp:			if((addressSpace->pageDirs[pdptIndex][pageDirIndex] & 0x1) && addressSpace->pageTables[pdptIndex][pageDirIndex])
Kernel/src/arch/x86_64/paging.cpp:				return addressSpace->pageTables[pdptIndex][pageDirIndex][pageTableIndex] & PAGE_FRAME;
Kernel/src/arch/x86_64/paging.cpp:		SetPageFrame(&(kernelPML4[PML4_GET_INDEX(KERNEL_VIRTUAL_BASE)]),((uint64_t)kernelPDPT - KERNEL_VIRTUAL_BASE));
Kernel/src/arch/x86_64/paging.cpp:		kernelPDPT[PDPT_GET_INDEX(KERNEL_VIRTUAL_BASE)] = ((uint64_t)kernelDir - KERNEL_VIRTUAL_BASE) | 0x3;
Kernel/src/arch/x86_64/paging.cpp:		SetPageFrame(&(kernelPDPT[KERNEL_HEAP_PDPT_INDEX]), (uint64_t)kernelHeapDir - KERNEL_VIRTUAL_BASE);
Kernel/src/arch/x86_64/paging.cpp:			kernelPDPT[PDPT_GET_INDEX(IO_VIRTUAL_BASE) + i] = ((uint64_t)ioDirs[i] - KERNEL_VIRTUAL_BASE) | 0x3;//(PAGE_SIZE_1G * i) | 0x83;
Kernel/src/arch/x86_64/paging.cpp:		kernelPML4Phys = (uint64_t)kernelPML4 - KERNEL_VIRTUAL_BASE;
Kernel/src/arch/x86_64/paging.cpp:		asm("mov %%rax, %%cr3" :: "a"((uint64_t)kernelPML4 - KERNEL_VIRTUAL_BASE));
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pageDirs = pageDirs;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pageDirsPhys = pageDirsPhys;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pageTables = pageTables;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pml4 = pml4;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pdptPhys = pdptPhys;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pml4Phys = pml4Phys;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pdpt = pdpt;
Kernel/src/arch/x86_64/paging.cpp:				pd_entry_t dirEnt = addressSpace->pageDirs[i][j];
Kernel/src/arch/x86_64/paging.cpp:						if(addressSpace->pageTables[i][j][k] & 0x1){
Kernel/src/arch/x86_64/paging.cpp:							uint64_t pagePhys = GetPageFrame(addressSpace->pageTables[i][j][k]);
Kernel/src/arch/x86_64/paging.cpp:					addressSpace->pageDirs[i][j] = 0;
Kernel/src/arch/x86_64/paging.cpp:					KernelFree4KPages(addressSpace->pageTables[i][j], 1);
Kernel/src/arch/x86_64/paging.cpp:				addressSpace->pageDirs[i][j] = 0;
Kernel/src/arch/x86_64/paging.cpp:			addressSpace->pdpt[i] = 0;
Kernel/src/arch/x86_64/paging.cpp:			Memory::FreePhysicalMemoryBlock(addressSpace->pageDirsPhys[i]);
Kernel/src/arch/x86_64/paging.cpp:			KernelFree4KPages(addressSpace->pageDirs[i], 1);
Kernel/src/arch/x86_64/paging.cpp:		SetPageFrame(&(addressSpace->pageDirs[pdptIndex][pageDirIndex]),pTable.phys);
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pageDirs[pdptIndex][pageDirIndex] |= PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;
Kernel/src/arch/x86_64/paging.cpp:		addressSpace->pageTables[pdptIndex][pageDirIndex] = pTable.virt;
Kernel/src/arch/x86_64/paging.cpp:			if(!(addressSpace->pdpt[d] & 0x1)) break;
Kernel/src/arch/x86_64/paging.cpp:				if(addressSpace->pageDirs[d][i] & 0x1 && !(addressSpace->pageDirs[d][i] & 0x80)){
Kernel/src/arch/x86_64/paging.cpp:						if(addressSpace->pageTables[d][i][j] & 0x1){
Kernel/src/arch/x86_64/paging.cpp:							while(counter--){
Kernel/src/arch/x86_64/paging.cpp:								addressSpace->pageTables[d][pageDirOffset][offset] = 0x3;
Kernel/src/arch/x86_64/paging.cpp:				if(!(addressSpace->pageDirs[d][i] & 0x1)){
Kernel/src/arch/x86_64/paging.cpp:							while(counter--){
Kernel/src/arch/x86_64/paging.cpp:								addressSpace->pageTables[d][pageDirOffset][offset] = 0x3;
Kernel/src/arch/x86_64/paging.cpp:						while(counter--){
Kernel/src/arch/x86_64/paging.cpp:					//kernelHeapDir[i] = (PAGE_FRAME & ((uintptr_t)&(kernelHeapDirTables[i]) - KERNEL_VIRTUAL_BASE)) | 0x3;
Kernel/src/arch/x86_64/paging.cpp:					SetPageFrame(&(kernelHeapDir[pageDirOffset]),((uintptr_t)&(kernelHeapDirTables[pageDirOffset]) - KERNEL_VIRTUAL_BASE));
Kernel/src/arch/x86_64/paging.cpp:					while(amount--){
Kernel/src/arch/x86_64/paging.cpp:							SetPageFrame(&(kernelHeapDir[pageDirOffset]),((uintptr_t)&(kernelHeapDirTables[pageDirOffset]) - KERNEL_VIRTUAL_BASE));
Kernel/src/arch/x86_64/paging.cpp:				while(counter--){
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:			if(!(addressSpace->pageDirs[pdptIndex][pageDirIndex] & 0x1)) continue;
Kernel/src/arch/x86_64/paging.cpp:			addressSpace->pageTables[pdptIndex][pageDirIndex][pageIndex] = 0;
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:		//phys &= ~(PAGE_SIZE_4K-1);
Kernel/src/arch/x86_64/paging.cpp:		//virt &= ~(PAGE_SIZE_4K-1);
Kernel/src/arch/x86_64/paging.cpp:		while(amount--){
Kernel/src/arch/x86_64/paging.cpp:			if(!(addressSpace->pageDirs[pdptIndex][pageDirIndex] & 0x1)) CreatePageTable(pdptIndex,pageDirIndex,addressSpace); // If we don't have a page table at this address, create one.
Kernel/src/arch/x86_64/paging.cpp:			SetPageFrame(&(addressSpace->pageTables[pdptIndex][pageDirIndex][pageIndex]), phys);
Kernel/src/arch/x86_64/paging.cpp:			addressSpace->pageTables[pdptIndex][pageDirIndex][pageIndex] |= PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;
Kernel/src/arch/x86_64/paging.cpp:		int us = err_code & 0x4;           // Processor was in user-mode and tried to access kernel page
Kernel/src/arch/x86_64/paging.cpp:		int reserved = err_code & 0x8;     // Overwritten CPU-reserved bits of page entry
Kernel/src/arch/x86_64/paging.cpp:		Log::Info(regs->rip);
Kernel/src/arch/x86_64/paging.cpp:		Log::Info(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rax);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rbx);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rcx);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rdx);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rsi);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rdi);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rsp);
Kernel/src/arch/x86_64/paging.cpp:		Log::Write(regs->rbp);
Kernel/src/arch/x86_64/paging.cpp:		if((regs->ss & 0x3)){
Kernel/src/arch/x86_64/paging.cpp:			Log::Write(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86_64/paging.cpp:			Log::Write(regs->rip);
Kernel/src/arch/x86_64/paging.cpp:		uint64_t* stack = (uint64_t*)regs->rbp;
Kernel/src/arch/x86_64/paging.cpp:		const char* reasons[]{"Page Fault","RIP: ", itoa(regs->rip, temp, 16),"Address: ",itoa(faultAddress, temp2, 16), "Process:", itoa(Scheduler::GetCurrentProcess()->pid,temp3,10)};;
Kernel/src/arch/x86_64/pci.cpp:		for(int i = 0; i < devices->get_length(); i++){
Kernel/src/arch/x86_64/pci.cpp:			if(devices->get_at(i).deviceID == deviceID && devices->get_at(i).vendorID == vendorID){
Kernel/src/arch/x86_64/pci.cpp:		for(int i = 0; i < devices->get_length(); i++){
Kernel/src/arch/x86_64/pci.cpp:			if(device.generic ? (devices->get_at(i).classCode == device.classCode && devices->get_at(i).subclass == device.subclass) : (devices->get_at(i).deviceID == device.deviceID && devices->get_at(i).vendorID == device.vendorID)){
Kernel/src/arch/x86_64/pci.cpp:				dev = devices->get_at(i);
Kernel/src/arch/x86_64/pci.cpp:				devices->replace_at(i, dev);
Kernel/src/arch/x86_64/pci.cpp:		int ret = devices->get_length();
Kernel/src/arch/x86_64/pci.cpp:		devices->add_back(device);
Kernel/src/arch/x86_64/pci.cpp:					if(devices->get_at(index).header0.headerType & 0x80){
Kernel/src/arch/x86_64/physicalallocator.cpp:        multiboot_memory_map_t* mem_map = mem_info->mem_map;
Kernel/src/arch/x86_64/physicalallocator.cpp:        multiboot_memory_map_t* mem_map_end = (multiboot_memory_map_t*)(mem_info->mem_map + mem_info->memory_map_len);
Kernel/src/arch/x86_64/physicalallocator.cpp:        maxPhysicalBlocks = (mem_info->memory_high + mem_info->memory_low) * 1024 / PHYSALLOC_BLOCK_SIZE;
Kernel/src/arch/x86_64/physicalallocator.cpp:            Log::Info("Memory Region: [%x - %x] (Type %d)", mem_map->base, mem_map->base + mem_map->length, mem_map->type);
Kernel/src/arch/x86_64/physicalallocator.cpp:            if (mem_map->type == 1){
Kernel/src/arch/x86_64/physicalallocator.cpp:                MarkMemoryRegionFree(mem_map->base, mem_map->length);
Kernel/src/arch/x86_64/physicalallocator.cpp:            } else if (!mem_map->type) break;
Kernel/src/arch/x86_64/physicalallocator.cpp:            mem_map = (multiboot_memory_map_t*)(((uint64_t)mem_map) + mem_map->size + sizeof(mem_map->size));
Kernel/src/arch/x86_64/physicalallocator.cpp:        MarkMemoryRegionUsed(0, (uintptr_t)&_end - KERNEL_VIRTUAL_BASE);
Kernel/src/arch/x86_64/physicalallocator.cpp:        for (uint32_t blocks = size / PHYSALLOC_BLOCK_SIZE, align = base / PHYSALLOC_BLOCK_SIZE; blocks > 0; blocks--, usedPhysicalBlocks++)
Kernel/src/arch/x86_64/physicalallocator.cpp:        for (uint32_t blocks = size / PHYSALLOC_BLOCK_SIZE, align = base / PHYSALLOC_BLOCK_SIZE; blocks > 0; blocks--, usedPhysicalBlocks--)
Kernel/src/arch/x86_64/physicalallocator.cpp:        while(blockCount--)
Kernel/src/arch/x86_64/physicalallocator.cpp:        usedPhysicalBlocks--;
Kernel/src/arch/x86_64/physicalallocator.cpp:        usedPhysicalBlocks-=blockCount;
Kernel/src/arch/x86_64/physicalallocator.cpp:        while(blockCount--)
Kernel/src/arch/x86_64/scheduler.cpp:        processPML4 = currentProcess->addressSpace->pml4Phys;
Kernel/src/arch/x86_64/scheduler.cpp:        asm volatile ("fxrstor64 (%0)" :: "r"((uintptr_t)currentProcess->fxState) : "memory");
Kernel/src/arch/x86_64/scheduler.cpp:        Memory::ChangeAddressSpace(currentProcess->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:        TSS::SetKernelStack((uintptr_t)currentProcess->threads[0].kernelStack);
Kernel/src/arch/x86_64/scheduler.cpp:        TaskSwitch(&currentProcess->threads[0].registers);
Kernel/src/arch/x86_64/scheduler.cpp:            Log::Warning("Invalid Handle: %x, Process: %d", (uintptr_t)handle, (unsigned long)(currentProcess ? currentProcess->pid : -1));
Kernel/src/arch/x86_64/scheduler.cpp:        if(pid == proc->pid) return proc;
Kernel/src/arch/x86_64/scheduler.cpp:        proc = proc->next;
Kernel/src/arch/x86_64/scheduler.cpp:            if(pid == proc->pid) return proc;
Kernel/src/arch/x86_64/scheduler.cpp:            proc = proc->next;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->messageQueue.add_back(msg);
Kernel/src/arch/x86_64/scheduler.cpp:        proc->messageQueue.add_back(msg); // Add message to queue
Kernel/src/arch/x86_64/scheduler.cpp:        if(proc->messageQueue.get_length() <= 0 || !proc){
Kernel/src/arch/x86_64/scheduler.cpp:        return proc->messageQueue.remove_at(0);
Kernel/src/arch/x86_64/scheduler.cpp:            proc->next = proc;
Kernel/src/arch/x86_64/scheduler.cpp:        else if(processQueueStart->next){ // More than 1 process in queue?
Kernel/src/arch/x86_64/scheduler.cpp:            proc->next = processQueueStart->next;
Kernel/src/arch/x86_64/scheduler.cpp:            processQueueStart->next = proc;
Kernel/src/arch/x86_64/scheduler.cpp:            processQueueStart->next = proc;
Kernel/src/arch/x86_64/scheduler.cpp:            proc->next = processQueueStart;
Kernel/src/arch/x86_64/scheduler.cpp:        process_t* _proc = proc->next;
Kernel/src/arch/x86_64/scheduler.cpp:        process_t* nextProc = proc->next;
Kernel/src/arch/x86_64/scheduler.cpp:        while(_proc->next && _proc != proc){
Kernel/src/arch/x86_64/scheduler.cpp:            if(_proc->next == proc){
Kernel/src/arch/x86_64/scheduler.cpp:                _proc->next = nextProc;
Kernel/src/arch/x86_64/scheduler.cpp:            _proc = _proc->next;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->fileDescriptors.clear();
Kernel/src/arch/x86_64/scheduler.cpp:        proc->fileDescriptors.add_back(fs::Open(nullDev));  //(NULL);
Kernel/src/arch/x86_64/scheduler.cpp:        proc->fileDescriptors.add_back(fs::Open(nullDev));  //(NULL);
Kernel/src/arch/x86_64/scheduler.cpp:        proc->fileDescriptors.add_back(fs::Open(nullDev));  //(NULL);
Kernel/src/arch/x86_64/scheduler.cpp:        proc->pid = nextPID++; // Set Process ID to the next availiable
Kernel/src/arch/x86_64/scheduler.cpp:        proc->priority = 1;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->thread_count = 1;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->state = PROCESS_STATE_ACTIVE;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->thread_count = 1;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->addressSpace = Memory::CreateAddressSpace();// So far this function is only used for idle task, we don't need an address space
Kernel/src/arch/x86_64/scheduler.cpp:        proc->timeSliceDefault = 1;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->timeSlice = proc->timeSliceDefault;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->next = NULL;
Kernel/src/arch/x86_64/scheduler.cpp:        thread_t* thread = proc->threads;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->stack = 0;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->priority = 1;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->parent = proc;
Kernel/src/arch/x86_64/scheduler.cpp:        regs64_t* registers = &thread->registers;
Kernel/src/arch/x86_64/scheduler.cpp:        registers->rflags = 0x202; // IF - Interrupt Flag, bit 1 should be 1
Kernel/src/arch/x86_64/scheduler.cpp:        registers->cs = 0x08; // Kernel CS
Kernel/src/arch/x86_64/scheduler.cpp:        registers->ss = 0x10; // Kernel SS
Kernel/src/arch/x86_64/scheduler.cpp:        proc->fxState = Memory::KernelAllocate4KPages(1); // Allocate Memory for the FPU/Extended Register State
Kernel/src/arch/x86_64/scheduler.cpp:        Memory::KernelMapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(), (uintptr_t)proc->fxState, 1);
Kernel/src/arch/x86_64/scheduler.cpp:        memset(proc->fxState, 0, 1024);
Kernel/src/arch/x86_64/scheduler.cpp:        thread->kernelStack = kernelStack + PAGE_SIZE_4K * 24;
Kernel/src/arch/x86_64/scheduler.cpp:        ((fx_state_t*)proc->fxState)->mxcsr = 0x1f80; // Default MXCSR (SSE Control Word) State
Kernel/src/arch/x86_64/scheduler.cpp:        ((fx_state_t*)proc->fxState)->mxcsrMask = 0xffbf;
Kernel/src/arch/x86_64/scheduler.cpp:        ((fx_state_t*)proc->fxState)->fcw = 0x33f; // Default FPU Control Word State
Kernel/src/arch/x86_64/scheduler.cpp:        strcpy(proc->workingDir, "/"); // set root as default working dir
Kernel/src/arch/x86_64/scheduler.cpp:        currentProcess->timeSlice = 0;
Kernel/src/arch/x86_64/scheduler.cpp:        thread_t* thread = &proc->threads[0];
Kernel/src/arch/x86_64/scheduler.cpp:        void* stack = (void*)Memory::KernelAllocate4KPages(32);//, proc->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:            Memory::KernelMapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(),(uintptr_t)stack + PAGE_SIZE_4K * i, 1);//, proc->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:        thread->stack = stack + PAGE_SIZE_4K * 32; // 128KB stack size
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rsp = (uintptr_t)thread->stack;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rbp = (uintptr_t)thread->stack;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rip = (uintptr_t)entry;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->timeSliceDefault = 4;
Kernel/src/arch/x86_64/scheduler.cpp:        proc->timeSlice = proc->timeSliceDefault;
Kernel/src/arch/x86_64/scheduler.cpp:        thread_t* thread = &proc->threads[0];
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.cs = 0x1B; // We want user mode so use user mode segments, make sure RPL is 3
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.ss = 0x23;
Kernel/src/arch/x86_64/scheduler.cpp:        Memory::MapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(),0,1,proc->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:        asm volatile("mov %%rax, %%cr3" :: "a"(proc->addressSpace->pml4Phys));
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rip = elfInfo.entry;
Kernel/src/arch/x86_64/scheduler.cpp:                node = current_node->findDir(current_node,file);
Kernel/src/arch/x86_64/scheduler.cpp:                if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/arch/x86_64/scheduler.cpp:            Log::Write(node->name);
Kernel/src/arch/x86_64/scheduler.cpp:            void* linkerElf = kmalloc(node->size);
Kernel/src/arch/x86_64/scheduler.cpp:            fs::Read(node, 0, node->size, (uint8_t*)linkerElf); // Load Dynamic Linker
Kernel/src/arch/x86_64/scheduler.cpp:            thread->registers.rip = linkerELFInfo.entry;
Kernel/src/arch/x86_64/scheduler.cpp:        void* _stack = (void*)Memory::Allocate4KPages(32, proc->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:            Memory::MapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(),(uintptr_t)_stack + PAGE_SIZE_4K * i, 1, proc->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:        thread->stack = _stack + PAGE_SIZE_4K * 32; // 128KB stack size
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rsp = (uintptr_t)thread->stack;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rbp = (uintptr_t)thread->stack;
Kernel/src/arch/x86_64/scheduler.cpp:        uint64_t* stack = (uint64_t*)thread->registers.rsp;
Kernel/src/arch/x86_64/scheduler.cpp:            stackStr -= strlen(argv[i]) + 1;
Kernel/src/arch/x86_64/scheduler.cpp:                stackStr -= strlen(envp[i]) + 1;
Kernel/src/arch/x86_64/scheduler.cpp:        stackStr -= (uintptr_t)stackStr & 0xf; // align the stack
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= ((argc + envc) % 2); // If argc + envCount is odd then the stack will be misaligned
Kernel/src/arch/x86_64/scheduler.cpp:        stack--;
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= sizeof(auxv_t)/sizeof(*stack);
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= sizeof(auxv_t)/sizeof(*stack);
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= sizeof(auxv_t)/sizeof(*stack);
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= sizeof(auxv_t)/sizeof(*stack);
Kernel/src/arch/x86_64/scheduler.cpp:        stack--;
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= envc;
Kernel/src/arch/x86_64/scheduler.cpp:        stack--;
Kernel/src/arch/x86_64/scheduler.cpp:        stack -= argc;
Kernel/src/arch/x86_64/scheduler.cpp:        stack--;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rsp = (uintptr_t) stack;
Kernel/src/arch/x86_64/scheduler.cpp:        thread->registers.rbp = (uintptr_t) stack;
Kernel/src/arch/x86_64/scheduler.cpp:        Log::Info("Entry: %x, Stack: %x", thread->registers.rip, stack);
Kernel/src/arch/x86_64/scheduler.cpp:        asm volatile("mov %%rax, %%cr3" :: "a"(currentProcess->addressSpace->pml4Phys));
Kernel/src/arch/x86_64/scheduler.cpp:        for(unsigned i = 0; i < process->children.get_length(); i++){
Kernel/src/arch/x86_64/scheduler.cpp:            EndProcess(process->children.get_at(i));
Kernel/src/arch/x86_64/scheduler.cpp:        if(process->parent){
Kernel/src/arch/x86_64/scheduler.cpp:            for(unsigned i = 0; i < process->parent->children.get_length(); i++){
Kernel/src/arch/x86_64/scheduler.cpp:                if(process->parent->children[i] == process){
Kernel/src/arch/x86_64/scheduler.cpp:                    process->parent->children.remove_at(i);
Kernel/src/arch/x86_64/scheduler.cpp:            asm volatile("mov %%rax, %%cr3" :: "a"(((uint64_t)Memory::kernelPML4) - KERNEL_VIRTUAL_BASE)); // If we are using the PML4 of the current process switch to the kernel's
Kernel/src/arch/x86_64/scheduler.cpp:        for(unsigned i = 0; i < process->sharedMemory.get_length(); i++){
Kernel/src/arch/x86_64/scheduler.cpp:            Memory::Free4KPages((void*)process->sharedMemory[i].base, process->sharedMemory[i].pageCount, process->addressSpace); // Make sure the physical memory does not get freed
Kernel/src/arch/x86_64/scheduler.cpp:        Memory::DestroyAddressSpace(process->addressSpace);
Kernel/src/arch/x86_64/scheduler.cpp:        /*for(int i = 0; i < process->fileDescriptors.get_length(); i++){
Kernel/src/arch/x86_64/scheduler.cpp:            if(process->fileDescriptors[i]){
Kernel/src/arch/x86_64/scheduler.cpp:                fs::Close(process->fileDescriptors[i]);
Kernel/src/arch/x86_64/scheduler.cpp:        process->fileDescriptors.clear();*/
Kernel/src/arch/x86_64/scheduler.cpp:            currentProcess = process->next;
Kernel/src/arch/x86_64/scheduler.cpp:            processPML4 = currentProcess->addressSpace->pml4Phys;
Kernel/src/arch/x86_64/scheduler.cpp:            asm volatile ("fxrstor64 (%0)" :: "r"((uintptr_t)currentProcess->fxState) : "memory");
Kernel/src/arch/x86_64/scheduler.cpp:            TSS::SetKernelStack((uintptr_t)currentProcess->threads[0].kernelStack);
Kernel/src/arch/x86_64/scheduler.cpp:            TaskSwitch(&currentProcess->threads[0].registers);
Kernel/src/arch/x86_64/scheduler.cpp:        if(currentProcess && currentProcess->timeSlice > 0) {
Kernel/src/arch/x86_64/scheduler.cpp:            currentProcess->timeSlice--;
Kernel/src/arch/x86_64/scheduler.cpp:        currentProcess->timeSlice = currentProcess->timeSliceDefault;
Kernel/src/arch/x86_64/scheduler.cpp:        asm volatile ("fxsave64 (%0)" :: "r"((uintptr_t)currentProcess->fxState) : "memory");
Kernel/src/arch/x86_64/scheduler.cpp:        currentProcess->threads[0].registers = *r;
Kernel/src/arch/x86_64/scheduler.cpp:        currentProcess = currentProcess->next;
Kernel/src/arch/x86_64/scheduler.cpp:        processPML4 = currentProcess->addressSpace->pml4Phys;
Kernel/src/arch/x86_64/scheduler.cpp:        asm volatile ("fxrstor64 (%0)" :: "r"((uintptr_t)currentProcess->fxState) : "memory");
Kernel/src/arch/x86_64/scheduler.cpp:        TSS::SetKernelStack((uintptr_t)currentProcess->threads[0].kernelStack);
Kernel/src/arch/x86_64/scheduler.cpp:        TaskSwitch(&currentProcess->threads[0].registers);
Kernel/src/arch/x86_64/serial.cpp:	outportb(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
Kernel/src/arch/x86_64/smp.cpp:    while((Timer::GetSystemUptime() * 1000 + (Timer::GetTicks() * (1000.0 / Timer::GetFrequency()))) - timeMs <= ms); // Wait 20ms
Kernel/src/arch/x86_64/smp.cpp:        cpu->id = id;
Kernel/src/arch/x86_64/sse2.cpp:	memcpy(dest, src, 0x10 - start_overflow);		
Kernel/src/arch/x86_64/sse2.cpp:	dest = dest; + 0x10-start_overflow;
Kernel/src/arch/x86_64/sse2.cpp:	count -= 0x10 - start_overflow;*/
Kernel/src/arch/x86_64/sse2.cpp:	size_t size_aligned = (count - overflow); // Size rounded DOWN to lowest multiple of 128 bits
Kernel/src/arch/x86_64/syscalls.cpp:	int64_t code = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info("Process %d exiting with code %d", Scheduler::GetCurrentProcess()->pid, code);
Kernel/src/arch/x86_64/syscalls.cpp:	char* filepath = (char*)kmalloc(strlen((char*)r->rbx) + 1);
Kernel/src/arch/x86_64/syscalls.cpp:	strcpy(filepath, (char*)r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	int argc = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	char** argv = (char**)r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t flags = r->rsi;
Kernel/src/arch/x86_64/syscalls.cpp:	char** envp = (char**)r->rdi;
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info("Executing: %s", (char*)r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	fs_node_t* current_node = fs::ResolvePath(filepath, Scheduler::GetCurrentProcess()->workingDir);
Kernel/src/arch/x86_64/syscalls.cpp:	uint8_t* buffer = (uint8_t*)kmalloc(current_node->size);
Kernel/src/arch/x86_64/syscalls.cpp:	size_t read = current_node->read(current_node, 0, current_node->size, buffer);
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("Could not read file: %s", current_node->name);
Kernel/src/arch/x86_64/syscalls.cpp:		Scheduler::GetCurrentProcess()->children.add_back(proc);
Kernel/src/arch/x86_64/syscalls.cpp:		proc->parent = Scheduler::GetCurrentProcess();
Kernel/src/arch/x86_64/syscalls.cpp:		proc->fileDescriptors.replace_at(0, Scheduler::GetCurrentProcess()->fileDescriptors.get_at(0));
Kernel/src/arch/x86_64/syscalls.cpp:		proc->fileDescriptors.replace_at(1, Scheduler::GetCurrentProcess()->fileDescriptors.get_at(1));
Kernel/src/arch/x86_64/syscalls.cpp:		proc->fileDescriptors.replace_at(2, Scheduler::GetCurrentProcess()->fileDescriptors.get_at(2));
Kernel/src/arch/x86_64/syscalls.cpp:	strncpy(proc->workingDir, Scheduler::GetCurrentProcess()->workingDir, PATH_MAX);
Kernel/src/arch/x86_64/syscalls.cpp:	return proc->pid;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_fd_t* handle = Scheduler::GetCurrentProcess()->fileDescriptors.get_at(r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("read failed! file descriptor: %d", r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	uint8_t* buffer = (uint8_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t count = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	*(int*)r->rsi = ret;
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rbx > Scheduler::GetCurrentProcess()->fileDescriptors.get_length()){
Kernel/src/arch/x86_64/syscalls.cpp:		if(r->rsi) *((int*)r->rsi) = -1; // Return -1
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_fd_t* handle = Scheduler::GetCurrentProcess()->fileDescriptors[r->rbx];
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("Invalid File Descriptor: %d", r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(r->rcx && r->rdx)) return 1;
Kernel/src/arch/x86_64/syscalls.cpp:	int ret = fs::Write(handle, r->rdx, (uint8_t*)r->rcx);
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rsi){
Kernel/src/arch/x86_64/syscalls.cpp:		*((int*)r->rsi) = ret;
Kernel/src/arch/x86_64/syscalls.cpp:	char* filepath = (char*)kmalloc(strlen((char*)r->rbx) + 1);
Kernel/src/arch/x86_64/syscalls.cpp:	strcpy(filepath, (char*)r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:		fd = Scheduler::GetCurrentProcess()->fileDescriptors.get_length();
Kernel/src/arch/x86_64/syscalls.cpp:		Scheduler::GetCurrentProcess()->fileDescriptors.add_back(fs::Open(root, 0));
Kernel/src/arch/x86_64/syscalls.cpp:		*((uint32_t*)r->rcx) = fd;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_node_t* node = fs::ResolvePath(filepath, Scheduler::GetCurrentProcess()->workingDir);
Kernel/src/arch/x86_64/syscalls.cpp:		*((uint32_t*)r->rcx) = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	fd = Scheduler::GetCurrentProcess()->fileDescriptors.get_length();
Kernel/src/arch/x86_64/syscalls.cpp:	Scheduler::GetCurrentProcess()->fileDescriptors.add_back(fs::Open(node, 0));
Kernel/src/arch/x86_64/syscalls.cpp:	*((uint32_t*)r->rcx) = fd;
Kernel/src/arch/x86_64/syscalls.cpp:	int fd = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if((handle = Scheduler::GetCurrentProcess()->fileDescriptors[fd])){
Kernel/src/arch/x86_64/syscalls.cpp:	Scheduler::GetCurrentProcess()->fileDescriptors.replace_at(fd, NULL);
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rbx){
Kernel/src/arch/x86_64/syscalls.cpp:		char* path =  fs::CanonicalizePath((char*)r->rbx, Scheduler::GetCurrentProcess()->workingDir);
Kernel/src/arch/x86_64/syscalls.cpp:			return -1;
Kernel/src/arch/x86_64/syscalls.cpp:		strcpy(Scheduler::GetCurrentProcess()->workingDir, path);
Kernel/src/arch/x86_64/syscalls.cpp:	uintptr_t fbVirt = (uintptr_t)Memory::Allocate4KPages(vMode.height*vMode.pitch/PAGE_SIZE_4K + 2, Scheduler::currentProcess->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:	Memory::MapVirtualMemory4K(HAL::multibootInfo.framebufferAddr,fbVirt,vMode.height*vMode.pitch/PAGE_SIZE_4K + 2,Scheduler::currentProcess->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:	Scheduler::currentProcess->sharedMemory.add_back(memR);
Kernel/src/arch/x86_64/syscalls.cpp:	*((uintptr_t*)r->rbx) = fbVirt;
Kernel/src/arch/x86_64/syscalls.cpp:	*((fb_info_t*)r->rcx) = fbInfo;
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info(r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info(r->rcx);
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info(*((uint64_t*)r->rbx));
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t pageCount = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uintptr_t* addressPointer = (uintptr_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uintptr_t address = (uintptr_t)Memory::Allocate4KPages(pageCount, Scheduler::currentProcess->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:		Memory::MapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(),address + i * PAGE_SIZE_4K,1,Scheduler::currentProcess->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:	stat_t* stat = (stat_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	int fd = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	int* ret = (int*)r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_node_t* node = Scheduler::GetCurrentProcess()->fileDescriptors.get_at(fd)->node;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_dev = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_ino = node->inode;
Kernel/src/arch/x86_64/syscalls.cpp:	if(node->flags & FS_NODE_DIRECTORY) stat->st_mode = S_IFDIR;
Kernel/src/arch/x86_64/syscalls.cpp:	if(node->flags & FS_NODE_FILE) stat->st_mode = S_IFREG;
Kernel/src/arch/x86_64/syscalls.cpp:	if(node->flags & FS_NODE_BLKDEVICE) stat->st_mode = S_IFBLK;
Kernel/src/arch/x86_64/syscalls.cpp:	if(node->flags & FS_NODE_CHARDEVICE) stat->st_mode = S_IFCHR;
Kernel/src/arch/x86_64/syscalls.cpp:	if(node->flags & FS_NODE_SYMLINK) stat->st_mode = S_IFLNK;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_nlink = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_uid = node->uid;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_gid = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_rdev = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_size = node->size;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_blksize = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	stat->st_blocks = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(r->rsi)){
Kernel/src/arch/x86_64/syscalls.cpp:		return -2;
Kernel/src/arch/x86_64/syscalls.cpp:	int64_t* ret = (int64_t*)r->rsi;
Kernel/src/arch/x86_64/syscalls.cpp:	int fd = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(fd >= Scheduler::GetCurrentProcess()->fileDescriptors.get_length() || !Scheduler::GetCurrentProcess()->fileDescriptors[fd]){
Kernel/src/arch/x86_64/syscalls.cpp:		*ret = -1;
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	switch(r->rdx){
Kernel/src/arch/x86_64/syscalls.cpp:		*ret = Scheduler::GetCurrentProcess()->fileDescriptors[fd]->pos = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:		*ret = Scheduler::GetCurrentProcess()->fileDescriptors[fd]->pos;
Kernel/src/arch/x86_64/syscalls.cpp:		*ret = Scheduler::GetCurrentProcess()->fileDescriptors[fd]->pos = Scheduler::GetCurrentProcess()->fileDescriptors[fd]->node->size;
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Info("Invalid seek: %s, mode: %d", Scheduler::GetCurrentProcess()->fileDescriptors[fd]->node->name, r->rdx);
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* pid = (uint64_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	*pid = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86_64/syscalls.cpp:	window_list_t** winList = (window_list_t**)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	window_list_t* userWindowList = (window_list_t*)Memory::Allocate4KPages(pageCount, Scheduler::GetCurrentProcess()->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:		Memory::MapVirtualMemory4K(phys, ((uintptr_t)userWindowList) + i * PAGE_SIZE_4K, 1, Scheduler::GetCurrentProcess()->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:	kernelWindowList->maxWindowCount = WINDOW_COUNT_MAX;
Kernel/src/arch/x86_64/syscalls.cpp:	kernelWindowList->windowCount = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	desktop->windows = kernelWindowList;
Kernel/src/arch/x86_64/syscalls.cpp:	desktop->pid = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86_64/syscalls.cpp:	desktop->lock = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	win_info_t* info = (win_info_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	info->handle = handle;
Kernel/src/arch/x86_64/syscalls.cpp:	info->ownerPID = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86_64/syscalls.cpp:	win->info = *info;
Kernel/src/arch/x86_64/syscalls.cpp:	win->desktop = GetDesktop();
Kernel/src/arch/x86_64/syscalls.cpp:	acquireLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:	while(GetDesktop()->windows->dirty == 2);
Kernel/src/arch/x86_64/syscalls.cpp:	window_list_t* windowList = GetDesktop()->windows;
Kernel/src/arch/x86_64/syscalls.cpp:	if(windowList->windowCount < windowList->maxWindowCount)
Kernel/src/arch/x86_64/syscalls.cpp:		windowList->windows[windowList->windowCount++] = info->handle;
Kernel/src/arch/x86_64/syscalls.cpp:	windowList->dirty = 1;
Kernel/src/arch/x86_64/syscalls.cpp:	releaseLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:	handle_t handle = (handle_t)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:		acquireLock(&desktop->lock);
Kernel/src/arch/x86_64/syscalls.cpp:		for(int i = 0; i < GetDesktop()->windows->windowCount; i++){
Kernel/src/arch/x86_64/syscalls.cpp:			if(GetDesktop()->windows->windows[i] == win->info.handle){
Kernel/src/arch/x86_64/syscalls.cpp:				while(desktop->windows->dirty == 2);
Kernel/src/arch/x86_64/syscalls.cpp:				memcpy(&desktop->windows->windows[i], &desktop->windows->windows[i + 1], (desktop->windows->windowCount - i - 1));
Kernel/src/arch/x86_64/syscalls.cpp:				desktop->windows->windowCount--;
Kernel/src/arch/x86_64/syscalls.cpp:				desktop->windows->dirty = 1;
Kernel/src/arch/x86_64/syscalls.cpp:		releaseLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:	win_info_t* winInfo = (win_info_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	acquireLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:	handle_t handle = (handle_t)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:		*winInfo = win->info;
Kernel/src/arch/x86_64/syscalls.cpp:		releaseLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	releaseLock(&GetDesktop()->lock);
Kernel/src/arch/x86_64/syscalls.cpp:	handle_t handle = (handle_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	win_info_t* info = (win_info_t*)r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:		win_info_t oldInfo = window->info;
Kernel/src/arch/x86_64/syscalls.cpp:		window->info = *info;
Kernel/src/arch/x86_64/syscalls.cpp:		if(window->info.handle != oldInfo.handle){
Kernel/src/arch/x86_64/syscalls.cpp:			window->info.handle = oldInfo.handle; // Do not allow a change in handle
Kernel/src/arch/x86_64/syscalls.cpp:		if(oldInfo.width != info->width || oldInfo.height != info->height){
Kernel/src/arch/x86_64/syscalls.cpp:		if(GetDesktop()->windows->dirty != 2) GetDesktop()->windows->dirty = 1; // Force the WM to refresh the background
Kernel/src/arch/x86_64/syscalls.cpp:	return GetDesktop()->pid;
Kernel/src/arch/x86_64/syscalls.cpp:// SendMessage(message_t* msg) - Sends an IPC message to a process
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t pid = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t msg = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t data = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t data2 = r->rsi;
Kernel/src/arch/x86_64/syscalls.cpp:	message.senderPID = Scheduler::GetCurrentProcess()->pid;
Kernel/src/arch/x86_64/syscalls.cpp:// RecieveMessage(message_t* msg) - Grabs next message on queue and copies it to msg
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(r->rbx && r->rcx)) return 1; // Was given null pointers
Kernel/src/arch/x86_64/syscalls.cpp:	message_t* msg = (message_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* queueSize = (uint64_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	*queueSize = Scheduler::GetCurrentProcess()->messageQueue.get_length();
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* seconds = (uint64_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* milliseconds = (uint64_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	Log::Info("%s, %d", (char*)r->rbx, r->rcx);
Kernel/src/arch/x86_64/syscalls.cpp:	*((fb_info_t*)r->rbx) = fbInfo;
Kernel/src/arch/x86_64/syscalls.cpp:	char* str = (char*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(r->rbx && r->rcx)) return 1;
Kernel/src/arch/x86_64/syscalls.cpp:	unsigned int fd = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(fd > Scheduler::GetCurrentProcess()->fileDescriptors.get_length()){
Kernel/src/arch/x86_64/syscalls.cpp:		if(r->rsi) *((int*)r->rsi) = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_dirent_t* direntPointer = (fs_dirent_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	unsigned int count = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(Scheduler::GetCurrentProcess()->fileDescriptors[fd]->node->flags & FS_NODE_DIRECTORY)){
Kernel/src/arch/x86_64/syscalls.cpp:		if(r->rsi) *((int*)r->rsi) = 0;
Kernel/src/arch/x86_64/syscalls.cpp:	int ret = fs::ReadDir(Scheduler::GetCurrentProcess()->fileDescriptors[fd], direntPointer, count);
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rsi) *((int*)r->rsi) = ret;
Kernel/src/arch/x86_64/syscalls.cpp:	asm("wrmsr" :: "a"(r->rbx & 0xFFFFFFFF) /*Value low*/, "b"((r->rbx >> 32) & 0xFFFFFFFF) /*Value high*/, "c"(0xC0000100) /*Set FS Base*/);
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* address = (uint64_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	size_t count = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uintptr_t hint = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:		if(Memory::CheckRegion(hint, count * PAGE_SIZE_4K, Scheduler::GetCurrentProcess()->addressSpace) /*Check availibilty of the requested map*/){
Kernel/src/arch/x86_64/syscalls.cpp:	} else _address = (uintptr_t)Memory::Allocate4KPages(count, Scheduler::GetCurrentProcess()->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:		Memory::MapVirtualMemory4K(Memory::AllocatePhysicalMemoryBlock(), _address + i * PAGE_SIZE_4K, 1, Scheduler::currentProcess->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:	if(!r->rbx) return 1;
Kernel/src/arch/x86_64/syscalls.cpp:	PTY* pty = GrantPTY(Scheduler::GetCurrentProcess()->pid);
Kernel/src/arch/x86_64/syscalls.cpp:	*((int*)r->rbx) = currentProcess->fileDescriptors.get_length();
Kernel/src/arch/x86_64/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(0, fs::Open(&pty->slaveFile)); // Stdin
Kernel/src/arch/x86_64/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(1, fs::Open(&pty->slaveFile)); // Stdout
Kernel/src/arch/x86_64/syscalls.cpp:	currentProcess->fileDescriptors.replace_at(2, fs::Open(&pty->slaveFile)); // Stderr
Kernel/src/arch/x86_64/syscalls.cpp:	currentProcess->fileDescriptors.add_back(fs::Open(&pty->masterFile));
Kernel/src/arch/x86_64/syscalls.cpp:	char* buf = (char*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	size_t sz = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	char* workingDir = Scheduler::GetCurrentProcess()->workingDir;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t pid = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t nanoseconds = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rbx > Scheduler::GetCurrentProcess()->fileDescriptors.get_length()){
Kernel/src/arch/x86_64/syscalls.cpp:		*((int*)r->rsi) = -1; // Return -1
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	if(Scheduler::GetCurrentProcess()->fileDescriptors.get_at(r->rbx) || !(node = Scheduler::GetCurrentProcess()->fileDescriptors.get_at(r->rbx)->node)){ 
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("sys_pread: Invalid file descriptor: %d", r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	uint8_t* buffer = (uint8_t*)r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t count = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t off = r->rdi;
Kernel/src/arch/x86_64/syscalls.cpp:	int ret = node->read(node, off, count, buffer);
Kernel/src/arch/x86_64/syscalls.cpp:	*(int*)r->rsi = ret;
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rbx > Scheduler::GetCurrentProcess()->fileDescriptors.get_length()){
Kernel/src/arch/x86_64/syscalls.cpp:		*((int*)r->rsi) = -1; // Return -1
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	if(Scheduler::GetCurrentProcess()->fileDescriptors.get_at(r->rbx) || !(node = Scheduler::GetCurrentProcess()->fileDescriptors.get_at(r->rbx)->node)){ 
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("sys_pwrite: Invalid file descriptor: %d", r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:	if(!(r->rcx)) {
Kernel/src/arch/x86_64/syscalls.cpp:		*((int*)r->rsi) = -1;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t off = r->rdi;
Kernel/src/arch/x86_64/syscalls.cpp:	int ret = fs::Write(node, off, r->rdx, (uint8_t*)r->rcx);
Kernel/src/arch/x86_64/syscalls.cpp:	if(r->rsi){
Kernel/src/arch/x86_64/syscalls.cpp:		*((int*)r->rsi) = ret;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t fd = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t request = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t arg = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	int* result = (int*)r->rsi;
Kernel/src/arch/x86_64/syscalls.cpp:	if(fd >= Scheduler::GetCurrentProcess()->fileDescriptors.get_length()){
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	fs_fd_t* handle = Scheduler::GetCurrentProcess()->fileDescriptors[r->rbx];
Kernel/src/arch/x86_64/syscalls.cpp:		Log::Warning("sys_fcntl: Invalid File Descriptor: %d", r->rbx);
Kernel/src/arch/x86_64/syscalls.cpp:		return -2;
Kernel/src/arch/x86_64/syscalls.cpp:	lemon_sysinfo_t* s = (lemon_sysinfo_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	s->usedMem = Memory::usedPhysicalBlocks * 4;
Kernel/src/arch/x86_64/syscalls.cpp:	s->totalMem = HAL::mem_info.memory_high + HAL::mem_info.memory_low;
Kernel/src/arch/x86_64/syscalls.cpp: * SysMunmap - Unmap memory (addr, count)
Kernel/src/arch/x86_64/syscalls.cpp: * On success - return 0
Kernel/src/arch/x86_64/syscalls.cpp: * On failure - return -1
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t address = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	size_t count = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(Memory::CheckRegion(address, count * PAGE_SIZE_4K, Scheduler::GetCurrentProcess()->addressSpace) /*Check availibilty of the requested map*/){
Kernel/src/arch/x86_64/syscalls.cpp:		//Memory::Free4KPages((void*)address, count, Scheduler::GetCurrentProcess()->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp: * SysCreateSharedMemory (key, size, flags, recipient) - Create Shared Memory
Kernel/src/arch/x86_64/syscalls.cpp: * key - Pointer to memory key
Kernel/src/arch/x86_64/syscalls.cpp: * size - memory size
Kernel/src/arch/x86_64/syscalls.cpp: * flags - flags
Kernel/src/arch/x86_64/syscalls.cpp: * recipient - (if private flag) PID of the process that can access memory
Kernel/src/arch/x86_64/syscalls.cpp: * On Success - Return 0, key greater than 1
Kernel/src/arch/x86_64/syscalls.cpp: * On Failure - Return -1, key null
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t* key = (uint64_t*)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t size = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t flags = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t recipient = r->rsi;
Kernel/src/arch/x86_64/syscalls.cpp:	*key = Memory::CreateSharedMemory(size, flags, Scheduler::GetCurrentProcess()->pid, recipient);
Kernel/src/arch/x86_64/syscalls.cpp:	if(!*key) return -1; // Failed
Kernel/src/arch/x86_64/syscalls.cpp: * SysMapSharedMemory (ptr, key, hint) - Map Shared Memory
Kernel/src/arch/x86_64/syscalls.cpp: * ptr - Pointer to pointer of mapped memory
Kernel/src/arch/x86_64/syscalls.cpp: * key - Memory key
Kernel/src/arch/x86_64/syscalls.cpp: * key - Address hint
Kernel/src/arch/x86_64/syscalls.cpp: * On Success - ptr > 0
Kernel/src/arch/x86_64/syscalls.cpp: * On Failure - ptr = 0
Kernel/src/arch/x86_64/syscalls.cpp:	void** ptr = (void**)r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t key = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t hint = r->rdx;
Kernel/src/arch/x86_64/syscalls.cpp: * SysUnmapSharedMemory (address, key) - Map Shared Memory
Kernel/src/arch/x86_64/syscalls.cpp: * address - address of mapped memory
Kernel/src/arch/x86_64/syscalls.cpp: * key - Memory key
Kernel/src/arch/x86_64/syscalls.cpp: * On Success - return 0
Kernel/src/arch/x86_64/syscalls.cpp: * On Failure - return -1
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t address = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t key = r->rcx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(!sMem) return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	if(!Memory::CheckRegion(address, sMem->pgCount * PAGE_SIZE_4K, Scheduler::GetCurrentProcess()->addressSpace)) // Make sure the process is not screwing with kernel memory
Kernel/src/arch/x86_64/syscalls.cpp:		return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	Memory::Free4KPages((void*)address, sMem->pgCount, Scheduler::GetCurrentProcess()->addressSpace);
Kernel/src/arch/x86_64/syscalls.cpp: * SysDestroySharedMemory (key) - Destroy Shared Memory
Kernel/src/arch/x86_64/syscalls.cpp: * key - Memory key
Kernel/src/arch/x86_64/syscalls.cpp: * On Success - return 0
Kernel/src/arch/x86_64/syscalls.cpp: * On Failure - return -1
Kernel/src/arch/x86_64/syscalls.cpp:	uint64_t key = r->rbx;
Kernel/src/arch/x86_64/syscalls.cpp:	if(Memory::CanModifySharedMemory(Scheduler::GetCurrentProcess()->pid, key)){
Kernel/src/arch/x86_64/syscalls.cpp:	} else return -1;
Kernel/src/arch/x86_64/syscalls.cpp:	if (regs->rax >= NUM_SYSCALLS) // If syscall is non-existant then return
Kernel/src/arch/x86_64/syscalls.cpp:	lastSyscall = regs->rax;
Kernel/src/arch/x86_64/syscalls.cpp:	if(syscalls[regs->rax])
Kernel/src/arch/x86_64/syscalls.cpp:		ret = syscalls[regs->rax](regs); // Call syscall
Kernel/src/arch/x86_64/syscalls.cpp:	regs->rax = ret;
Kernel/src/arch/x86_64/timer.cpp:            ticks -= frequency;
Kernel/src/arch/x86_64/timer.cpp:        // Divisor has to be sent byte-wise, so split here into upper/lower bytes.
Kernel/src/arch/x86_64/tss.asm:LoadTSS: ; RDI - address 
Kernel/src/characterbuffer.cpp:    acquireLock(&(this->lock));
Kernel/src/characterbuffer.cpp:            if(bufferPos > 0) bufferPos--;
Kernel/src/characterbuffer.cpp:    releaseLock(&(this->lock));
Kernel/src/characterbuffer.cpp:    acquireLock(&(this->lock));
Kernel/src/characterbuffer.cpp:        releaseLock(&(this->lock));
Kernel/src/characterbuffer.cpp:        if(buffer[i] == '\n') lines--;
Kernel/src/characterbuffer.cpp:    for(int i = 0; i < bufferSize - count; i++){
Kernel/src/characterbuffer.cpp:    bufferPos -= count;
Kernel/src/characterbuffer.cpp:    releaseLock(&(this->lock));
Kernel/src/fs/fat32.cpp:        if(part->Read(0, 512, (uint8_t*)bootRecord)){ // Read Volume Boot Record (First sector of partition)
Kernel/src/fs/fat32.cpp:            return -1; // Disk Error
Kernel/src/fs/fat32.cpp:        if(bootRecord->ebr.signature == 0x28 || bootRecord->ebr.signature == 0x29){
Kernel/src/fs/fat32.cpp:            uint32_t dataSectors = bootRecord->bpb.largeSectorCount - (bootRecord->bpb.reservedSectors + (bootRecord->ebr.sectorsPerFAT * bootRecord->bpb.fatCount));
Kernel/src/fs/fat32.cpp:            uint32_t clusters = dataSectors / bootRecord->bpb.sectorsPerCluster;
Kernel/src/fs/fat32.cpp:        return (bootRecord->bpb.reservedSectors + bootRecord->bpb.fatCount * bootRecord->ebr.sectorsPerFAT) + cluster * bootRecord->bpb.sectorsPerCluster - (2 * bootRecord->bpb.sectorsPerCluster);
Kernel/src/fs/fat32.cpp:        this->part = _part;
Kernel/src/fs/fat32.cpp:        if(part->Read(0, 512, (uint8_t*)bootRecord)){ // Read Volume Boot Record (First sector of partition)
Kernel/src/fs/fat32.cpp:        this->bootRecord = bootRecord;
Kernel/src/fs/fat32.cpp:        Log::Info("[FAT32] Initializing Volume\tSignature: %d, OEM ID: %s, Size: %d MB", bootRecord->ebr.signature, (char*)bootRecord->bpb.oem, bootRecord->bpb.largeSectorCount * 512 / 1024 / 1024);
Kernel/src/fs/fat32.cpp:        clusterSizeBytes = bootRecord->bpb.sectorsPerCluster * part->parentDisk->blocksize;
Kernel/src/fs/fat32.cpp:        mountPoint.inode = bootRecord->ebr.rootClusterNum;
Kernel/src/fs/fat32.cpp:        mountPointDirent.inode = bootRecord->ebr.rootClusterNum;
Kernel/src/fs/fat32.cpp:            list->add_back(cluster);
Kernel/src/fs/fat32.cpp:                if(part->Read(bootRecord->bpb.reservedSectors + block * (4096 / part->parentDisk->blocksize) /* Get Sector of Block */, 4096, buf)){
Kernel/src/fs/fat32.cpp:        uint32_t maxCluster = (max / (bootRecord->bpb.sectorsPerCluster * part->parentDisk->blocksize)) + 1;
Kernel/src/fs/fat32.cpp:        void* buf = kmalloc(clusterChain->get_length() * clusterSizeBytes);
Kernel/src/fs/fat32.cpp:        for(int i = 0; i < clusterChain->get_length() && maxCluster; i++){
Kernel/src/fs/fat32.cpp:            part->Read(ClusterToLBA(clusterChain->get_at(i)), clusterSizeBytes, buf);
Kernel/src/fs/fat32.cpp:            *clusterCount = clusterChain->get_length();
Kernel/src/fs/fat32.cpp:        if(cluster == 0) cluster = bootRecord->ebr.rootClusterNum;
Kernel/src/fs/fat32.cpp:        void* buf = kmalloc(clusterChain->get_length() * clusterSizeBytes);
Kernel/src/fs/fat32.cpp:        for(int i = 0; i < clusterChain->get_length(); i++){
Kernel/src/fs/fat32.cpp:            part->Read(ClusterToLBA(clusterChain->get_at(i)), clusterSizeBytes, buf);
Kernel/src/fs/fat32.cpp:            *clusterCount = clusterChain->get_length();
Kernel/src/fs/fat32.cpp:        if(!node->inode || node->flags & FS_NODE_DIRECTORY) return 0;
Kernel/src/fs/fat32.cpp:        void* _buf = ReadClusterChain(node->inode, &count, size);
Kernel/src/fs/fat32.cpp:        if(count * bootRecord->bpb.sectorsPerCluster * part->parentDisk->blocksize < size) return 0;
Kernel/src/fs/fat32.cpp:        List<uint32_t>* clusters = GetClusterChain(node->inode);
Kernel/src/fs/fat32.cpp:        if(offset + size > clusters->get_length() * bootRecord->bpb.sectorsPerCluster * part->parentDisk->blocksize){
Kernel/src/fs/fat32.cpp:            Log::Info("[FAT32] Allocating Clusters for %s", node->name);
Kernel/src/fs/fat32.cpp:        uint32_t cluster = node->inode;
Kernel/src/fs/fat32.cpp:        int dirEntryIndex = -1;
Kernel/src/fs/fat32.cpp:            if(dirEntries[i].filename[0] == 0) return -1; // No Directory Entry at index
Kernel/src/fs/fat32.cpp:        if(dirEntryIndex == -1){
Kernel/src/fs/fat32.cpp:            return -2;
Kernel/src/fs/fat32.cpp:            fat_lfn_entry_t* lfnEntry = (fat_lfn_entry_t*)(&dirEntries[dirEntryIndex -  i - 1]);
Kernel/src/fs/fat32.cpp:        dirent->inode = dirEntry->lowClusterNum | (dirEntry->highClusterNum << 16);
Kernel/src/fs/fat32.cpp:            GetLongFilename(dirent->name, lfnEntries, lfnCount);
Kernel/src/fs/fat32.cpp:            strncpy(dirent->name, (char*)dirEntry->filename, 8);
Kernel/src/fs/fat32.cpp:            while(strchr(dirent->name, ' ')) *strchr(dirent->name, ' ') = 0; // Remove Spaces
Kernel/src/fs/fat32.cpp:            if(strchr((char*)dirEntry->ext, ' ') != (char*)dirEntry->ext){
Kernel/src/fs/fat32.cpp:                strncpy(dirent->name + strlen(dirent->name), ".", 1);
Kernel/src/fs/fat32.cpp:                strncpy(dirent->name + strlen(dirent->name), (char*)dirEntry->ext, 3);
Kernel/src/fs/fat32.cpp:        if(dirEntry->attributes & FAT_ATTR_DIRECTORY) dirent->type = FS_NODE_DIRECTORY;
Kernel/src/fs/fat32.cpp:        else dirent->type = FS_NODE_FILE;
Kernel/src/fs/fat32.cpp:        uint32_t cluster = node->inode;
Kernel/src/fs/fat32.cpp:                        fat_lfn_entry_t* lfnEntry = (fat_lfn_entry_t*)(&dirEntries[i -  k - 1]);
Kernel/src/fs/fat32.cpp:                    if(clusterNum == bootRecord->ebr.rootClusterNum || clusterNum == 0) 
Kernel/src/fs/fat32.cpp:                    _node->size = dirEntries[i].fileSize;
Kernel/src/fs/fat32.cpp:                    _node->inode = clusterNum;
Kernel/src/fs/fat32.cpp:                    if(dirEntries[i].attributes & FAT_ATTR_DIRECTORY) _node->flags = FS_NODE_DIRECTORY;
Kernel/src/fs/fat32.cpp:                    else _node->flags = FS_NODE_FILE;
Kernel/src/fs/fat32.cpp:                    strcpy(_node->name, _name);
Kernel/src/fs/fat32.cpp:            _node->vol = this;
Kernel/src/fs/fat32.cpp:            _node->read = FAT32::Read;
Kernel/src/fs/fat32.cpp:            _node->write = FAT32::Write;
Kernel/src/fs/fat32.cpp:            _node->open = FAT32::Open;
Kernel/src/fs/fat32.cpp:            _node->close = FAT32::Close;
Kernel/src/fs/fat32.cpp:            _node->findDir = FAT32::FindDir;
Kernel/src/fs/fat32.cpp:            _node->readDir = FAT32::ReadDir;
Kernel/src/fs/fat32.cpp:        ((Fat32Volume*)node->vol)->Read(node, offset, size, buffer);
Kernel/src/fs/fat32.cpp:        ((Fat32Volume*)node->vol)->Write(node, offset, size, buffer);
Kernel/src/fs/fat32.cpp:        ((Fat32Volume*)node->vol)->Open(node, flags);
Kernel/src/fs/fat32.cpp:        ((Fat32Volume*)node->vol)->Close(node);
Kernel/src/fs/fat32.cpp:        return ((Fat32Volume*)node->vol)->ReadDir(node, dirent, index);
Kernel/src/fs/fat32.cpp:        ((Fat32Volume*)node->vol)->FindDir(node, name);
Kernel/src/fs/filesystem.cpp:			if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/fs/filesystem.cpp:		Log::Info("Returning: %s", current_node->name);
Kernel/src/fs/filesystem.cpp:			tokens->add_back(file);
Kernel/src/fs/filesystem.cpp:		for(int i = 0; i < tokens->get_length(); i++){
Kernel/src/fs/filesystem.cpp:			if(strlen(tokens->get_at(i)) == 0){
Kernel/src/fs/filesystem.cpp:				tokens->remove_at(i--);
Kernel/src/fs/filesystem.cpp:			} else if(strcmp(tokens->get_at(i), ".") == 0){
Kernel/src/fs/filesystem.cpp:				tokens->remove_at(i--);
Kernel/src/fs/filesystem.cpp:			} else if(strcmp(tokens->get_at(i), "..") == 0){
Kernel/src/fs/filesystem.cpp:					tokens->remove_at(i);
Kernel/src/fs/filesystem.cpp:					tokens->remove_at(i - 1);
Kernel/src/fs/filesystem.cpp:					i -= 2;
Kernel/src/fs/filesystem.cpp:				} else tokens->remove_at(i);
Kernel/src/fs/filesystem.cpp:			newLength += strlen(tokens->get_at(i)) + 1; // Name and separator
Kernel/src/fs/filesystem.cpp:		if(!tokens->get_length()) strcpy(outPath + strlen(outPath), "/");
Kernel/src/fs/filesystem.cpp:		else for(int i = 0; i < tokens->get_length(); i++){
Kernel/src/fs/filesystem.cpp:			strcpy(outPath + strlen(outPath), tokens->get_at(i));
Kernel/src/fs/filesystem.cpp:		Log::Write(device->name);
Kernel/src/fs/filesystem.cpp:		} else if (node == &root && index < fs::volumes->get_length() + 1){
Kernel/src/fs/filesystem.cpp:			*dirent = (volumes->get_at(index - 1)->mountPointDirent);
Kernel/src/fs/filesystem.cpp:		} else return -1;
Kernel/src/fs/filesystem.cpp:			for(int i = 0; i < fs::volumes->get_length(); i++){
Kernel/src/fs/filesystem.cpp:				if(strcmp(fs::volumes->get_at(i)->mountPoint.name,name) == 0) return &(fs::volumes->get_at(i)->mountPoint);
Kernel/src/fs/filesystem.cpp:			if(index >= deviceCount) return -1;
Kernel/src/fs/filesystem.cpp:			memset(dirent->name,0,128); // Zero the string
Kernel/src/fs/filesystem.cpp:			strcpy(dirent->name,devices[index]->name);
Kernel/src/fs/filesystem.cpp:			dirent->inode = index;
Kernel/src/fs/filesystem.cpp:			dirent->type = 0;
Kernel/src/fs/filesystem.cpp:		} else return -2;
Kernel/src/fs/filesystem.cpp:				if(strcmp(devices[i]->name, name) == 0) return devices[i];
Kernel/src/fs/filesystem.cpp:		memset(buffer, -1, size);
Kernel/src/fs/filesystem.cpp:		if(node->flags & FS_NODE_SYMLINK) return Read(node->link, offset, size, buffer);
Kernel/src/fs/filesystem.cpp:        if(node->read)
Kernel/src/fs/filesystem.cpp:            return node->read(node,offset,size,buffer);
Kernel/src/fs/filesystem.cpp:		if(node->flags & FS_NODE_SYMLINK) return Write(node->link, offset, size, buffer);
Kernel/src/fs/filesystem.cpp:        if(node->write)
Kernel/src/fs/filesystem.cpp:            return node->write(node,offset,size,buffer);
Kernel/src/fs/filesystem.cpp:        if(node->open){
Kernel/src/fs/filesystem.cpp:            node->open(node,flags);
Kernel/src/fs/filesystem.cpp:		fd->pos = 0;
Kernel/src/fs/filesystem.cpp:		fd->node = node;
Kernel/src/fs/filesystem.cpp:		fd->mode = flags;
Kernel/src/fs/filesystem.cpp:        if(node->close){
Kernel/src/fs/filesystem.cpp:            return node->close(node);
Kernel/src/fs/filesystem.cpp:        if(fd->node->close){
Kernel/src/fs/filesystem.cpp:            fd->node->close(fd->node);
Kernel/src/fs/filesystem.cpp:		if(node->flags & FS_NODE_SYMLINK) return ReadDir(node->link, dirent, index);
Kernel/src/fs/filesystem.cpp:        if(node->readDir)
Kernel/src/fs/filesystem.cpp:            return node->readDir(node, dirent, index);
Kernel/src/fs/filesystem.cpp:		if(node->flags & FS_NODE_SYMLINK) return FindDir(node->link, name);
Kernel/src/fs/filesystem.cpp:        if(node->findDir)
Kernel/src/fs/filesystem.cpp:            return node->findDir(node, name);
Kernel/src/fs/filesystem.cpp:        if(handle->node){
Kernel/src/fs/filesystem.cpp:            off_t ret = Read(handle->node,handle->pos,size,buffer);
Kernel/src/fs/filesystem.cpp:			handle->pos += ret;
Kernel/src/fs/filesystem.cpp:        if(handle->node){
Kernel/src/fs/filesystem.cpp:            off_t ret = Write(handle->node,handle->pos,size,buffer);
Kernel/src/fs/filesystem.cpp:			handle->pos += ret;
Kernel/src/fs/filesystem.cpp:        if(handle->node)
Kernel/src/fs/filesystem.cpp:            return ReadDir(handle->node, dirent, index);
Kernel/src/fs/filesystem.cpp:        if(handle->node)
Kernel/src/fs/filesystem.cpp:            return FindDir(handle->node,name);
Kernel/src/fs/filesystem.cpp:		if(handle->node && handle->node->ioctl) return handle->node->ioctl(handle->node, cmd, arg);
Kernel/src/fs/filesystem.cpp:		else return -1;
Kernel/src/fs/initrd.cpp:			strcpy(node->name,nodes[i].filename);
Kernel/src/fs/initrd.cpp:			node->inode = i;
Kernel/src/fs/initrd.cpp:			node->flags = FS_NODE_FILE;
Kernel/src/fs/initrd.cpp:			node->read = Initrd::Read;
Kernel/src/fs/initrd.cpp:			node->write = Initrd::Write;
Kernel/src/fs/initrd.cpp:			node->open = Initrd::Open;
Kernel/src/fs/initrd.cpp:			node->close = Initrd::Close;
Kernel/src/fs/initrd.cpp:			node->size = nodes[i].size;
Kernel/src/fs/initrd.cpp:		fs::volumes->add_back(vol);
Kernel/src/fs/initrd.cpp:		strcpy(vol2->mountPoint.name, "lib");
Kernel/src/fs/initrd.cpp:		strcpy(vol2->mountPointDirent.name, "lib");
Kernel/src/fs/initrd.cpp:		fs::volumes->add_back(vol2);
Kernel/src/fs/initrd.cpp:		lemoninitfs_node_t inode = nodes[node->inode];
Kernel/src/fs/initrd.cpp:		else if(offset + size > inode.size || size > inode.size) size = inode.size - offset;
Kernel/src/fs/initrd.cpp:		if(index >= initrdHeader.fileCount + 2) return -1;
Kernel/src/fs/initrd.cpp:			memset(dirent->name,0,128); // Zero the string
Kernel/src/fs/initrd.cpp:			strcpy(dirent->name,".");
Kernel/src/fs/initrd.cpp:			dirent->inode = 0;
Kernel/src/fs/initrd.cpp:			dirent->type = FS_NODE_DIRECTORY;
Kernel/src/fs/initrd.cpp:			memset(dirent->name,0,128); // Zero the string
Kernel/src/fs/initrd.cpp:			strcpy(dirent->name,"..");
Kernel/src/fs/initrd.cpp:			dirent->inode = 2;
Kernel/src/fs/initrd.cpp:			dirent->type = FS_NODE_DIRECTORY;
Kernel/src/fs/initrd.cpp:		memset(dirent->name,0,128); // Zero the string
Kernel/src/fs/initrd.cpp:		strcpy(dirent->name,nodes[index - 2].filename);
Kernel/src/fs/initrd.cpp:		dirent->inode = index - 3;
Kernel/src/fs/initrd.cpp:		dirent->type = 0;
Kernel/src/fs/tar.cpp:    while (size-- && *str) {
Kernel/src/fs/tar.cpp:        n |= (*str - '0') & 0x7;
Kernel/src/fs/tar.cpp:    long round = (sz % 512) ? (512 - (sz % 512)) : 0; // Round up to 512 byte multiple
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            return ((TarVolume*)node->vol)->Read(node, offset, size, buffer);
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            return ((TarVolume*)node->vol)->Write(node, offset, size, buffer);
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            ((TarVolume*)node->vol)->Open(node, flags);
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            ((TarVolume*)node->vol)->Close(node);
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            return ((TarVolume*)node->vol)->ReadDir(node, dirent, index);
Kernel/src/fs/tar.cpp:        } else return -10;
Kernel/src/fs/tar.cpp:        if(node->vol){
Kernel/src/fs/tar.cpp:            return ((TarVolume*)node->vol)->FindDir(node, name);
Kernel/src/fs/tar.cpp:        n->parent = parent;
Kernel/src/fs/tar.cpp:        n->header = header;
Kernel/src/fs/tar.cpp:        n->node = nodeTemplate;
Kernel/src/fs/tar.cpp:        n->node.inode = inode;
Kernel/src/fs/tar.cpp:        n->node.uid = OctToDec(header->ustar.uid, 8);
Kernel/src/fs/tar.cpp:        n->node.flags = TarTypeToFilesystemFlags(header->ustar.type);
Kernel/src/fs/tar.cpp:        n->node.vol = this;
Kernel/src/fs/tar.cpp:        char* name = header->ustar.name;
Kernel/src/fs/tar.cpp:        char* _name = strtok(header->ustar.name, "/");
Kernel/src/fs/tar.cpp:        strcpy(n->node.name, name);
Kernel/src/fs/tar.cpp:        n->node.size = GetSize(header->ustar.size);
Kernel/src/fs/tar.cpp:        dirNode->node.read = dirNode->node.write = nullptr; // Is a directory
Kernel/src/fs/tar.cpp:        dirNode->entryCount = 0;
Kernel/src/fs/tar.cpp:        int i = blockIndex + GetBlockCount(dirHeader->ustar.size) + 1; // Next block
Kernel/src/fs/tar.cpp:        for(; i < blockCount; dirNode->entryCount++){
Kernel/src/fs/tar.cpp:            if(strncmp(blocks[i].ustar.name, dirHeader->ustar.name, strlen(dirHeader->ustar.name))){
Kernel/src/fs/tar.cpp:                break; // End of directory - header is not in directory
Kernel/src/fs/tar.cpp:        dirNode->children = (ino_t*)kmalloc(sizeof(ino_t) * dirNode->entryCount);
Kernel/src/fs/tar.cpp:        i = blockIndex + GetBlockCount(dirHeader->ustar.size) + 1;
Kernel/src/fs/tar.cpp:        for(int e = 0; i < blockCount && e < dirNode->entryCount; e++){ // Iterate through directory
Kernel/src/fs/tar.cpp:            dirNode->children[e] = inode;
Kernel/src/fs/tar.cpp:            if(!strchr(header.ustar.name, '/') || (header.ustar.type == TAR_TYPE_DIRECTORY && strchr(header.ustar.name, '/') == header.ustar.name + strlen(header.ustar.name) - 1)) entryCount++;
Kernel/src/fs/tar.cpp:        mountPoint = volumeNode->node;
Kernel/src/fs/tar.cpp:        strcpy(mountPoint.name, volumeNode->node.name);
Kernel/src/fs/tar.cpp:        volumeNode->children = (ino_t*)kmalloc(sizeof(ino_t) * entryCount);
Kernel/src/fs/tar.cpp:        volumeNode->entryCount = entryCount;
Kernel/src/fs/tar.cpp:                volumeNode->children[e] = nextNode; // Directory will take next available node so add it to children
Kernel/src/fs/tar.cpp:                volumeNode->children[e] = inode;
Kernel/src/fs/tar.cpp:        volumeNode->entryCount = e;
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:		if(offset > node->size) return 0;
Kernel/src/fs/tar.cpp:		else if(offset + size > node->size || size > node->size) size = node->size - offset;
Kernel/src/fs/tar.cpp:		memcpy(buffer, (void*)(((uintptr_t)tarNode->header) + 512 + offset), size);
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:        if(!(node->flags & FS_NODE_DIRECTORY)) return -1;
Kernel/src/fs/tar.cpp:        if(index >= tarNode->entryCount + 2) return -2;
Kernel/src/fs/tar.cpp:            strcpy(dirent->name, ".");
Kernel/src/fs/tar.cpp:            strcpy(dirent->name, "..");
Kernel/src/fs/tar.cpp:        tar_node_t* dir = &nodes[tarNode->children[index - 2]];
Kernel/src/fs/tar.cpp:        strcpy(dirent->name, dir->node.name);
Kernel/src/fs/tar.cpp:        dirent->type = dir->node.flags;
Kernel/src/fs/tar.cpp:        dirent->inode = dir->node.inode;
Kernel/src/fs/tar.cpp:        tar_node_t* tarNode = &nodes[node->inode];
Kernel/src/fs/tar.cpp:        if(!(node->flags & FS_NODE_DIRECTORY)) return nullptr;
Kernel/src/fs/tar.cpp:            if(node->inode == 0) return fs::GetRoot();
Kernel/src/fs/tar.cpp:            else return &nodes[tarNode->parent].node;
Kernel/src/fs/tar.cpp:        for(int i = 0; i < tarNode->entryCount; i++){
Kernel/src/fs/tar.cpp:            if(strcmp(nodes[tarNode->children[i]].node.name, name) == 0) return &nodes[tarNode->children[i]].node;
Kernel/src/gpt.cpp:        gpt_header_t* header = (gpt_header_t*)kmalloc(disk->blocksize);
Kernel/src/gpt.cpp:        if(disk->Read(1,disk->blocksize,(uint8_t*)header)){
Kernel/src/gpt.cpp:            return -1; // Disk Error
Kernel/src/gpt.cpp:        if(header->signature != GPT_HEADER_SIGNATURE /*Check Signature*/ || header->partNum == 0 /*Make sure there is at least 1 partition*/){
Kernel/src/gpt.cpp:        Log::Write(header->partNum);
Kernel/src/gpt.cpp:        Log::Write(header->partEntrySize);
Kernel/src/gpt.cpp:        uint64_t tableLBA = header->partitionTableLBA;
Kernel/src/gpt.cpp:        int partNum = 4;//header->partNum;
Kernel/src/gpt.cpp:        gpt_entry_t* partitionTable = (gpt_entry_t*)kmalloc(partNum * header->partEntrySize);
Kernel/src/gpt.cpp:        if(disk->Read(tableLBA,partNum * header->partEntrySize,(uint8_t*)partitionTable)){
Kernel/src/gpt.cpp:            return -1; // Disk Error
Kernel/src/gpt.cpp:            Log::Info("Found GPT Partition of size %d MB", (entry.endLBA - entry.startLBA) * 512 / 1024 / 1024);
Kernel/src/gpt.cpp:            if((entry.endLBA - entry.startLBA)){
Kernel/src/gpt.cpp:                disk->partitions.add_back(part);
Kernel/src/gpt.cpp:                DeviceManager::devices->add_back(part);
Kernel/src/kernel.cpp:	void* initElf = (void*)kmalloc(initFsNode->size);
Kernel/src/kernel.cpp:	fs::Read(initFsNode, 0, initFsNode->size, (uint8_t*)initElf);
Kernel/src/kernel.cpp:	strcpy(initProc->workingDir, "/initrd");
Kernel/src/kernel.cpp:		for(int i = 0; i < desktop->windows->windowCount; i++){
Kernel/src/kernel.cpp:			handle_t handle = desktop->windows->windows[i];
Kernel/src/kernel.cpp:			if(!Scheduler::FindProcessByPID(win->info.ownerPID)){
Kernel/src/kernel.cpp:				acquireLock(&desktop->lock);
Kernel/src/kernel.cpp:				while(desktop->windows->dirty == 2);
Kernel/src/kernel.cpp:				memcpy(&desktop->windows->windows[i], &desktop->windows->windows[i + 1], (desktop->windows->windowCount - i - 1));
Kernel/src/kernel.cpp:				desktop->windows->windowCount--;
Kernel/src/kernel.cpp:				desktop->windows->dirty = 1;
Kernel/src/kernel.cpp:				releaseLock(&desktop->lock);
Kernel/src/kernel.cpp:				Memory::DestroySharedMemory(win->info.primaryBufferKey);
Kernel/src/kernel.cpp:				Memory::DestroySharedMemory(win->info.secondaryBufferKey);
Kernel/src/kernel.cpp:	//Initrd::Initialize(initrd_start,initrd_end - initrd_start); // Initialize Initrd
Kernel/src/kernel.cpp:	fs::volumes->add_back(tar);
Kernel/src/kernel.cpp:	fs::volumes->add_back(new fs::LinkVolume(tar, "lib"));
Kernel/src/kernel.cpp:		if(node->flags & FS_NODE_DIRECTORY){
Kernel/src/kernel.cpp:		uint32_t size = splashFile->size;
Kernel/src/kernel.cpp:			Video::DrawBitmapImage(videoMode.width/2 - 484/2, videoMode.height/2 - 292/2, 484, 292, buffer);
Kernel/src/kernel.cpp:		uint32_t size = splashFile->size;
Kernel/src/kernel.cpp:			Video::DrawBitmapImage(videoMode.width/2 - 24*6, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/kernel.cpp:			Video::DrawBitmapImage(videoMode.width/2 - 24*5, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/kernel.cpp:	Video::DrawString("Copyright 2018-2020 JJ Roberts-White", 2, videoMode.height - 10, 255, 255, 255);
Kernel/src/kernel.cpp:	Video::DrawBitmapImage(videoMode.width/2 - 24*4, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/kernel.cpp:	Video::DrawBitmapImage(videoMode.width/2 - 24*3, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/kernel.cpp:	Video::DrawBitmapImage(videoMode.width/2 - 24*2, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/kernel.cpp:	Video::DrawBitmapImage(videoMode.width/2 - 24*1, videoMode.height/2 + 292/2 + 48, 24, 24, progressBuffer);
Kernel/src/liballoc/liballoc.c:			diff = (uintptr_t)ptr & (ALIGNMENT-1);						\
Kernel/src/liballoc/liballoc.c:				diff = ALIGNMENT - diff;								\
Kernel/src/liballoc/liballoc.c:			*((ALIGN_TYPE*)((uintptr_t)ptr - ALIGN_INFO)) = 			\
Kernel/src/liballoc/liballoc.c:			uintptr_t diff = *((ALIGN_TYPE*)((uintptr_t)ptr - ALIGN_INFO));	\
Kernel/src/liballoc/liballoc.c:				ptr = (void*)((uintptr_t)ptr - diff);					\
Kernel/src/liballoc/liballoc.c:		n -= sizeof(unsigned int);
Kernel/src/liballoc/liballoc.c:		n -= 1;
Kernel/src/liballoc/liballoc.c:	maj->prev = NULL;
Kernel/src/liballoc/liballoc.c:	maj->next = NULL;
Kernel/src/liballoc/liballoc.c:	maj->pages = st;
Kernel/src/liballoc/liballoc.c:	maj->size = st * l_pageSize;
Kernel/src/liballoc/liballoc.c:	maj->usage = sizeof(struct liballoc_major);
Kernel/src/liballoc/liballoc.c:	maj->first = NULL;
Kernel/src/liballoc/liballoc.c:	l_allocated += maj->size;
Kernel/src/liballoc/liballoc.c:	kprintf("liballoc: Resource allocated %x of %i pages (%i bytes) for %i size.\n", maj, st, maj->size, size);
Kernel/src/liballoc/liballoc.c:		bestSize = l_bestBet->size - l_bestBet->usage;
Kernel/src/liballoc/liballoc.c:		diff = maj->size - maj->usage;
Kernel/src/liballoc/liballoc.c:			if (maj->next != NULL)
Kernel/src/liballoc/liballoc.c:				maj = maj->next;		// Hop to that one.
Kernel/src/liballoc/liballoc.c:			maj->next = allocate_new_page(size);	// next one will be okay.
Kernel/src/liballoc/liballoc.c:			if (maj->next == NULL) break;			// no more memory.
Kernel/src/liballoc/liballoc.c:			maj->next->prev = maj;
Kernel/src/liballoc/liballoc.c:			maj = maj->next;
Kernel/src/liballoc/liballoc.c:		if (maj->first == NULL)
Kernel/src/liballoc/liballoc.c:			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major));
Kernel/src/liballoc/liballoc.c:			maj->first->magic = LIBALLOC_MAGIC;
Kernel/src/liballoc/liballoc.c:			maj->first->prev = NULL;
Kernel/src/liballoc/liballoc.c:			maj->first->next = NULL;
Kernel/src/liballoc/liballoc.c:			maj->first->block = maj;
Kernel/src/liballoc/liballoc.c:			maj->first->size = size;
Kernel/src/liballoc/liballoc.c:			maj->first->req_size = req_size;
Kernel/src/liballoc/liballoc.c:			maj->usage += size + sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:			p = (void*)((uintptr_t)(maj->first) + sizeof(struct liballoc_minor));
Kernel/src/liballoc/liballoc.c:		diff = (uintptr_t)(maj->first);
Kernel/src/liballoc/liballoc.c:		diff -= (uintptr_t)maj;
Kernel/src/liballoc/liballoc.c:		diff -= sizeof(struct liballoc_major);
Kernel/src/liballoc/liballoc.c:			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major));
Kernel/src/liballoc/liballoc.c:			maj->first->prev->next = maj->first;
Kernel/src/liballoc/liballoc.c:			maj->first = maj->first->prev;
Kernel/src/liballoc/liballoc.c:			maj->first->magic = LIBALLOC_MAGIC;
Kernel/src/liballoc/liballoc.c:			maj->first->prev = NULL;
Kernel/src/liballoc/liballoc.c:			maj->first->block = maj;
Kernel/src/liballoc/liballoc.c:			maj->first->size = size;
Kernel/src/liballoc/liballoc.c:			maj->first->req_size = req_size;
Kernel/src/liballoc/liballoc.c:			maj->usage += size + sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:			p = (void*)((uintptr_t)(maj->first) + sizeof(struct liballoc_minor));
Kernel/src/liballoc/liballoc.c:		min = maj->first;
Kernel/src/liballoc/liballoc.c:			if (min->next == NULL)
Kernel/src/liballoc/liballoc.c:				diff = (uintptr_t)(maj)+maj->size;
Kernel/src/liballoc/liballoc.c:				diff -= (uintptr_t)min;
Kernel/src/liballoc/liballoc.c:				diff -= sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:				diff -= min->size;
Kernel/src/liballoc/liballoc.c:					min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof(struct liballoc_minor) + min->size);
Kernel/src/liballoc/liballoc.c:					min->next->prev = min;
Kernel/src/liballoc/liballoc.c:					min = min->next;
Kernel/src/liballoc/liballoc.c:					min->next = NULL;
Kernel/src/liballoc/liballoc.c:					min->magic = LIBALLOC_MAGIC;
Kernel/src/liballoc/liballoc.c:					min->block = maj;
Kernel/src/liballoc/liballoc.c:					min->size = size;
Kernel/src/liballoc/liballoc.c:					min->req_size = req_size;
Kernel/src/liballoc/liballoc.c:					maj->usage += size + sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:			if (min->next != NULL)
Kernel/src/liballoc/liballoc.c:				diff = (uintptr_t)(min->next);
Kernel/src/liballoc/liballoc.c:				diff -= (uintptr_t)min;
Kernel/src/liballoc/liballoc.c:				diff -= sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:				diff -= min->size;
Kernel/src/liballoc/liballoc.c:					new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof(struct liballoc_minor) + min->size);
Kernel/src/liballoc/liballoc.c:					new_min->magic = LIBALLOC_MAGIC;
Kernel/src/liballoc/liballoc.c:					new_min->next = min->next;
Kernel/src/liballoc/liballoc.c:					new_min->prev = min;
Kernel/src/liballoc/liballoc.c:					new_min->size = size;
Kernel/src/liballoc/liballoc.c:					new_min->req_size = req_size;
Kernel/src/liballoc/liballoc.c:					new_min->block = maj;
Kernel/src/liballoc/liballoc.c:					min->next->prev = new_min;
Kernel/src/liballoc/liballoc.c:					min->next = new_min;
Kernel/src/liballoc/liballoc.c:					maj->usage += size + sizeof(struct liballoc_minor);
Kernel/src/liballoc/liballoc.c:			}	// min->next != NULL
Kernel/src/liballoc/liballoc.c:			min = min->next;
Kernel/src/liballoc/liballoc.c:		if (maj->next == NULL)
Kernel/src/liballoc/liballoc.c:			maj->next = allocate_new_page(size);		// next one guaranteed to be okay
Kernel/src/liballoc/liballoc.c:			if (maj->next == NULL) break;			//  uh oh,  no more memory.....
Kernel/src/liballoc/liballoc.c:			maj->next->prev = maj;
Kernel/src/liballoc/liballoc.c:		maj = maj->next;
Kernel/src/liballoc/liballoc.c:	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof(struct liballoc_minor));
Kernel/src/liballoc/liballoc.c:	if (min->magic != LIBALLOC_MAGIC)
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) ||
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) ||
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF))
Kernel/src/liballoc/liballoc.c:			kprintf("liballoc: ERROR: Possible 1-3 byte overrun\n");
Kernel/src/liballoc/liballoc.c:		if (min->magic == LIBALLOC_DEAD)
Kernel/src/liballoc/liballoc.c:	maj = min->block;
Kernel/src/liballoc/liballoc.c:	l_inuse -= min->size;
Kernel/src/liballoc/liballoc.c:	maj->usage -= (min->size + sizeof(struct liballoc_minor));
Kernel/src/liballoc/liballoc.c:	min->magic = LIBALLOC_DEAD;		// No mojo.
Kernel/src/liballoc/liballoc.c:	if (min->next != NULL) min->next->prev = min->prev;
Kernel/src/liballoc/liballoc.c:	if (min->prev != NULL) min->prev->next = min->next;
Kernel/src/liballoc/liballoc.c:	if (min->prev == NULL) maj->first = min->next;
Kernel/src/liballoc/liballoc.c:	if (maj->first == NULL)	// Block completely unused.
Kernel/src/liballoc/liballoc.c:		if (l_memRoot == maj) l_memRoot = maj->next;
Kernel/src/liballoc/liballoc.c:		if (maj->prev != NULL) maj->prev->next = maj->next;
Kernel/src/liballoc/liballoc.c:		if (maj->next != NULL) maj->next->prev = maj->prev;
Kernel/src/liballoc/liballoc.c:		l_allocated -= maj->size;
Kernel/src/liballoc/liballoc.c:		liballoc_free(maj, maj->pages);
Kernel/src/liballoc/liballoc.c:			int bestSize = l_bestBet->size - l_bestBet->usage;
Kernel/src/liballoc/liballoc.c:			int majSize = maj->size - maj->usage;
Kernel/src/liballoc/liballoc.c:	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof(struct liballoc_minor));
Kernel/src/liballoc/liballoc.c:	if (min->magic != LIBALLOC_MAGIC)
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) ||
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) ||
Kernel/src/liballoc/liballoc.c:			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF))
Kernel/src/liballoc/liballoc.c:			kprintf("liballoc: ERROR: Possible 1-3 byte overrun for magic %x != %x\n",
Kernel/src/liballoc/liballoc.c:				min->magic,
Kernel/src/liballoc/liballoc.c:		if (min->magic == LIBALLOC_DEAD)
Kernel/src/liballoc/liballoc.c:	real_size = min->req_size;
Kernel/src/liballoc/liballoc.c:		min->req_size = size;
Kernel/src/logging.cpp:		if(size + offset > logBufferPos) size = logBufferPos - offset;
Kernel/src/logging.cpp:			console->PrintN(str, n, 255, 255, 255);
Kernel/src/logging.cpp:			console->Update();
Kernel/src/math.cpp:	return num < x ? x - 1 : x;
Kernel/src/math.cpp:	return num < 0 ? -num : num;
Kernel/src/net/8254x.cpp:        while((Timer::GetSystemUptime() - _t) < 2);
Kernel/src/net/8254x.cpp:        while((Timer::GetSystemUptime() - _t) < 2);
Kernel/src/net/8254x.cpp:        while((Timer::GetSystemUptime() - _t) < 2);
Kernel/src/net/8254x.cpp:        while((Timer::GetSystemUptime() - _t) < 2);
Kernel/src/net/8254x.cpp:        status &= ~(1 << 7);  /* unset invert loss-of-signal */
Kernel/src/panic.cpp:	Video::DrawString("Lemon has encountered a fatal error.", 0, v.height - 200, 255, 255, 255);
Kernel/src/panic.cpp:	Video::DrawString("The system has been halted.", 0, v.height - 200 + 8, 255, 255, 255);
Kernel/src/sharedmem.cpp:            if((sMem->owner = pid)) return 1;
Kernel/src/sharedmem.cpp:        sMem->pgCount = pgCount;
Kernel/src/sharedmem.cpp:        sMem->pages = (uint64_t*)kmalloc(sMem->pgCount * sizeof(uint64_t*));
Kernel/src/sharedmem.cpp:        for(unsigned i = 0; i < sMem->pgCount; i++){
Kernel/src/sharedmem.cpp:            sMem->pages[i] = Memory::AllocatePhysicalMemoryBlock();
Kernel/src/sharedmem.cpp:        sMem->flags = flags;
Kernel/src/sharedmem.cpp:        sMem->owner = owner;
Kernel/src/sharedmem.cpp:        sMem->recipient = recipient;
Kernel/src/sharedmem.cpp:        if(sMem->flags & SMEM_FLAGS_PRIVATE){ // Private Mapping
Kernel/src/sharedmem.cpp:            if(proc->pid != sMem->owner && proc->pid != sMem->recipient){
Kernel/src/sharedmem.cpp:        if(hint && Memory::CheckRegion(hint, sMem->pgCount * PAGE_SIZE_4K, proc->addressSpace)){
Kernel/src/sharedmem.cpp:        } else mapping = Memory::Allocate4KPages(sMem->pgCount, proc->addressSpace);
Kernel/src/sharedmem.cpp:        for(unsigned i = 0; i < sMem->pgCount; i++){
Kernel/src/sharedmem.cpp:            Memory::MapVirtualMemory4K(sMem->pages[i], (uintptr_t)mapping + i * PAGE_SIZE_4K, 1, proc->addressSpace);
Kernel/src/sharedmem.cpp:        mReg.pageCount = sMem->pgCount;
Kernel/src/sharedmem.cpp:        proc->sharedMemory.add_back(mReg);
Kernel/src/storage/ahci.cpp:		uint32_t pi = ahciHBA->pi;
Kernel/src/storage/ahci.cpp:				if(((ahciHBA->ports[i].ssts >> 8) & 0x0F) != HBA_PORT_IPM_ACTIVE || (ahciHBA->ports[i].ssts & 0x0F) != HBA_PORT_DET_PRESENT) continue;
Kernel/src/storage/ahci.cpp:				if(ahciHBA->ports[i].sig == SATA_SIG_ATAPI) ;
Kernel/src/storage/ahci.cpp:				else if(ahciHBA->ports[i].sig == SATA_SIG_PM) ;
Kernel/src/storage/ahci.cpp:				else if(ahciHBA->ports[i].sig == SATA_SIG_SEMB) ;
Kernel/src/storage/ahci.cpp:					Log::Info("Found SATA Drive - Port: %d", i);
Kernel/src/storage/ahci.cpp:					Log::Info(ahciHBA->ports[i].sig);
Kernel/src/storage/ahci.cpp:					ports[i] = new Port(i, &ahciHBA->ports[i]);
Kernel/src/storage/ahci.cpp:					ports[i]->Read(0, 512, buf);
Kernel/src/storage/ahci.cpp:					DeviceManager::devices->add_back(ports[i]);
Kernel/src/storage/ahciport.cpp:		registers->cmd &= ~HBA_PxCMD_ST;
Kernel/src/storage/ahciport.cpp:		registers->cmd &= ~HBA_PxCMD_FRE;
Kernel/src/storage/ahciport.cpp:		registers->clb = (uint32_t)(phys & 0xFFFFFFFF);
Kernel/src/storage/ahciport.cpp:		registers->clbu = (uint32_t)(phys >> 32);
Kernel/src/storage/ahciport.cpp:		registers->fb = (uint32_t)(phys & 0xFFFFFFFF);
Kernel/src/storage/ahciport.cpp:		registers->fbu = (uint32_t)(phys >> 32);
Kernel/src/storage/ahciport.cpp:        Memory::KernelMapVirtualMemory4K(registers->clb, (uintptr_t)commandList, 1);
Kernel/src/storage/ahciport.cpp:        registers->clbu = 0;
Kernel/src/storage/ahciport.cpp:        Memory::KernelMapVirtualMemory4K(registers->fb, (uintptr_t)fis, 1);
Kernel/src/storage/ahciport.cpp:        registers->is = 0;
Kernel/src/storage/ahciport.cpp:		registers->cmd |= HBA_PxCMD_FRE;
Kernel/src/storage/ahciport.cpp:		registers->cmd |= HBA_PxCMD_ST; 
Kernel/src/storage/ahciport.cpp:            Log::Error("[SATA] Disk has a corrupted or non-existant GPT. MBR disks are NOT supported.");
Kernel/src/storage/ahciport.cpp:        case -1:
Kernel/src/storage/ahciport.cpp:        while(blockCount-- && count){
Kernel/src/storage/ahciport.cpp:        while(blockCount-- && count){
Kernel/src/storage/ahciport.cpp:        registers->is = 0xffff; 
Kernel/src/storage/ahciport.cpp:        if(slot == -1){
Kernel/src/storage/ahciport.cpp:        commandHeader->cfl = sizeof(fis_reg_h2d_t) / 4;
Kernel/src/storage/ahciport.cpp:        commandHeader->w = write;
Kernel/src/storage/ahciport.cpp:        commandHeader->c = 1;
Kernel/src/storage/ahciport.cpp:        commandHeader->p = 1;
Kernel/src/storage/ahciport.cpp:        commandTable->prdt_entry[0].dba = bufPhys & 0xFFFFFFFF;
Kernel/src/storage/ahciport.cpp:        commandTable->prdt_entry[0].dbau = (bufPhys >> 32) & 0xFFFFFFFF;
Kernel/src/storage/ahciport.cpp:        commandTable->prdt_entry[0].dbc = 511; // 512 bytes per sector
Kernel/src/storage/ahciport.cpp:        commandTable->prdt_entry[0].i = 0;
Kernel/src/storage/ahciport.cpp:        fis_reg_h2d_t* cmdfis = (fis_reg_h2d_t*)(commandTable->cfis); 
Kernel/src/storage/ahciport.cpp:        memset(commandTable->cfis, 0, sizeof(fis_reg_h2d_t));
Kernel/src/storage/ahciport.cpp:        cmdfis->fis_type = FIS_TYPE_REG_H2D;
Kernel/src/storage/ahciport.cpp:        cmdfis->c = 1;  // Command
Kernel/src/storage/ahciport.cpp:        cmdfis->pmport = 0; // Port multiplier
Kernel/src/storage/ahciport.cpp:        cmdfis->command = ATA_CMD_READ_DMA_EX;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba0 = lba & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba1 = (lba >> 8) & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba2 = (lba >> 16) & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->device = 1 << 6;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba3 = (lba >> 24) & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba4 = (lba >> 32) & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->lba5 = (lba >> 40) & 0xFF;
Kernel/src/storage/ahciport.cpp:        cmdfis->countl = count & 0xff;
Kernel/src/storage/ahciport.cpp:        cmdfis->counth = count >> 8;
Kernel/src/storage/ahciport.cpp:        while ((registers->tfd & (ATA_DEV_BUSY | ATA_DEV_DRQ)) && spin < 1000000) {
Kernel/src/storage/ahciport.cpp:        registers->ci = 1 << slot;
Kernel/src/storage/ahciport.cpp:                if (!(registers->ci & (1 << slot))) 
Kernel/src/storage/ahciport.cpp:                if (registers->is & HBA_PxIS_TFES)   // Task file error
Kernel/src/storage/ahciport.cpp:        if (registers->is & HBA_PxIS_TFES) {
Kernel/src/storage/ahciport.cpp:        uint32_t slots = (registers->sact | registers->ci);
Kernel/src/storage/ahciport.cpp:        return -1;
Kernel/src/storage/ata.cpp:		while(timer--){
Kernel/src/storage/ata.cpp:					DeviceManager::devices->add_back(drives[i * 2 + j]);
Kernel/src/storage/ata.cpp:		while(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x80 || !(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x40));
Kernel/src/storage/ata.cpp:		outportd(busMasterPort + ATA_BMR_PRDT_ADDRESS, drive->prdtPhys);
Kernel/src/storage/ata.cpp:		while(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x80);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_DRIVE_HEAD, 0x40 | (drive->drive << 4));
Kernel/src/storage/ata.cpp:		WriteControlRegister(drive->port, 0, 0);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_SECTOR_COUNT, (count >> 8) & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_LOW, (lba >> 24) & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_MID, (lba >> 32) & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_HIGH, (lba >> 40) & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_SECTOR_COUNT, count & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_LOW, lba & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_MID, (lba >> 8) & 0xFF);
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_LBA_HIGH, (lba >> 16) & 0xFF);
Kernel/src/storage/ata.cpp:		while(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x80 || !(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x40));
Kernel/src/storage/ata.cpp:		WriteRegister(drive->port, ATA_REGISTER_COMMAND, 0x25); // 48-bit read DMA
Kernel/src/storage/ata.cpp:		while(!(inportb(busMasterPort + ATA_BMR_STATUS) & 0x4));// || (ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x80));
Kernel/src/storage/ata.cpp:		if(ReadRegister(drive->port, ATA_REGISTER_STATUS) & 0x1){
Kernel/src/storage/ata.cpp:		memcpy(buffer, drive->prdBuffer, count * 512);
Kernel/src/storage/atadrive.cpp:        this->port = port;
Kernel/src/storage/atadrive.cpp:        this->drive = drive;
Kernel/src/storage/atadrive.cpp:            Log::Write(this->port ? "Secondary " : "Primary ");
Kernel/src/storage/atadrive.cpp:            Log::Write(this->drive ? "Slave " : "Master ");
Kernel/src/storage/atadrive.cpp:            Log::Write("has a corrupted or non-existant GPT. MBR disks are NOT supported.");
Kernel/src/storage/atadrive.cpp:        case -1:
Kernel/src/storage/atadrive.cpp:            Log::Write(this->port ? "Secondary " : "Primary ");
Kernel/src/storage/atadrive.cpp:            Log::Write(this->drive ? "Slave " : "Master ");
Kernel/src/storage/atadrive.cpp:        while(blockCount-- && count){
Kernel/src/storage/diskdevice.cpp:            fs::volumes->add_back(new fs::FAT32::Fat32Volume(partitions.get_at(i),name));
Kernel/src/storage/nvme.cpp:        device.subclass = 0x08; // Non-volatile memory controller subclass
Kernel/src/storage/partitiondevice.cpp:    this->startLBA = startLBA;
Kernel/src/storage/partitiondevice.cpp:    this->endLBA = endLBA;
Kernel/src/storage/partitiondevice.cpp:    this->parentDisk = disk;
Kernel/src/storage/partitiondevice.cpp:    if(count * parentDisk->blocksize > (endLBA - startLBA) * parentDisk->blocksize) return 2;
Kernel/src/storage/partitiondevice.cpp:    return parentDisk->Read(lba + startLBA, count, buffer);
Kernel/src/string.cpp:   for (c = 0; c < length - 1; c++)
Kernel/src/string.cpp:      end--;
Kernel/src/string.cpp:		str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
Kernel/src/string.cpp:	while (count--)
Kernel/src/string.cpp:		count -= sizeof(uint64_t);
Kernel/src/string.cpp:		count -= 4;
Kernel/src/string.cpp:		count--;
Kernel/src/string.cpp:            return -1;
Kernel/src/string.cpp:			return s1[i] < s2[i] ? -1 : 1;
Kernel/src/string.cpp:			return s1[i] < s2[i] ? -1 : 1;
Kernel/src/string.cpp:// strchr - Get pointer to first occurance of c in string s
Kernel/src/string.cpp:// strspn - Get initial length of s1 including only the characters of s2
Kernel/src/string.cpp:// strspn - Get initial length of s1 excluding the characters of s2
Kernel/src/string.cpp:// strtok - breaks str into tokens using specified delimiters
Kernel/src/string.cpp:		return c - 'a' + 'A';
Kernel/src/tty/pty.cpp:	Log::Info(ptys->get_length());
Kernel/src/tty/pty.cpp:	PTY* pty = (*ptys)[node->inode];
Kernel/src/tty/pty.cpp:		return pty->Slave_Read((char*)buffer,size);
Kernel/src/tty/pty.cpp:	PTY* pty = (*ptys)[node->inode];
Kernel/src/tty/pty.cpp:		return pty->Master_Read((char*)buffer,size);
Kernel/src/tty/pty.cpp:	PTY* pty = (*ptys)[node->inode];
Kernel/src/tty/pty.cpp:		return pty->Slave_Write((char*)buffer,size);
Kernel/src/tty/pty.cpp:	PTY* pty = (*ptys)[node->inode];
Kernel/src/tty/pty.cpp:		return pty->Master_Write((char*)(buffer + 1),size);
Kernel/src/tty/pty.cpp:	PTY* pty = (*ptys)[node->inode];
Kernel/src/tty/pty.cpp:	if(!pty) return -1;
Kernel/src/tty/pty.cpp:			*((winsz*)arg) = pty->wSz;
Kernel/src/tty/pty.cpp:			pty->wSz = *((winsz*)arg);
Kernel/src/tty/pty.cpp:			return -1;
Kernel/src/tty/pty.cpp:	slaveFile.inode = ptys->get_length();
Kernel/src/tty/pty.cpp:	masterFile.inode = ptys->get_length();
Kernel/src/tty/pty.cpp:	ptys->add_back(this);
Kernel/src/usb/xhci.cpp:            opRegs = (xhci_op_regs_t*)(xhciVirtualAddress + capRegs->capLength);
Kernel/src/usb/xhci.cpp:            while(timer-- && (opRegs->usbStatus & USB_STS_CNR));
Kernel/src/usb/xhci.cpp:            if((opRegs->usbStatus & USB_STS_CNR)){
Kernel/src/video.cpp:{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00 },   // U+002D (-)
Kernel/src/video.cpp:        uint32_t bmp_offset = rowSize * (h - 1);
Kernel/src/video.cpp:            bmp_offset -= rowSize;
Kernel/src/videoconsole.cpp:    this->x = x;
Kernel/src/videoconsole.cpp:    this->y = y;
Kernel/src/videoconsole.cpp:    this->width = width;
Kernel/src/videoconsole.cpp:    this->height = height;
Kernel/src/videoconsole.cpp:    widthInCharacters = width / 8 - 1;
Kernel/src/videoconsole.cpp:    heightInCharacters = height / 8 - 1;
Kernel/src/videoconsole.cpp:            cursorX--;
Kernel/src/videoconsole.cpp:                cursorX = widthInCharacters - 1;
Kernel/src/videoconsole.cpp:                cursorY--;
Kernel/src/videoconsole.cpp:    memcpy(characterBuffer,(void*)(characterBuffer + widthInCharacters), widthInCharacters*(heightInCharacters-1)*sizeof(ConsoleCharacter));
Kernel/src/videoconsole.cpp:    cursorY--;
Kernel/subprojects/lai/.git/config:	url = https://github.com/qword-os/lai.git
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:# applypatch from an e-mail message.
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:# The hook should exit with non-zero status after issuing an
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:# To enable this hook, rename this file to "applypatch-msg".
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:. git-sh-setup
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
Kernel/subprojects/lai/.git/hooks/applypatch-msg.sample:test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# that has the commit message.  The hook should exit with non-zero
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# To enable this hook, rename this file to "commit-msg".
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# Uncomment the below to add a Signed-off-by line to the message.
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:# This example catches duplicate Signed-off-by lines.
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:test "" = "$(grep '^Signed-off-by: ' "$1" |
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
Kernel/subprojects/lai/.git/hooks/commit-msg.sample:	echo >&2 Duplicate Signed-off-by lines.
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:# To enable this hook, rename this file to "query-watchman" and set
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:# 'git config core.fsmonitor .git/hooks/query-watchman'
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	die "Unsupported query-fsmonitor hook version '$version'.\n" .
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	my $o = $json_pkg->new->utf8->decode($response);
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:		$retry--;
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	die "Watchman: $o->{error}.\n" .
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	    "Falling back to scanning...\n" if $o->{error};
Kernel/subprojects/lai/.git/hooks/fsmonitor-watchman.sample:	print @{$o->{files}};
Kernel/subprojects/lai/.git/hooks/post-update.sample:# To enable this hook, rename this file to "post-update".
Kernel/subprojects/lai/.git/hooks/post-update.sample:exec git update-server-info
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:# by applypatch from an e-mail message.
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:# The hook should exit with non-zero status after issuing an
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:# To enable this hook, rename this file to "pre-applypatch".
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:. git-sh-setup
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:precommit="$(git rev-parse --git-path hooks/pre-commit)"
Kernel/subprojects/lai/.git/hooks/pre-applypatch.sample:test -x "$precommit" && exec "$precommit" ${1+"$@"}
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:# exit with non-zero status after issuing an appropriate message if
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:# To enable this hook, rename this file to "pre-commit".
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:if git rev-parse --verify HEAD >/dev/null 2>&1
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:# If you want to allow non-ASCII filenames set this variable to true.
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:allownonascii=$(git config --bool hooks.allownonascii)
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:# Cross platform projects tend to avoid non-ASCII filenames; prevent
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:	test $(git diff --cached --name-only --diff-filter=A -z $against |
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
Kernel/subprojects/lai/.git/hooks/pre-commit.sample:exec git diff-index --check --cached $against --
Kernel/subprojects/lai/.git/hooks/pre-push.sample:# pushed.  If this script exits with a non-zero status nothing will be pushed.
Kernel/subprojects/lai/.git/hooks/pre-push.sample:# $1 -- Name of the remote to which the push is being done
Kernel/subprojects/lai/.git/hooks/pre-push.sample:# $2 -- URL to which the push is being done
Kernel/subprojects/lai/.git/hooks/pre-push.sample:		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
Kernel/subprojects/lai/.git/hooks/pre-push.sample:		if [ -n "$commit" ]
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:# The "pre-rebase" hook is run just before "git rebase" starts doing
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:# non-zero status.
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:# $1 -- the upstream the series was forked from.
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:# $2 -- the branch being rebased (or empty when rebasing the current branch).
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	topic=`git symbolic-ref HEAD` ||
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:git show-ref -q "$topic" || {
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:if test -z "$not_in_master"
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:only_next_2=`git rev-list ^master           ${publish} | sort`
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	not_in_topic=`git rev-list "^$topic" master`
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	if test -z "$not_in_topic"
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	/usr/bin/perl -e '
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:			/^([0-9a-f]+) /;
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:				/^([0-9a-f]+) (.*)$/;
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:    build on top of it -- other people may already want to
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:		   o---o---o---o---o---o---o---o---o---o "next"
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:		 /   a---a---b A     /           /
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	       /   /   c---c---c---c B         /
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	     /   /   /   b---b C     \       /
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:    ---o---o---o---o---o---o---o---o---o---o---o "master"
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	git rev-list ^master ^topic next
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	git rev-list ^master        next
Kernel/subprojects/lai/.git/hooks/pre-rebase.sample:	git rev-list master..topic
Kernel/subprojects/lai/.git/hooks/pre-receive.sample:# To enable this hook, rename this file to "pre-receive".
Kernel/subprojects/lai/.git/hooks/pre-receive.sample:if test -n "$GIT_PUSH_OPTION_COUNT"
Kernel/subprojects/lai/.git/hooks/pre-receive.sample:	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
Kernel/subprojects/lai/.git/hooks/pre-receive.sample:			echo "echo from the pre-receive-hook: ${value#*=}" >&2
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# message file.  If the hook fails with a non-zero status,
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# To enable this hook, rename this file to "prepare-commit-msg".
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# The second includes the output of "git diff --name-status -r"
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# commented because it doesn't cope with --amend or with squashed
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# The third example adds a Signed-off-by line to the message, that can
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:#    /usr/bin/perl -i.bak -pe '
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:#       print "\n" . `git diff --cached --name-status -r`
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:# if test -z "$COMMIT_SOURCE"
Kernel/subprojects/lai/.git/hooks/prepare-commit-msg.sample:#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
Kernel/subprojects/lai/.git/hooks/update.sample:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
Kernel/subprojects/lai/.git/hooks/update.sample:# ------
Kernel/subprojects/lai/.git/hooks/update.sample:# --- Command line
Kernel/subprojects/lai/.git/hooks/update.sample:# --- Safety check
Kernel/subprojects/lai/.git/hooks/update.sample:if [ -z "$GIT_DIR" ]; then
Kernel/subprojects/lai/.git/hooks/update.sample:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
Kernel/subprojects/lai/.git/hooks/update.sample:# --- Config
Kernel/subprojects/lai/.git/hooks/update.sample:allowunannotated=$(git config --bool hooks.allowunannotated)
Kernel/subprojects/lai/.git/hooks/update.sample:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
Kernel/subprojects/lai/.git/hooks/update.sample:denycreatebranch=$(git config --bool hooks.denycreatebranch)
Kernel/subprojects/lai/.git/hooks/update.sample:allowdeletetag=$(git config --bool hooks.allowdeletetag)
Kernel/subprojects/lai/.git/hooks/update.sample:allowmodifytag=$(git config --bool hooks.allowmodifytag)
Kernel/subprojects/lai/.git/hooks/update.sample:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
Kernel/subprojects/lai/.git/hooks/update.sample:# --- Check types
Kernel/subprojects/lai/.git/hooks/update.sample:	newrev_type=$(git cat-file -t $newrev)
Kernel/subprojects/lai/.git/hooks/update.sample:		# un-annotated tag
Kernel/subprojects/lai/.git/hooks/update.sample:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
Kernel/subprojects/lai/.git/hooks/update.sample:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
Kernel/subprojects/lai/.git/hooks/update.sample:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
Kernel/subprojects/lai/.git/hooks/update.sample:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
Kernel/subprojects/lai/.git/hooks/update.sample:# --- Finished
Binary file Kernel/subprojects/lai/.git/index matches
Kernel/subprojects/lai/.git/info/exclude:# git ls-files --others --exclude-from=.git/info/exclude
Kernel/subprojects/lai/.git/logs/HEAD:0000000000000000000000000000000000000000 2a0a575c443577ef72851f49bc580932a2805a6c fido2020 <fidojj@hotmail.com> 1587723506 +1000	clone: from https://github.com/qword-os/lai.git
Kernel/subprojects/lai/.git/logs/refs/heads/master:0000000000000000000000000000000000000000 2a0a575c443577ef72851f49bc580932a2805a6c fido2020 <fidojj@hotmail.com> 1587723506 +1000	clone: from https://github.com/qword-os/lai.git
Kernel/subprojects/lai/.git/logs/refs/remotes/origin/HEAD:0000000000000000000000000000000000000000 2a0a575c443577ef72851f49bc580932a2805a6c fido2020 <fidojj@hotmail.com> 1587723506 +1000	clone: from https://github.com/qword-os/lai.git
Binary file Kernel/subprojects/lai/.git/objects/pack/pack-eb64095a50e5347e0926aadec6b29066695c027c.idx matches
Binary file Kernel/subprojects/lai/.git/objects/pack/pack-eb64095a50e5347e0926aadec6b29066695c027c.pack matches
Kernel/subprojects/lai/.git/packed-refs:# pack-refs with: peeled fully-peeled sorted 
Kernel/subprojects/lai/AUTHORS.md:- Alexander van der Grinten (GitHub: @avdgrinten)
Kernel/subprojects/lai/AUTHORS.md:- Qookie (GitHub: @qookei)
Kernel/subprojects/lai/AUTHORS.md:- toor (GitHub: @too-r)
Kernel/subprojects/lai/core/aml_opcodes.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/error.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/eval.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/eval.c:        return character - '0';
Kernel/subprojects/lai/core/eval.c:        return character - 'A' + 10;
Kernel/subprojects/lai/core/eval.c:        return character - 'a' + 10;
Kernel/subprojects/lai/core/eval.c:    object->type = LAI_INTEGER;
Kernel/subprojects/lai/core/eval.c:    out |= ((id[0] - 0x40) << 26);
Kernel/subprojects/lai/core/eval.c:    out |= ((id[1] - 0x40) << 21);
Kernel/subprojects/lai/core/eval.c:    out |= ((id[2] - 0x40) << 16);
Kernel/subprojects/lai/core/eval.c:    object->integer = (uint64_t)out & 0xFFFFFFFF;
Kernel/subprojects/lai/core/eval.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/exec-operand.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/exec-operand.c:    LAI_ENSURE(str->type == LAI_STRING);
Kernel/subprojects/lai/core/exec-operand.c:    return lai_strlen(str->string_ptr->content);
Kernel/subprojects/lai/core/exec-operand.c:    lai_var_assign(out, &head->elems[i]);
Kernel/subprojects/lai/core/exec-operand.c:    lai_var_assign(&head->elems[i], in);
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:    switch (ref->type) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(object, &ref->iref_invocation->arg[ref->iref_index]);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(object, &ref->iref_invocation->local[ref->iref_index]);
Kernel/subprojects/lai/core/exec-operand.c:            lai_exec_access(object, ref->handle);
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("unknown reference type %d for lai_exec_ref_load()", ref->type);
Kernel/subprojects/lai/core/exec-operand.c:    switch (ref->type) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(&ref->iref_invocation->arg[ref->iref_index], object);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(&ref->iref_invocation->local[ref->iref_index], object);
Kernel/subprojects/lai/core/exec-operand.c:            lai_store_ns(ref->handle, object);
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("unknown reference type %d for lai_exec_ref_store()", ref->type);
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:    switch (src->type) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(object, &src->object);
Kernel/subprojects/lai/core/exec-operand.c:            object->type = LAI_HANDLE;
Kernel/subprojects/lai/core/exec-operand.c:            object->handle = src;
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("unexpected type %d of named object in lai_exec_access()", src->type);
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec-operand.c:    switch (src->tag) {
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(object, &ctxitem->invocation->arg[src->index]);
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(object, &ctxitem->invocation->local[src->index]);
Kernel/subprojects/lai/core/exec-operand.c:            lai_exec_access(object, src->handle);
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("tag %d is not valid for lai_load()", src->tag);
Kernel/subprojects/lai/core/exec-operand.c:    switch (target->type) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(&target->object, object);
Kernel/subprojects/lai/core/exec-operand.c:    switch (target->type) {
Kernel/subprojects/lai/core/exec-operand.c:            switch (target->object.type) {
Kernel/subprojects/lai/core/exec-operand.c:                    if(lai_mutate_integer(&target->object, object))
Kernel/subprojects/lai/core/exec-operand.c:                    if(lai_mutate_string(&target->object, object))
Kernel/subprojects/lai/core/exec-operand.c:                    if(lai_mutate_buffer(&target->object, object))
Kernel/subprojects/lai/core/exec-operand.c:                    LAI_ENSURE(object->type == LAI_PACKAGE); // TODO: Implement conversion.
Kernel/subprojects/lai/core/exec-operand.c:                    if (lai_obj_resize_pkg(&target->object, n))
Kernel/subprojects/lai/core/exec-operand.c:                        lai_exec_pkg_store(&temp, &target->object, i);
Kernel/subprojects/lai/core/exec-operand.c:                    lai_var_assign(&target->object, object);
Kernel/subprojects/lai/core/exec-operand.c:// lai_operand_mutate(): Modifies the operand in-place to store the object.
Kernel/subprojects/lai/core/exec-operand.c:    if (dest->tag == LAI_OPERAND_OBJECT) {
Kernel/subprojects/lai/core/exec-operand.c:        switch (dest->object.type) {
Kernel/subprojects/lai/core/exec-operand.c:                char *window = dest->object.string_ptr->content;
Kernel/subprojects/lai/core/exec-operand.c:                window[dest->object.integer] = object->integer;
Kernel/subprojects/lai/core/exec-operand.c:                uint8_t *window = dest->object.buffer_ptr->content;
Kernel/subprojects/lai/core/exec-operand.c:                window[dest->object.integer] = object->integer;
Kernel/subprojects/lai/core/exec-operand.c:                lai_exec_pkg_var_store(&copy, dest->object.pkg_ptr, dest->object.integer);
Kernel/subprojects/lai/core/exec-operand.c:                lai_panic("unexpected object type %d for lai_store_overwrite()", dest->object.type);
Kernel/subprojects/lai/core/exec-operand.c:    switch (dest->tag) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_exec_mutate_ns(dest->handle, object);
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_variable_t *arg_var = &ctxitem->invocation->arg[dest->index];
Kernel/subprojects/lai/core/exec-operand.c:            switch (arg_var->type) {
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(&ctxitem->invocation->local[dest->index], object);
Kernel/subprojects/lai/core/exec-operand.c:                switch (object->type) {
Kernel/subprojects/lai/core/exec-operand.c:                        lai_debug("Debug(): integer(%ld)", object->integer);
Kernel/subprojects/lai/core/exec-operand.c:                        lai_debug("Debug(): type %d", object->type);
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("tag %d is not valid for lai_store_overwrite()", dest->tag);
Kernel/subprojects/lai/core/exec-operand.c:    if (dest->tag == LAI_OPERAND_OBJECT) {
Kernel/subprojects/lai/core/exec-operand.c:        switch (dest->object.type) {
Kernel/subprojects/lai/core/exec-operand.c:                char *window = dest->object.string_ptr->content;
Kernel/subprojects/lai/core/exec-operand.c:                window[dest->object.integer] = object->integer;
Kernel/subprojects/lai/core/exec-operand.c:                uint8_t *window = dest->object.buffer_ptr->content;
Kernel/subprojects/lai/core/exec-operand.c:                window[dest->object.integer] = object->integer;
Kernel/subprojects/lai/core/exec-operand.c:                lai_exec_pkg_var_store(&copy, dest->object.pkg_ptr, dest->object.integer);
Kernel/subprojects/lai/core/exec-operand.c:                lai_panic("unexpected object type %d for lai_store_overwrite()", dest->object.type);
Kernel/subprojects/lai/core/exec-operand.c:    switch (dest->tag) {
Kernel/subprojects/lai/core/exec-operand.c:            lai_store_ns(dest->handle, object);
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_variable_t *arg_var = &ctxitem->invocation->arg[dest->index];
Kernel/subprojects/lai/core/exec-operand.c:            switch (arg_var->type) {
Kernel/subprojects/lai/core/exec-operand.c:            LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec-operand.c:            lai_var_assign(&ctxitem->invocation->local[dest->index], object);
Kernel/subprojects/lai/core/exec-operand.c:                switch (object->type) {
Kernel/subprojects/lai/core/exec-operand.c:                        lai_debug("Debug(): integer(%ld)", object->integer);
Kernel/subprojects/lai/core/exec-operand.c:                        lai_debug("Debug(): type %d", object->type);
Kernel/subprojects/lai/core/exec-operand.c:            lai_panic("tag %d is not valid for lai_store_overwrite()", dest->tag);
Kernel/subprojects/lai/core/exec-operand.c:// Returns immediate objects and indices as-is (i.e., without load from a name).
Kernel/subprojects/lai/core/exec-operand.c:    LAI_ENSURE(src->tag == LAI_OPERAND_OBJECT);
Kernel/subprojects/lai/core/exec-operand.c:    lai_var_assign(object, &src->object);
Kernel/subprojects/lai/core/exec-operand.c:// Returns immediate objects as-is.
Kernel/subprojects/lai/core/exec-operand.c:    LAI_ENSURE(src->tag == LAI_OPERAND_OBJECT);
Kernel/subprojects/lai/core/exec-operand.c:    lai_var_assign(&temp, &src->object);
Kernel/subprojects/lai/core/exec-operand.c:    lai_nsnode_t *buffer_handle = handle->bf_node;
Kernel/subprojects/lai/core/exec-operand.c:    uint64_t value = source->integer;
Kernel/subprojects/lai/core/exec-operand.c:    size_t offset = handle->bf_offset;
Kernel/subprojects/lai/core/exec-operand.c:    size_t size = handle->bf_size;
Kernel/subprojects/lai/core/exec-operand.c:    uint8_t *data = lai_exec_buffer_access(&buffer_handle->object);
Kernel/subprojects/lai/core/exec-operand.c:        int m = size - n;
Kernel/subprojects/lai/core/exec-operand.c:        if (m > (8 - bit))
Kernel/subprojects/lai/core/exec-operand.c:            m = 8 - bit;
Kernel/subprojects/lai/core/exec-operand.c:        uint8_t mask = (1 << m) - 1;
Kernel/subprojects/lai/core/exec-operand.c:	lai_nsnode_t *buffer_handle = handle->bf_node;
Kernel/subprojects/lai/core/exec-operand.c:	size_t offset = handle->bf_offset;
Kernel/subprojects/lai/core/exec-operand.c:	size_t size = handle->bf_size;
Kernel/subprojects/lai/core/exec-operand.c:	uint8_t *data = lai_exec_buffer_access(&buffer_handle->object);
Kernel/subprojects/lai/core/exec-operand.c:	dest->type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec-operand.c:	dest->integer = 0;
Kernel/subprojects/lai/core/exec-operand.c:		int m = size - n;
Kernel/subprojects/lai/core/exec-operand.c:		if (m > (8 - bit))
Kernel/subprojects/lai/core/exec-operand.c:			m = 8 - bit;
Kernel/subprojects/lai/core/exec-operand.c:		uint8_t mask = (1 << m) - 1;
Kernel/subprojects/lai/core/exec-operand.c:		dest->integer |= (uint64_t)to_write << n;
Kernel/subprojects/lai/core/exec.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/exec.c:#include "util-list.h"
Kernel/subprojects/lai/core/exec.c:#include "util-macros.h"
Kernel/subprojects/lai/core/exec.c:// Param: lai_state_t *state - will store method name and arguments
Kernel/subprojects/lai/core/exec.c:// Param: lai_nsnode_t *method - identifies the control method
Kernel/subprojects/lai/core/exec.c:    state->ctxstack_base = state->small_ctxstack;
Kernel/subprojects/lai/core/exec.c:    state->blkstack_base = state->small_blkstack;
Kernel/subprojects/lai/core/exec.c:    state->stack_base = state->small_stack;
Kernel/subprojects/lai/core/exec.c:    state->opstack_base = state->small_opstack;
Kernel/subprojects/lai/core/exec.c:    state->ctxstack_capacity = LAI_SMALL_CTXSTACK_SIZE;
Kernel/subprojects/lai/core/exec.c:    state->blkstack_capacity = LAI_SMALL_BLKSTACK_SIZE;
Kernel/subprojects/lai/core/exec.c:    state->stack_capacity = LAI_SMALL_STACK_SIZE;
Kernel/subprojects/lai/core/exec.c:    state->opstack_capacity = LAI_SMALL_OPSTACK_SIZE;
Kernel/subprojects/lai/core/exec.c:    state->ctxstack_ptr = -1;
Kernel/subprojects/lai/core/exec.c:    state->blkstack_ptr = -1;
Kernel/subprojects/lai/core/exec.c:    state->stack_ptr = -1;
Kernel/subprojects/lai/core/exec.c:    while (state->ctxstack_ptr >= 0)
Kernel/subprojects/lai/core/exec.c:    while (state->blkstack_ptr >= 0)
Kernel/subprojects/lai/core/exec.c:    while (state->stack_ptr >= 0)
Kernel/subprojects/lai/core/exec.c:    lai_exec_pop_opstack(state, state->opstack_ptr);
Kernel/subprojects/lai/core/exec.c:    if (state->ctxstack_base != state->small_ctxstack)
Kernel/subprojects/lai/core/exec.c:        laihost_free(state->ctxstack_base);
Kernel/subprojects/lai/core/exec.c:    if (state->blkstack_base != state->small_blkstack)
Kernel/subprojects/lai/core/exec.c:        laihost_free(state->blkstack_base);
Kernel/subprojects/lai/core/exec.c:    if (state->stack_base != state->small_stack)
Kernel/subprojects/lai/core/exec.c:        laihost_free(state->stack_base);
Kernel/subprojects/lai/core/exec.c:    if (state->opstack_base != state->small_opstack)
Kernel/subprojects/lai/core/exec.c:        laihost_free(state->opstack_base);
Kernel/subprojects/lai/core/exec.c:    if (lhs->type != LAI_INTEGER || rhs->type != LAI_INTEGER)
Kernel/subprojects/lai/core/exec.c:                lhs->type, rhs->type);
Kernel/subprojects/lai/core/exec.c:    return lhs->integer - rhs->integer;
Kernel/subprojects/lai/core/exec.c:    if (lai_current_instance()->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:            node->type = LAI_NAMESPACE_NAME;
Kernel/subprojects/lai/core/exec.c:            lai_var_move(&node->object, &object);
Kernel/subprojects/lai/core/exec.c:            if (ctxitem->invocation)
Kernel/subprojects/lai/core/exec.c:                lai_list_link(&ctxitem->invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:            node->type = LAI_NAMESPACE_BUFFER_FIELD;
Kernel/subprojects/lai/core/exec.c:            node->bf_node = operands[0].handle;
Kernel/subprojects/lai/core/exec.c:                case BITFIELD_OP: node->bf_size = 1; break;
Kernel/subprojects/lai/core/exec.c:                case BYTEFIELD_OP: node->bf_size = 8; break;
Kernel/subprojects/lai/core/exec.c:                case WORDFIELD_OP: node->bf_size = 16; break;
Kernel/subprojects/lai/core/exec.c:                case DWORDFIELD_OP: node->bf_size = 32; break;
Kernel/subprojects/lai/core/exec.c:                case QWORDFIELD_OP: node->bf_size = 64; break;
Kernel/subprojects/lai/core/exec.c:            node->bf_offset = offset.integer * 8;
Kernel/subprojects/lai/core/exec.c:            if (ctxitem->invocation)
Kernel/subprojects/lai/core/exec.c:                lai_list_link(&ctxitem->invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:            node->type = LAI_NAMESPACE_OPREGION;
Kernel/subprojects/lai/core/exec.c:            node->op_address_space = operands[1].object.integer;
Kernel/subprojects/lai/core/exec.c:            node->op_base = base.integer;
Kernel/subprojects/lai/core/exec.c:            node->op_length = size.integer;
Kernel/subprojects/lai/core/exec.c:            if (ctxitem->invocation)
Kernel/subprojects/lai/core/exec.c:                lai_list_link(&ctxitem->invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:    if (lai_current_instance()->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:		result.integer = lsb == 0 ? 0 : (65 - lsb);
Kernel/subprojects/lai/core/exec.c:        result.integer = lhs.integer - rhs.integer;
Kernel/subprojects/lai/core/exec.c:        result.integer--;
Kernel/subprojects/lai/core/exec.c:                lai_rc_ref(&object.string_ptr->rc);
Kernel/subprojects/lai/core/exec.c:                lai_rc_ref(&object.buffer_ptr->rc);
Kernel/subprojects/lai/core/exec.c:                lai_rc_ref(&object.pkg_ptr->rc);
Kernel/subprojects/lai/core/exec.c:                char *window = ref.string_ptr->content;
Kernel/subprojects/lai/core/exec.c:                uint8_t *window = ref.buffer_ptr->content;
Kernel/subprojects/lai/core/exec.c:        switch (operand->tag) {
Kernel/subprojects/lai/core/exec.c:                LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec.c:                ref.iref_invocation = ctxitem->invocation;
Kernel/subprojects/lai/core/exec.c:                ref.iref_index = operand->index;
Kernel/subprojects/lai/core/exec.c:                LAI_ENSURE(ctxitem->invocation);
Kernel/subprojects/lai/core/exec.c:                ref.iref_invocation = ctxitem->invocation;
Kernel/subprojects/lai/core/exec.c:                ref.iref_index = operand->index;
Kernel/subprojects/lai/core/exec.c:                ref.handle = operand->handle;
Kernel/subprojects/lai/core/exec.c:                lai_panic("Unexpected operand tag %d for RefOf()", operand->tag);
Kernel/subprojects/lai/core/exec.c:        switch (operand->tag) {
Kernel/subprojects/lai/core/exec.c:                if (operand->handle) {
Kernel/subprojects/lai/core/exec.c:                    ref.handle = operand->handle;
Kernel/subprojects/lai/core/exec.c:                lai_panic("Unexpected operand tag %d for CondRefOf()", operand->tag);
Kernel/subprojects/lai/core/exec.c:            if(operands[0].handle->type == LAI_NAMESPACE_ALIAS)
Kernel/subprojects/lai/core/exec.c:                result.integer = lai_objecttype_ns(operands[0].handle->al_target);
Kernel/subprojects/lai/core/exec.c:            else if(operands[0].handle->type == LAI_NAMESPACE_NAME && operands[0].handle->object.type == LAI_NODE_REF)
Kernel/subprojects/lai/core/exec.c:                result.integer = lai_objecttype_ns(operands[0].handle->object.handle);
Kernel/subprojects/lai/core/exec.c:            if(node->type == LAI_NAMESPACE_ALIAS)
Kernel/subprojects/lai/core/exec.c:                result.integer = lai_objecttype_ns(node->al_target);
Kernel/subprojects/lai/core/exec.c:            else if(node->type == LAI_NAMESPACE_NAME && node->object.type == LAI_NODE_REF)
Kernel/subprojects/lai/core/exec.c:                result.integer = lai_objecttype_ns(node->object.handle);
Kernel/subprojects/lai/core/exec.c:                switch (trace_item->kind) {
Kernel/subprojects/lai/core/exec.c:                                i, trace_item->kind, trace_item->op_opcode);
Kernel/subprojects/lai/core/exec.c:                        lai_debug("stack item %d is of type %d", i, trace_item->kind);
Kernel/subprojects/lai/core/exec.c:// Process the top-most item of the execution stack.
Kernel/subprojects/lai/core/exec.c:    struct lai_aml_segment *amls = ctxitem->amls;
Kernel/subprojects/lai/core/exec.c:    uint8_t *method = ctxitem->code;
Kernel/subprojects/lai/core/exec.c:    lai_nsnode_t *ctx_handle = ctxitem->handle;
Kernel/subprojects/lai/core/exec.c:    struct lai_invocation *invocation = ctxitem->invocation;
Kernel/subprojects/lai/core/exec.c:    // Package-size encoding (and similar) needs to know the PC of the opcode.
Kernel/subprojects/lai/core/exec.c:    int opcode_pc = block->pc;
Kernel/subprojects/lai/core/exec.c:    int limit = block->limit;
Kernel/subprojects/lai/core/exec.c:    // This matches the offsets in the output of 'iasl -l'.
Kernel/subprojects/lai/core/exec.c:                      + (method - amls->table->data)
Kernel/subprojects/lai/core/exec.c:                      + (method - amls->table->data)
Kernel/subprojects/lai/core/exec.c:                      + block->limit;
Kernel/subprojects/lai/core/exec.c:    if (block->pc > block->limit)
Kernel/subprojects/lai/core/exec.c:    if (item->kind == LAI_POPULATE_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        if (block->pc == block->limit) {
Kernel/subprojects/lai/core/exec.c:    } else if(item->kind == LAI_METHOD_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        if (block->pc == block->limit) {
Kernel/subprojects/lai/core/exec.c:            if (state->opstack_ptr) // This is an internal error.
Kernel/subprojects/lai/core/exec.c:            if (item->mth_want_result) {
Kernel/subprojects/lai/core/exec.c:                result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:                result->object.integer = 0;
Kernel/subprojects/lai/core/exec.c:            // Clean up all per-method namespace nodes.
Kernel/subprojects/lai/core/exec.c:            while ((pmi = lai_list_first(&invocation->per_method_list))) {
Kernel/subprojects/lai/core/exec.c:                lai_list_unlink(&node->per_method_item);
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_BUFFER_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:            struct lai_operand *operand = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:            int initial_size = block->limit - block->pc;
Kernel/subprojects/lai/core/exec.c:            memcpy(lai_exec_buffer_access(&result), method + block->pc, initial_size);
Kernel/subprojects/lai/core/exec.c:            if (item->buf_want_result) {
Kernel/subprojects/lai/core/exec.c:                opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                lai_var_move(&opstack_res->object, &result);
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_PACKAGE_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        struct lai_operand *frame = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:        if (state->opstack_ptr == item->opstack_frame + 2) {
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(package->tag == LAI_OPERAND_OBJECT);
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(initializer->tag == LAI_OPERAND_OBJECT);
Kernel/subprojects/lai/core/exec.c:            if (item->pkg_index == (int) lai_exec_pkg_size(&package->object))
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(item->pkg_index < (int) lai_exec_pkg_size(&package->object));
Kernel/subprojects/lai/core/exec.c:            lai_exec_pkg_store(&initializer->object, &package->object, item->pkg_index);
Kernel/subprojects/lai/core/exec.c:            item->pkg_index++;
Kernel/subprojects/lai/core/exec.c:        LAI_ENSURE(state->opstack_ptr == item->opstack_frame + 1);
Kernel/subprojects/lai/core/exec.c:        if (block->pc == block->limit) {
Kernel/subprojects/lai/core/exec.c:            if (!item->pkg_want_result)
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_NODE_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:        if (!item->node_arg_modes[k]) {
Kernel/subprojects/lai/core/exec.c:            struct lai_operand *operands = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:            lai_exec_reduce_node(item->node_opcode, state, operands, ctx_handle);
Kernel/subprojects/lai/core/exec.c:            return lai_exec_parse(item->node_arg_modes[k], state);
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_OP_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:        if (!item->op_arg_modes[k]) {
Kernel/subprojects/lai/core/exec.c:            struct lai_operand *operands = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:            lai_api_error_t error = lai_exec_reduce_op(item->op_opcode, state, operands, &result);
Kernel/subprojects/lai/core/exec.c:            if (item->op_want_result) {
Kernel/subprojects/lai/core/exec.c:                opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                lai_var_move(&opstack_res->object, &result);
Kernel/subprojects/lai/core/exec.c:            return lai_exec_parse(item->op_arg_modes[k], state);
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_INVOKE_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int argc = item->ivk_argc;
Kernel/subprojects/lai/core/exec.c:        int want_result = item->ivk_want_result;
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:                    = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(opstack_method->tag == LAI_RESOLVED_NAME);
Kernel/subprojects/lai/core/exec.c:            lai_nsnode_t *handle = opstack_method->handle;
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(handle->type == LAI_NAMESPACE_METHOD);
Kernel/subprojects/lai/core/exec.c:                        = lai_exec_get_opstack(state, item->opstack_frame + 1 + i);
Kernel/subprojects/lai/core/exec.c:            if (handle->method_override) {
Kernel/subprojects/lai/core/exec.c:                // It's an OS-defined method.
Kernel/subprojects/lai/core/exec.c:                int e = handle->method_override(args, &method_result);
Kernel/subprojects/lai/core/exec.c:                    opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                    lai_var_move(&opstack_res->object, &method_result);
Kernel/subprojects/lai/core/exec.c:                LAI_ENSURE(handle->amls);
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->amls = handle->amls;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->code = handle->pointer;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->handle = handle;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->invocation = laihost_malloc(sizeof(struct lai_invocation));
Kernel/subprojects/lai/core/exec.c:                if (!method_ctxitem->invocation)
Kernel/subprojects/lai/core/exec.c:                memset(method_ctxitem->invocation, 0, sizeof(struct lai_invocation));
Kernel/subprojects/lai/core/exec.c:                lai_list_init(&method_ctxitem->invocation->per_method_list);
Kernel/subprojects/lai/core/exec.c:                    lai_var_move(&method_ctxitem->invocation->arg[i], &args[i]);
Kernel/subprojects/lai/core/exec.c:                blkitem->pc = 0;
Kernel/subprojects/lai/core/exec.c:                blkitem->limit = handle->size;
Kernel/subprojects/lai/core/exec.c:                item->kind = LAI_METHOD_STACKITEM;
Kernel/subprojects/lai/core/exec.c:                item->mth_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_RETURN_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:            struct lai_operand *operand = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:                // Ignore the top-most LAI_RETURN_STACKITEM.
Kernel/subprojects/lai/core/exec.c:                if (method_item->kind == LAI_METHOD_STACKITEM)
Kernel/subprojects/lai/core/exec.c:                if (method_item->kind != LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                        && method_item->kind != LAI_LOOP_STACKITEM)
Kernel/subprojects/lai/core/exec.c:                    lai_panic("Return() cannot skip item of type %d", method_item->kind);
Kernel/subprojects/lai/core/exec.c:            if (method_item->mth_want_result) {
Kernel/subprojects/lai/core/exec.c:                opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                lai_obj_clone(&opstack_res->object, &result);
Kernel/subprojects/lai/core/exec.c:            // Clean up all per-method namespace nodes.
Kernel/subprojects/lai/core/exec.c:            while ((pmi = lai_list_first(&invocation->per_method_list))) {
Kernel/subprojects/lai/core/exec.c:                lai_list_unlink(&node->per_method_item);
Kernel/subprojects/lai/core/exec.c:                LAI_ENSURE(pop_item->kind == LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                        || pop_item->kind == LAI_LOOP_STACKITEM);
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_LOOP_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        if (!item->loop_state) {
Kernel/subprojects/lai/core/exec.c:            int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:                struct lai_operand *operand = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:                    item->loop_state = LAI_LOOP_ITERATION;
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(item->loop_state == LAI_LOOP_ITERATION);
Kernel/subprojects/lai/core/exec.c:            if (block->pc == block->limit) {
Kernel/subprojects/lai/core/exec.c:                item->loop_state = 0;
Kernel/subprojects/lai/core/exec.c:                block->pc = item->loop_pred;
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_COND_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        if (!item->cond_state) {
Kernel/subprojects/lai/core/exec.c:            int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:                struct lai_operand *operand = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:                    item->cond_state = LAI_COND_BRANCH;
Kernel/subprojects/lai/core/exec.c:                    if (item->cond_has_else) {
Kernel/subprojects/lai/core/exec.c:                        item->cond_state = LAI_COND_BRANCH;
Kernel/subprojects/lai/core/exec.c:                        block->pc = item->cond_else_pc;
Kernel/subprojects/lai/core/exec.c:                        block->limit = item->cond_else_limit;
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(item->cond_state == LAI_COND_BRANCH);
Kernel/subprojects/lai/core/exec.c:            if (block->pc == block->limit) {
Kernel/subprojects/lai/core/exec.c:    } else if (item->kind == LAI_BANKFIELD_STACKITEM) {
Kernel/subprojects/lai/core/exec.c:        int k = state->opstack_ptr - item->opstack_frame;
Kernel/subprojects/lai/core/exec.c:            operand = lai_exec_get_opstack(state, item->opstack_frame);
Kernel/subprojects/lai/core/exec.c:            lai_nsnode_t *region_node = operand->handle;
Kernel/subprojects/lai/core/exec.c:            operand = lai_exec_get_opstack(state, item->opstack_frame + 1);
Kernel/subprojects/lai/core/exec.c:            lai_nsnode_t *bank_node = operand->handle;
Kernel/subprojects/lai/core/exec.c:            operand = lai_exec_get_opstack(state, item->opstack_frame + 2);
Kernel/subprojects/lai/core/exec.c:            int pc = block->pc;
Kernel/subprojects/lai/core/exec.c:            while (pc < block->limit) {
Kernel/subprojects/lai/core/exec.c:                        node->type = LAI_NAMESPACE_BANK_FIELD;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_region_node = region_node;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_bank_node = bank_node;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_flags = access_type;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_size = skip_bits;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_offset = curr_off;
Kernel/subprojects/lai/core/exec.c:                        node->bkf_value = bank_value;
Kernel/subprojects/lai/core/exec.c:                            lai_list_link(&invocation->per_method_list,
Kernel/subprojects/lai/core/exec.c:                                          &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:    // Note that we re-read the block pointer, as the block stack might have been reallocated.
Kernel/subprojects/lai/core/exec.c:    block->pc = pc;
Kernel/subprojects/lai/core/exec.c:    struct lai_aml_segment *amls = ctxitem->amls;
Kernel/subprojects/lai/core/exec.c:    uint8_t *method = ctxitem->code;
Kernel/subprojects/lai/core/exec.c:    lai_nsnode_t *ctx_handle = ctxitem->handle;
Kernel/subprojects/lai/core/exec.c:    struct lai_invocation *invocation = ctxitem->invocation;
Kernel/subprojects/lai/core/exec.c:    int pc = block->pc;
Kernel/subprojects/lai/core/exec.c:    int limit = block->limit;
Kernel/subprojects/lai/core/exec.c:    // Package-size encoding (and similar) needs to know the PC of the opcode.
Kernel/subprojects/lai/core/exec.c:    // This matches the offsets in the output of 'iasl -l'.
Kernel/subprojects/lai/core/exec.c:                      + (method - amls->table->data)
Kernel/subprojects/lai/core/exec.c:                      + (method - amls->table->data)
Kernel/subprojects/lai/core/exec.c:                      + block->limit;
Kernel/subprojects/lai/core/exec.c:    if (!(pc < block->limit))
Kernel/subprojects/lai/core/exec.c:        result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:        result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:        result->object.integer = value;
Kernel/subprojects/lai/core/exec.c:        result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:        result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:        result->object.integer = value;
Kernel/subprojects/lai/core/exec.c:        result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:        result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:        result->object.integer = value;
Kernel/subprojects/lai/core/exec.c:        if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:            if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                opstack_res->object.type = LAI_LAZY_HANDLE;
Kernel/subprojects/lai/core/exec.c:                opstack_res->object.unres_ctx_handle = ctx_handle;
Kernel/subprojects/lai/core/exec.c:                opstack_res->object.unres_aml = method + opcode_pc;
Kernel/subprojects/lai/core/exec.c:            if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                opstack_res->tag = LAI_UNRESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:                opstack_res->unres_ctx_handle = ctx_handle;
Kernel/subprojects/lai/core/exec.c:                opstack_res->unres_aml = method + opcode_pc;
Kernel/subprojects/lai/core/exec.c:                    if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                        lai_debug("parsing non-existant name %s [@ 0x%x]", path, table_pc);
Kernel/subprojects/lai/core/exec.c:                        opstack_res->tag = LAI_RESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:                        opstack_res->handle = NULL;
Kernel/subprojects/lai/core/exec.c:            } else if (handle->type == LAI_NAMESPACE_METHOD
Kernel/subprojects/lai/core/exec.c:                if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                node_item->kind = LAI_INVOKE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:                node_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:                node_item->ivk_argc = handle->method_flags & METHOD_ARGC_MASK;
Kernel/subprojects/lai/core/exec.c:                node_item->ivk_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:                opstack_method->tag = LAI_RESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:                opstack_method->handle = handle;
Kernel/subprojects/lai/core/exec.c:                if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                    opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:                    lai_var_move(&opstack_res->object, &result);
Kernel/subprojects/lai/core/exec.c:                if (instance->trace & LAI_TRACE_OP)
Kernel/subprojects/lai/core/exec.c:                    opstack_method->tag = LAI_RESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:                    opstack_method->handle = handle;
Kernel/subprojects/lai/core/exec.c:        if (pc + 1 == block->limit)
Kernel/subprojects/lai/core/exec.c:            lai_panic("two-byte opcode on method boundary");
Kernel/subprojects/lai/core/exec.c:    if (instance->trace & LAI_TRACE_OP) {
Kernel/subprojects/lai/core/exec.c:                amls->table->header.signature[0],
Kernel/subprojects/lai/core/exec.c:                amls->table->header.signature[1],
Kernel/subprojects/lai/core/exec.c:                amls->table->header.signature[2],
Kernel/subprojects/lai/core/exec.c:                amls->table->header.signature[3],
Kernel/subprojects/lai/core/exec.c:                amls->index);
Kernel/subprojects/lai/core/exec.c:            result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:            result->object.integer = 0;
Kernel/subprojects/lai/core/exec.c:            result->tag = LAI_NULL_NAME;
Kernel/subprojects/lai/core/exec.c:            result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:            result->object.integer = 1;
Kernel/subprojects/lai/core/exec.c:            result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:            result->object.integer = ~((uint64_t)0);
Kernel/subprojects/lai/core/exec.c:            result->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            result->object.type = LAI_INTEGER;
Kernel/subprojects/lai/core/exec.c:            result->object.integer = value;
Kernel/subprojects/lai/core/exec.c:        size_t n = 0; // Length of null-terminated string.
Kernel/subprojects/lai/core/exec.c:        while (pc + n < (size_t) block->limit && method[pc + n])
Kernel/subprojects/lai/core/exec.c:        if (pc + n == (size_t) block->limit)
Kernel/subprojects/lai/core/exec.c:            opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            if(lai_create_string(&opstack_res->object, n))
Kernel/subprojects/lai/core/exec.c:            memcpy(lai_exec_string_access(&opstack_res->object), method + data_pc, n);
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = data_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 1 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        buf_item->kind = LAI_BUFFER_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        buf_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        buf_item->buf_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = data_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 1 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        pkg_item->kind = LAI_PACKAGE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        pkg_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        pkg_item->pkg_index = 0;
Kernel/subprojects/lai/core/exec.c:        pkg_item->pkg_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        opstack_pkg->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:        if (lai_create_pkg(&opstack_pkg->object, num_ents))
Kernel/subprojects/lai/core/exec.c:        node_item->kind = LAI_RETURN_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = body_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 1 + loop_size;
Kernel/subprojects/lai/core/exec.c:        loop_item->kind = LAI_LOOP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        loop_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        loop_item->loop_state = 0;
Kernel/subprojects/lai/core/exec.c:        loop_item->loop_pred = body_pc;
Kernel/subprojects/lai/core/exec.c:            if (loop_item->kind == LAI_LOOP_STACKITEM)
Kernel/subprojects/lai/core/exec.c:            if (loop_item->kind != LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                    && loop_item->kind != LAI_LOOP_STACKITEM)
Kernel/subprojects/lai/core/exec.c:                lai_panic("Continue() cannot skip item of type %d", loop_item->kind);
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(pop_item->kind == LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                    || pop_item->kind == LAI_LOOP_STACKITEM);
Kernel/subprojects/lai/core/exec.c:        pc = loop_item->loop_pred;
Kernel/subprojects/lai/core/exec.c:            if (loop_item->kind == LAI_LOOP_STACKITEM)
Kernel/subprojects/lai/core/exec.c:            if (loop_item->kind != LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                    && loop_item->kind != LAI_LOOP_STACKITEM)
Kernel/subprojects/lai/core/exec.c:                lai_panic("Break() cannot skip item of type %d", loop_item->kind);
Kernel/subprojects/lai/core/exec.c:            LAI_ENSURE(pop_item->kind == LAI_COND_STACKITEM
Kernel/subprojects/lai/core/exec.c:                    || pop_item->kind == LAI_LOOP_STACKITEM);
Kernel/subprojects/lai/core/exec.c:        if (pc < block->limit && method[pc] == ELSE_OP) {
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = if_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 1 + if_size;
Kernel/subprojects/lai/core/exec.c:        cond_item->kind = LAI_COND_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        cond_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        cond_item->cond_state = 0;
Kernel/subprojects/lai/core/exec.c:        cond_item->cond_has_else = has_else;
Kernel/subprojects/lai/core/exec.c:        cond_item->cond_else_pc = else_pc;
Kernel/subprojects/lai/core/exec.c:        cond_item->cond_else_limit = opcode_pc + 1 + if_size + 1 + else_size;
Kernel/subprojects/lai/core/exec.c:    // Scope-like objects in the ACPI namespace.
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->code = method;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->handle = scoped_ctx_handle;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = nested_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 1 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->code = method;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->handle = node;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = nested_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 2 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_PROCESSOR;
Kernel/subprojects/lai/core/exec.c:        node->cpu_id = cpu_id;
Kernel/subprojects/lai/core/exec.c:        node->pblk_addr = pblk_addr;
Kernel/subprojects/lai/core/exec.c:        node->pblk_len = pblk_len;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->code = method;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->handle = node;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = nested_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 2 + pkgsize;
Kernel/subprojects/lai/core/exec.c:        item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_POWERRESOURCE;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->code = method;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->handle = node;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = nested_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 2 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_THERMALZONE;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->code = method;
Kernel/subprojects/lai/core/exec.c:        populate_ctxitem->handle = node;
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = nested_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = opcode_pc + 2 + encoded_size;
Kernel/subprojects/lai/core/exec.c:        item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_METHOD;
Kernel/subprojects/lai/core/exec.c:        node->method_flags = flags;
Kernel/subprojects/lai/core/exec.c:        node->amls = amls;
Kernel/subprojects/lai/core/exec.c:        node->pointer = method + nested_pc;
Kernel/subprojects/lai/core/exec.c:        node->size = pc - nested_pc;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        node_item->kind = LAI_NODE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node_item->node_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        node_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[0] = LAI_UNRESOLVED_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_ALIAS;
Kernel/subprojects/lai/core/exec.c:        node->al_target = lai_do_resolve(ctx_handle, &target_amln);
Kernel/subprojects/lai/core/exec.c:        if (!node->al_target)
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        node_item->kind = LAI_NODE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node_item->node_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        node_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[2] = LAI_UNRESOLVED_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_MUTEX;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        node->type = LAI_NAMESPACE_EVENT;
Kernel/subprojects/lai/core/exec.c:            lai_list_link(&invocation->per_method_list, &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        node_item->kind = LAI_NODE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        node_item->node_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        node_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[0] = LAI_UNRESOLVED_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[1] = LAI_IMMEDIATE_BYTE_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[2] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[3] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        node_item->node_arg_modes[4] = 0;
Kernel/subprojects/lai/core/exec.c:            lai_panic("error parsing field for non-existant OpRegion, ignoring...");
Kernel/subprojects/lai/core/exec.c:                    node->type = LAI_NAMESPACE_FIELD;
Kernel/subprojects/lai/core/exec.c:                    node->fld_region_node = region_node;
Kernel/subprojects/lai/core/exec.c:                    node->fld_flags = access_type;
Kernel/subprojects/lai/core/exec.c:                    node->fld_size = skip_bits;
Kernel/subprojects/lai/core/exec.c:                    node->fld_offset = curr_off;
Kernel/subprojects/lai/core/exec.c:                        lai_list_link(&invocation->per_method_list,
Kernel/subprojects/lai/core/exec.c:                                      &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:                    node->type = LAI_NAMESPACE_INDEXFIELD;
Kernel/subprojects/lai/core/exec.c:                    node->idxf_index_node = index_node;
Kernel/subprojects/lai/core/exec.c:                    node->idxf_data_node = data_node;
Kernel/subprojects/lai/core/exec.c:                    node->idxf_flags = access_type;
Kernel/subprojects/lai/core/exec.c:                    node->idxf_size = skip_bits;
Kernel/subprojects/lai/core/exec.c:                    node->idxf_offset = curr_off;
Kernel/subprojects/lai/core/exec.c:                        lai_list_link(&invocation->per_method_list,
Kernel/subprojects/lai/core/exec.c:                                      &node->per_method_item);
Kernel/subprojects/lai/core/exec.c:        blkitem->pc = start_pc;
Kernel/subprojects/lai/core/exec.c:        blkitem->limit = pc;
Kernel/subprojects/lai/core/exec.c:        bankfield_item->kind = LAI_BANKFIELD_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        bankfield_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        region_operand->tag = LAI_RESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:        region_operand->handle = region_node;
Kernel/subprojects/lai/core/exec.c:        bank_operand->tag = LAI_RESOLVED_NAME;
Kernel/subprojects/lai/core/exec.c:        bank_operand->handle = bank_node;
Kernel/subprojects/lai/core/exec.c:            opstack_res->tag = LAI_ARG_NAME;
Kernel/subprojects/lai/core/exec.c:            opstack_res->index = opcode - ARG0_OP;
Kernel/subprojects/lai/core/exec.c:            opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            lai_var_assign(&opstack_res->object, &invocation->arg[opcode - ARG0_OP]);
Kernel/subprojects/lai/core/exec.c:            opstack_res->tag = LAI_LOCAL_NAME;
Kernel/subprojects/lai/core/exec.c:            opstack_res->index = opcode - LOCAL0_OP;
Kernel/subprojects/lai/core/exec.c:            opstack_res->tag = LAI_OPERAND_OBJECT;
Kernel/subprojects/lai/core/exec.c:            lai_var_assign(&opstack_res->object, &invocation->local[opcode - LOCAL0_OP]);
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_IMMEDIATE_BYTE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_IMMEDIATE_DWORD_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        result->tag = LAI_DEBUG_NAME;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:		op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:		op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:		op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:		op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:		op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:		op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:		op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:		op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:		op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:		op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:		op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[2] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:		op_item->op_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:		op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[3] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[4] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[3] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OPTIONAL_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_IMMEDIATE_WORD_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:        op_item->kind = LAI_OP_STACKITEM;
Kernel/subprojects/lai/core/exec.c:        op_item->op_opcode = opcode;
Kernel/subprojects/lai/core/exec.c:        op_item->opstack_frame = state->opstack_ptr;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[0] = LAI_OBJECT_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[1] = LAI_REFERENCE_MODE;
Kernel/subprojects/lai/core/exec.c:        op_item->op_arg_modes[2] = 0;
Kernel/subprojects/lai/core/exec.c:        op_item->op_want_result = want_result;
Kernel/subprojects/lai/core/exec.c:    size_t size = amls->table->header.length - sizeof(acpi_header_t);
Kernel/subprojects/lai/core/exec.c:    populate_ctxitem->amls = amls;
Kernel/subprojects/lai/core/exec.c:    populate_ctxitem->code = amls->table->data;
Kernel/subprojects/lai/core/exec.c:    populate_ctxitem->handle = parent;
Kernel/subprojects/lai/core/exec.c:    blkitem->pc = 0;
Kernel/subprojects/lai/core/exec.c:    blkitem->limit = size;
Kernel/subprojects/lai/core/exec.c:    item->kind = LAI_POPULATE_STACKITEM;
Kernel/subprojects/lai/core/exec.c:    LAI_ENSURE(state->ctxstack_ptr == -1);
Kernel/subprojects/lai/core/exec.c:    LAI_ENSURE(state->stack_ptr == -1);
Kernel/subprojects/lai/core/exec.c:    LAI_ENSURE(!state->opstack_ptr);
Kernel/subprojects/lai/core/exec.c:    LAI_ENSURE(handle->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/exec.c:    switch (handle->type) {
Kernel/subprojects/lai/core/exec.c:                lai_warn("non-empty argument list given when evaluating Name()");
Kernel/subprojects/lai/core/exec.c:                lai_obj_clone(result, &handle->object);
Kernel/subprojects/lai/core/exec.c:            if (handle->method_override) {
Kernel/subprojects/lai/core/exec.c:                // It's an OS-defined method.
Kernel/subprojects/lai/core/exec.c:                e = handle->method_override(args, &method_result);
Kernel/subprojects/lai/core/exec.c:                LAI_ENSURE(handle->amls);
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->amls = handle->amls;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->code = handle->pointer;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->handle = handle;
Kernel/subprojects/lai/core/exec.c:                method_ctxitem->invocation = laihost_malloc(sizeof(struct lai_invocation));
Kernel/subprojects/lai/core/exec.c:                if (!method_ctxitem->invocation)
Kernel/subprojects/lai/core/exec.c:                memset(method_ctxitem->invocation, 0, sizeof(struct lai_invocation));
Kernel/subprojects/lai/core/exec.c:                lai_list_init(&method_ctxitem->invocation->per_method_list);
Kernel/subprojects/lai/core/exec.c:                    lai_var_assign(&method_ctxitem->invocation->arg[i], &args[i]);
Kernel/subprojects/lai/core/exec.c:                blkitem->pc = 0;
Kernel/subprojects/lai/core/exec.c:                blkitem->limit = handle->size;
Kernel/subprojects/lai/core/exec.c:                item->kind = LAI_METHOD_STACKITEM;
Kernel/subprojects/lai/core/exec.c:                item->mth_want_result = 1;
Kernel/subprojects/lai/core/exec.c:                    LAI_ENSURE(state->ctxstack_ptr == -1);
Kernel/subprojects/lai/core/exec.c:                    LAI_ENSURE(state->stack_ptr == -1);
Kernel/subprojects/lai/core/exec.c:                    if (state->opstack_ptr != 1) // This would be an internal error.
Kernel/subprojects/lai/core/exec.c:    lai_current_instance()->trace = trace;
Kernel/subprojects/lai/core/exec_impl.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/exec_impl.h:// Turns the AML name into a ASL-like name string.
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:    if (state->ctxstack_ptr + 1 == state->ctxstack_capacity) {
Kernel/subprojects/lai/core/exec_impl.h:        size_t new_capacity = 2 * state->ctxstack_capacity;
Kernel/subprojects/lai/core/exec_impl.h:        memcpy(new_stack, state->ctxstack_base,
Kernel/subprojects/lai/core/exec_impl.h:               (state->ctxstack_ptr + 1) * sizeof(struct lai_ctxitem));
Kernel/subprojects/lai/core/exec_impl.h:        if (state->ctxstack_base != state->small_ctxstack)
Kernel/subprojects/lai/core/exec_impl.h:            laihost_free(state->ctxstack_base);
Kernel/subprojects/lai/core/exec_impl.h:        state->ctxstack_base = new_stack;
Kernel/subprojects/lai/core/exec_impl.h:        state->ctxstack_capacity = new_capacity;
Kernel/subprojects/lai/core/exec_impl.h:    state->ctxstack_ptr++;
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->ctxstack_ptr < state->ctxstack_capacity);
Kernel/subprojects/lai/core/exec_impl.h:    memset(&state->ctxstack_base[state->ctxstack_ptr], 0, sizeof(struct lai_ctxitem));
Kernel/subprojects/lai/core/exec_impl.h:    return &state->ctxstack_base[state->ctxstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    if (state->ctxstack_ptr < 0)
Kernel/subprojects/lai/core/exec_impl.h:    return &state->ctxstack_base[state->ctxstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->ctxstack_ptr >= 0);
Kernel/subprojects/lai/core/exec_impl.h:    struct lai_ctxitem *ctxitem = &state->ctxstack_base[state->ctxstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    if (ctxitem->invocation) {
Kernel/subprojects/lai/core/exec_impl.h:            lai_var_finalize(&ctxitem->invocation->arg[i]);
Kernel/subprojects/lai/core/exec_impl.h:            lai_var_finalize(&ctxitem->invocation->local[i]);
Kernel/subprojects/lai/core/exec_impl.h:        laihost_free(ctxitem->invocation);
Kernel/subprojects/lai/core/exec_impl.h:    state->ctxstack_ptr -= 1;
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:    if (state->blkstack_ptr + 1 == state->blkstack_capacity) {
Kernel/subprojects/lai/core/exec_impl.h:        size_t new_capacity = 2 * state->blkstack_capacity;
Kernel/subprojects/lai/core/exec_impl.h:        memcpy(new_stack, state->blkstack_base,
Kernel/subprojects/lai/core/exec_impl.h:               (state->blkstack_ptr + 1) * sizeof(struct lai_blkitem));
Kernel/subprojects/lai/core/exec_impl.h:        if (state->blkstack_base != state->small_blkstack)
Kernel/subprojects/lai/core/exec_impl.h:            laihost_free(state->blkstack_base);
Kernel/subprojects/lai/core/exec_impl.h:        state->blkstack_base = new_stack;
Kernel/subprojects/lai/core/exec_impl.h:        state->blkstack_capacity = new_capacity;
Kernel/subprojects/lai/core/exec_impl.h:    state->blkstack_ptr++;
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->blkstack_ptr < state->blkstack_capacity);
Kernel/subprojects/lai/core/exec_impl.h:    memset(&state->blkstack_base[state->blkstack_ptr], 0, sizeof(struct lai_blkitem));
Kernel/subprojects/lai/core/exec_impl.h:    return &state->blkstack_base[state->blkstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    if (state->blkstack_ptr < 0)
Kernel/subprojects/lai/core/exec_impl.h:    return &state->blkstack_base[state->blkstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->blkstack_ptr >= 0);
Kernel/subprojects/lai/core/exec_impl.h:    state->blkstack_ptr -= 1;
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:    if (state->stack_ptr + 1 == state->stack_capacity) {
Kernel/subprojects/lai/core/exec_impl.h:        size_t new_capacity = 2 * state->stack_capacity;
Kernel/subprojects/lai/core/exec_impl.h:        memcpy(new_stack, state->stack_base,
Kernel/subprojects/lai/core/exec_impl.h:               (state->stack_ptr + 1) * sizeof(lai_stackitem_t));
Kernel/subprojects/lai/core/exec_impl.h:        if (state->stack_base != state->small_stack)
Kernel/subprojects/lai/core/exec_impl.h:            laihost_free(state->stack_base);
Kernel/subprojects/lai/core/exec_impl.h:        state->stack_base = new_stack;
Kernel/subprojects/lai/core/exec_impl.h:        state->stack_capacity = new_capacity;
Kernel/subprojects/lai/core/exec_impl.h:    state->stack_ptr++;
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->stack_ptr < state->stack_capacity);
Kernel/subprojects/lai/core/exec_impl.h:    return &state->stack_base[state->stack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:// Returns the n-th item from the top of the stack.
Kernel/subprojects/lai/core/exec_impl.h:    if (state->stack_ptr - n < 0)
Kernel/subprojects/lai/core/exec_impl.h:    return &state->stack_base[state->stack_ptr - n];
Kernel/subprojects/lai/core/exec_impl.h:    return &state->stack_base[n];
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->stack_ptr >= 0);
Kernel/subprojects/lai/core/exec_impl.h:    state->stack_ptr--;
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:// --------------------------------------------------------------------------------------
Kernel/subprojects/lai/core/exec_impl.h:    if (state->opstack_ptr == state->opstack_capacity) {
Kernel/subprojects/lai/core/exec_impl.h:        size_t new_capacity = 2 * state->opstack_capacity;
Kernel/subprojects/lai/core/exec_impl.h:        memcpy(new_stack, state->opstack_base,
Kernel/subprojects/lai/core/exec_impl.h:               state->opstack_ptr * sizeof(struct lai_operand));
Kernel/subprojects/lai/core/exec_impl.h:        if (state->opstack_base != state->small_opstack)
Kernel/subprojects/lai/core/exec_impl.h:            laihost_free(state->opstack_base);
Kernel/subprojects/lai/core/exec_impl.h:        state->opstack_base = new_stack;
Kernel/subprojects/lai/core/exec_impl.h:        state->opstack_capacity = new_capacity;
Kernel/subprojects/lai/core/exec_impl.h:        n--;
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(state->opstack_ptr < state->opstack_capacity);
Kernel/subprojects/lai/core/exec_impl.h:    struct lai_operand *object = &state->opstack_base[state->opstack_ptr];
Kernel/subprojects/lai/core/exec_impl.h:    state->opstack_ptr++;
Kernel/subprojects/lai/core/exec_impl.h:// Returns the n-th item from the opstack.
Kernel/subprojects/lai/core/exec_impl.h:    LAI_ENSURE(n < state->opstack_ptr);
Kernel/subprojects/lai/core/exec_impl.h:    return &state->opstack_base[n];
Kernel/subprojects/lai/core/exec_impl.h:        struct lai_operand *operand = &state->opstack_base[state->opstack_ptr - k - 1];
Kernel/subprojects/lai/core/exec_impl.h:        if (operand->tag == LAI_OPERAND_OBJECT)
Kernel/subprojects/lai/core/exec_impl.h:            lai_var_finalize(&operand->object);
Kernel/subprojects/lai/core/exec_impl.h:    state->opstack_ptr -= n;
Kernel/subprojects/lai/core/libc.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/libc.c:            return -1;
Kernel/subprojects/lai/core/libc.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/ns.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/ns.c:#include "util-hash.h"
Kernel/subprojects/lai/core/ns.c:    if (instance->trace & LAI_TRACE_NS) {
Kernel/subprojects/lai/core/ns.c:        lai_debug("lai_install_nsnode: adding node with type %d at %s", node->type, fullpath);
Kernel/subprojects/lai/core/ns.c:    if (instance->ns_size == instance->ns_capacity) {
Kernel/subprojects/lai/core/ns.c:        size_t new_capacity = instance->ns_capacity * 2;
Kernel/subprojects/lai/core/ns.c:        new_array = laihost_realloc(instance->ns_array, sizeof(lai_nsnode_t *) * new_capacity);
Kernel/subprojects/lai/core/ns.c:        instance->ns_array = new_array;
Kernel/subprojects/lai/core/ns.c:        instance->ns_capacity = new_capacity;
Kernel/subprojects/lai/core/ns.c:    instance->ns_array[instance->ns_size++] = node;
Kernel/subprojects/lai/core/ns.c:    lai_nsnode_t *parent = node->parent;
Kernel/subprojects/lai/core/ns.c:        int h = lai_hash_string(node->name, 4);
Kernel/subprojects/lai/core/ns.c:        while (!lai_hashtable_chain_advance(&parent->children, h, &chain)) {
Kernel/subprojects/lai/core/ns.c:            lai_nsnode_t *child = lai_hashtable_chain_get(&parent->children, h, &chain);
Kernel/subprojects/lai/core/ns.c:            if (!memcmp(child->name, node->name, 4)) {
Kernel/subprojects/lai/core/ns.c:        lai_hashtable_insert(&parent->children, h, node);
Kernel/subprojects/lai/core/ns.c:    for (size_t i = 0; i < instance->ns_size; i++) {
Kernel/subprojects/lai/core/ns.c:        if (instance->ns_array[i] == node)
Kernel/subprojects/lai/core/ns.c:            instance->ns_array[i] = NULL;
Kernel/subprojects/lai/core/ns.c:    lai_nsnode_t *parent = node->parent;
Kernel/subprojects/lai/core/ns.c:        int h = lai_hash_string(node->name, 4);
Kernel/subprojects/lai/core/ns.c:            if (lai_hashtable_chain_advance(&parent->children, h, &chain))
Kernel/subprojects/lai/core/ns.c:            lai_nsnode_t *child = lai_hashtable_chain_get(&parent->children, h, &chain);
Kernel/subprojects/lai/core/ns.c:            lai_hashtable_chain_remove(&parent->children, h, &chain);
Kernel/subprojects/lai/core/ns.c:        // As a sanity-check: make sure that the child does not occur twice.
Kernel/subprojects/lai/core/ns.c:        while (!lai_hashtable_chain_advance(&parent->children, h, &chain)) {
Kernel/subprojects/lai/core/ns.c:            lai_nsnode_t *child = lai_hashtable_chain_get(&parent->children, h, &chain);
Kernel/subprojects/lai/core/ns.c:    return lai_current_instance()->root_node;
Kernel/subprojects/lai/core/ns.c:    return node->parent;
Kernel/subprojects/lai/core/ns.c:    while (!lai_hashtable_chain_advance(&parent->children, h, &chain)) {
Kernel/subprojects/lai/core/ns.c:        lai_nsnode_t *child = lai_hashtable_chain_get(&parent->children, h, &chain);
Kernel/subprojects/lai/core/ns.c:        if (!memcmp(child->name, name, 4))
Kernel/subprojects/lai/core/ns.c:    amln->is_absolute = 0;
Kernel/subprojects/lai/core/ns.c:    amln->height = 0;
Kernel/subprojects/lai/core/ns.c:        amln->is_absolute = 1;
Kernel/subprojects/lai/core/ns.c:        // Non-absolute paths can be prefixed by a number of ^.
Kernel/subprojects/lai/core/ns.c:            amln->height++;
Kernel/subprojects/lai/core/ns.c:    amln->search_scopes = !amln->is_absolute && !amln->height && num_segs == 1;
Kernel/subprojects/lai/core/ns.c:    amln->it = it;
Kernel/subprojects/lai/core/ns.c:    amln->end = it + 4 * num_segs;
Kernel/subprojects/lai/core/ns.c:    return amln->end - begin;
Kernel/subprojects/lai/core/ns.c:    return amln->it == amln->end;
Kernel/subprojects/lai/core/ns.c:    LAI_ENSURE(amln->it < amln->end);
Kernel/subprojects/lai/core/ns.c:        out[i] = amln->it[i];
Kernel/subprojects/lai/core/ns.c:    amln->it += 4;
Kernel/subprojects/lai/core/ns.c:    size_t num_segs = (amln.end - amln.it) / 4;
Kernel/subprojects/lai/core/ns.c:                        + 1;          // Null-terminator.
Kernel/subprojects/lai/core/ns.c:    if (!node->parent) {
Kernel/subprojects/lai/core/ns.c:        LAI_ENSURE(node->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:    for (current = node; current->parent; current = current->parent)
Kernel/subprojects/lai/core/ns.c:    for (current = node; current->parent; current = current->parent) {
Kernel/subprojects/lai/core/ns.c:        n -= 4;
Kernel/subprojects/lai/core/ns.c:        lai_namecpy(str + n, current->name);
Kernel/subprojects/lai/core/ns.c:        n -= 1;
Kernel/subprojects/lai/core/ns.c:    LAI_ENSURE(current->type != LAI_NAMESPACE_ALIAS); // ctx_handle needs to be resolved.
Kernel/subprojects/lai/core/ns.c:                current = current->parent;
Kernel/subprojects/lai/core/ns.c:            if (node->type == LAI_NAMESPACE_ALIAS) {
Kernel/subprojects/lai/core/ns.c:                node = node->al_target;
Kernel/subprojects/lai/core/ns.c:                LAI_ENSURE(node->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/ns.c:            while (current->parent)
Kernel/subprojects/lai/core/ns.c:                current = current->parent;
Kernel/subprojects/lai/core/ns.c:            LAI_ENSURE(current->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:            if (!current->parent) {
Kernel/subprojects/lai/core/ns.c:                LAI_ENSURE(current->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:            current = current->parent;
Kernel/subprojects/lai/core/ns.c:        if (current->type == LAI_NAMESPACE_ALIAS) {
Kernel/subprojects/lai/core/ns.c:            current = current->al_target;
Kernel/subprojects/lai/core/ns.c:            LAI_ENSURE(current->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/ns.c:    LAI_ENSURE(parent->type != LAI_NAMESPACE_ALIAS); // ctx_handle needs to be resolved.
Kernel/subprojects/lai/core/ns.c:    // Note: we do not care about amln->search_scopes here.
Kernel/subprojects/lai/core/ns.c:        while (parent->parent)
Kernel/subprojects/lai/core/ns.c:            parent = parent->parent;
Kernel/subprojects/lai/core/ns.c:        LAI_ENSURE(parent->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:        if (!parent->parent) {
Kernel/subprojects/lai/core/ns.c:            LAI_ENSURE(parent->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:        parent = parent->parent;
Kernel/subprojects/lai/core/ns.c:            lai_namecpy(node->name, segment);
Kernel/subprojects/lai/core/ns.c:            node->parent = parent;
Kernel/subprojects/lai/core/ns.c:            if (parent->type == LAI_NAMESPACE_ALIAS) {
Kernel/subprojects/lai/core/ns.c:                parent = parent->al_target;
Kernel/subprojects/lai/core/ns.c:                LAI_ENSURE(parent->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/ns.c:    instance->root_node = lai_create_nsnode_or_die();
Kernel/subprojects/lai/core/ns.c:    instance->root_node->type = LAI_NAMESPACE_ROOT;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(instance->root_node->name, "\\___");
Kernel/subprojects/lai/core/ns.c:    instance->root_node->parent = NULL;
Kernel/subprojects/lai/core/ns.c:    sb_node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(sb_node->name, "_SB_");
Kernel/subprojects/lai/core/ns.c:    sb_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    si_node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(si_node->name, "_SI_");
Kernel/subprojects/lai/core/ns.c:    si_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    gpe_node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(gpe_node->name, "_GPE");
Kernel/subprojects/lai/core/ns.c:    gpe_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    pr_node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(pr_node->name, "_PR_");
Kernel/subprojects/lai/core/ns.c:    pr_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    tz_node->type = LAI_NAMESPACE_DEVICE;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(tz_node->name, "_TZ_");
Kernel/subprojects/lai/core/ns.c:    tz_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    // Create the OS-defined objects.
Kernel/subprojects/lai/core/ns.c:    osi_node->type = LAI_NAMESPACE_METHOD;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(osi_node->name, "_OSI");
Kernel/subprojects/lai/core/ns.c:    osi_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    osi_node->method_flags = 0x01;
Kernel/subprojects/lai/core/ns.c:    osi_node->method_override = &lai_do_osi_method;
Kernel/subprojects/lai/core/ns.c:    os_node->type = LAI_NAMESPACE_METHOD;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(os_node->name, "_OS_");
Kernel/subprojects/lai/core/ns.c:    os_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    os_node->method_flags = 0x00;
Kernel/subprojects/lai/core/ns.c:    os_node->method_override = &lai_do_os_method;
Kernel/subprojects/lai/core/ns.c:    rev_node->type = LAI_NAMESPACE_METHOD;
Kernel/subprojects/lai/core/ns.c:    lai_namecpy(rev_node->name, "_REV");
Kernel/subprojects/lai/core/ns.c:    rev_node->parent = instance->root_node;
Kernel/subprojects/lai/core/ns.c:    rev_node->method_flags = 0x00;
Kernel/subprojects/lai/core/ns.c:    rev_node->method_override = &lai_do_rev_method;
Kernel/subprojects/lai/core/ns.c:    return instance->root_node;
Kernel/subprojects/lai/core/ns.c:// Creates the ACPI namespace. Requires the ability to scan for ACPI tables - ensure this is
Kernel/subprojects/lai/core/ns.c:    instance->fadt = laihost_scan("FACP", 0);
Kernel/subprojects/lai/core/ns.c:    if (!instance->fadt) {
Kernel/subprojects/lai/core/ns.c:    lai_debug("ACPI namespace created, total of %d predefined objects.", instance->ns_size);
Kernel/subprojects/lai/core/ns.c:    amls->table = ptr;
Kernel/subprojects/lai/core/ns.c:    amls->index = index;
Kernel/subprojects/lai/core/ns.c:            amls->table->header.signature[0],
Kernel/subprojects/lai/core/ns.c:            amls->table->header.signature[1],
Kernel/subprojects/lai/core/ns.c:            amls->table->header.signature[2],
Kernel/subprojects/lai/core/ns.c:            amls->table->header.signature[3],
Kernel/subprojects/lai/core/ns.c:            amls->table->header.length);
Kernel/subprojects/lai/core/ns.c:        current = lai_current_instance()->root_node;
Kernel/subprojects/lai/core/ns.c:        while (current->parent)
Kernel/subprojects/lai/core/ns.c:            current = current->parent;
Kernel/subprojects/lai/core/ns.c:        LAI_ENSURE(current->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:            if (!current->parent) {
Kernel/subprojects/lai/core/ns.c:                LAI_ENSURE(current->type == LAI_NAMESPACE_ROOT);
Kernel/subprojects/lai/core/ns.c:            current = current->parent;
Kernel/subprojects/lai/core/ns.c:        if (current->type == LAI_NAMESPACE_ALIAS) {
Kernel/subprojects/lai/core/ns.c:            current = current->al_target;
Kernel/subprojects/lai/core/ns.c:            LAI_ENSURE(current->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/ns.c:    LAI_ENSURE(current->type != LAI_NAMESPACE_ALIAS); // ctx_handle needs to be resolved.
Kernel/subprojects/lai/core/ns.c:            current = current->parent;
Kernel/subprojects/lai/core/ns.c:        if (node->type == LAI_NAMESPACE_ALIAS) {
Kernel/subprojects/lai/core/ns.c:            node = node->al_target;
Kernel/subprojects/lai/core/ns.c:            LAI_ENSURE(node->type != LAI_NAMESPACE_ALIAS);
Kernel/subprojects/lai/core/ns.c:    if (id.type == LAI_INTEGER && pnp_id->type == LAI_INTEGER) {
Kernel/subprojects/lai/core/ns.c:        if (id.integer == pnp_id->integer) {
Kernel/subprojects/lai/core/ns.c:    } else if (id.type == LAI_STRING && pnp_id->type == LAI_STRING) {
Kernel/subprojects/lai/core/ns.c:    while (iter->i < instance->ns_size) {
Kernel/subprojects/lai/core/ns.c:        lai_nsnode_t *n = instance->ns_array[iter->i++];
Kernel/subprojects/lai/core/ns.c:    while (iter->i < (size_t) iter->parent->children.elem_capacity) {
Kernel/subprojects/lai/core/ns.c:        lai_nsnode_t *n = iter->parent->children.elem_ptr_tab[iter->i++];
Kernel/subprojects/lai/core/ns.c:    if(node->type != LAI_NAMESPACE_OPREGION){
Kernel/subprojects/lai/core/ns.c:        lai_warn("Tried to override opregion functions for non-opregion");
Kernel/subprojects/lai/core/ns.c:    node->op_override = override;
Kernel/subprojects/lai/core/ns.c:    node->op_userptr = userptr;
Kernel/subprojects/lai/core/ns.c:    switch (node->type){
Kernel/subprojects/lai/core/ns.c:    lai_current_instance()->acpi_revision = (revision == 0) ? (1) : (revision); // For some reason ACPI 1 is encoded as 0 and the rest just normally
Kernel/subprojects/lai/core/ns.c:    LAI_ENSURE(node->type == LAI_NAMESPACE_OPREGION);
Kernel/subprojects/lai/core/ns.c:    return node->op_address_space;
Kernel/subprojects/lai/core/ns_impl.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/object.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/object.c:    object->type = LAI_STRING;
Kernel/subprojects/lai/core/object.c:    object->string_ptr = laihost_malloc(sizeof(struct lai_string_head));
Kernel/subprojects/lai/core/object.c:    if (!object->string_ptr)
Kernel/subprojects/lai/core/object.c:    object->string_ptr->rc = 1;
Kernel/subprojects/lai/core/object.c:    object->string_ptr->content = laihost_malloc(length + 1);
Kernel/subprojects/lai/core/object.c:    if (!object->string_ptr->content) {
Kernel/subprojects/lai/core/object.c:        laihost_free(object->string_ptr);
Kernel/subprojects/lai/core/object.c:    memset(object->string_ptr->content, 0, length + 1);
Kernel/subprojects/lai/core/object.c:    object->type = LAI_BUFFER;
Kernel/subprojects/lai/core/object.c:    object->buffer_ptr = laihost_malloc(sizeof(struct lai_buffer_head));
Kernel/subprojects/lai/core/object.c:    if (!object->buffer_ptr)
Kernel/subprojects/lai/core/object.c:    object->buffer_ptr->rc = 1;
Kernel/subprojects/lai/core/object.c:    object->buffer_ptr->size = size;
Kernel/subprojects/lai/core/object.c:    object->buffer_ptr->content = laihost_malloc(size);
Kernel/subprojects/lai/core/object.c:    if (!object->buffer_ptr->content) {
Kernel/subprojects/lai/core/object.c:        laihost_free(object->buffer_ptr);
Kernel/subprojects/lai/core/object.c:    memset(object->buffer_ptr->content, 0, size);
Kernel/subprojects/lai/core/object.c:    object->type = LAI_PACKAGE;
Kernel/subprojects/lai/core/object.c:    object->pkg_ptr = laihost_malloc(sizeof(struct lai_pkg_head));
Kernel/subprojects/lai/core/object.c:    if (!object->pkg_ptr)
Kernel/subprojects/lai/core/object.c:    object->pkg_ptr->rc = 1;
Kernel/subprojects/lai/core/object.c:    object->pkg_ptr->size = n;
Kernel/subprojects/lai/core/object.c:    object->pkg_ptr->elems = laihost_malloc(n * sizeof(lai_variable_t));
Kernel/subprojects/lai/core/object.c:    if (!object->pkg_ptr->elems) {
Kernel/subprojects/lai/core/object.c:        laihost_free(object->pkg_ptr);
Kernel/subprojects/lai/core/object.c:    memset(object->pkg_ptr->elems, 0, n * sizeof(lai_variable_t));
Kernel/subprojects/lai/core/object.c:    if (object->type != LAI_STRING)
Kernel/subprojects/lai/core/object.c:    if (length > lai_strlen(object->string_ptr->content)) {
Kernel/subprojects/lai/core/object.c:        lai_strcpy(new_content, object->string_ptr->content);
Kernel/subprojects/lai/core/object.c:        laihost_free(object->string_ptr->content);
Kernel/subprojects/lai/core/object.c:        object->string_ptr->content = new_content;
Kernel/subprojects/lai/core/object.c:    if (object->type != LAI_BUFFER)
Kernel/subprojects/lai/core/object.c:    if (size > object->buffer_ptr->size) {
Kernel/subprojects/lai/core/object.c:        memcpy(new_content, object->buffer_ptr->content, object->buffer_ptr->size);
Kernel/subprojects/lai/core/object.c:        laihost_free(object->buffer_ptr->content);
Kernel/subprojects/lai/core/object.c:        object->buffer_ptr->content = new_content;
Kernel/subprojects/lai/core/object.c:    object->buffer_ptr->size = size;
Kernel/subprojects/lai/core/object.c:    if (object->type != LAI_PACKAGE)
Kernel/subprojects/lai/core/object.c:    if (n <= object->pkg_ptr->size) {
Kernel/subprojects/lai/core/object.c:        for (unsigned int i = n; i < object->pkg_ptr->size; i++)
Kernel/subprojects/lai/core/object.c:            lai_var_finalize(&object->pkg_ptr->elems[i]);
Kernel/subprojects/lai/core/object.c:        for (unsigned int i = 0; i < object->pkg_ptr->size; i++)
Kernel/subprojects/lai/core/object.c:            lai_var_move(&new_elems[i], &object->pkg_ptr->elems[i]);
Kernel/subprojects/lai/core/object.c:        laihost_free(object->pkg_ptr->elems);
Kernel/subprojects/lai/core/object.c:        object->pkg_ptr->elems = new_elems;
Kernel/subprojects/lai/core/object.c:    object->pkg_ptr->size = n;
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            lai_panic("unexpected object type %d in lai_object_type_of_objref()", object->type);
Kernel/subprojects/lai/core/object.c:    switch (handle->type) {
Kernel/subprojects/lai/core/object.c:            lai_panic("unexpected node type %d in lai_object_type_of_node()", handle->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            return lai_object_type_of_node(object->handle);
Kernel/subprojects/lai/core/object.c:            lai_amlname_parse(&amln, object->unres_aml);
Kernel/subprojects/lai/core/object.c:            lai_nsnode_t *handle = lai_do_resolve(object->unres_ctx_handle, &amln);
Kernel/subprojects/lai/core/object.c:            lai_panic("unexpected object type %d for lai_obj_get_type()", object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            *out = object->integer;
Kernel/subprojects/lai/core/object.c:                      object->type);
Kernel/subprojects/lai/core/object.c:    if (object->type != LAI_PACKAGE)
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            *out = object->handle;
Kernel/subprojects/lai/core/object.c:            lai_amlname_parse(&amln, object->unres_aml);
Kernel/subprojects/lai/core/object.c:            lai_nsnode_t *handle = lai_do_resolve(object->unres_ctx_handle, &amln);
Kernel/subprojects/lai/core/object.c:                      object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type)
Kernel/subprojects/lai/core/object.c:        memcpy(out->buffer_ptr->content, &object->integer, sizeof(uint64_t));
Kernel/subprojects/lai/core/object.c:            memcpy(out->buffer_ptr->content, object->string_ptr->content, len);
Kernel/subprojects/lai/core/object.c:                   object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            // TODO: This assumes that 64-bit integers are used.
Kernel/subprojects/lai/core/object.c:            uint64_t data = object->integer;
Kernel/subprojects/lai/core/object.c:                       object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type)
Kernel/subprojects/lai/core/object.c:                   object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type)
Kernel/subprojects/lai/core/object.c:        string[string_index - 1] = '\0';
Kernel/subprojects/lai/core/object.c:                   object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type)
Kernel/subprojects/lai/core/object.c:        string[string_index - 1] = '\0';
Kernel/subprojects/lai/core/object.c:                   object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            // Need space for 16 hex digits + one null-terminator.
Kernel/subprojects/lai/core/object.c:            lai_snprintf(s, 17, "%016lX", object->integer);
Kernel/subprojects/lai/core/object.c:            // Need space for '0x12 ' + one null-terminator.
Kernel/subprojects/lai/core/object.c:                       object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type)
Kernel/subprojects/lai/core/object.c:        out->type = LAI_INTEGER;
Kernel/subprojects/lai/core/object.c:        out->integer = *buffer;
Kernel/subprojects/lai/core/object.c:            out->integer = bswap64(out->integer);
Kernel/subprojects/lai/core/object.c:                    v = string[i] - '0';
Kernel/subprojects/lai/core/object.c:                    v = string[i] - 'a' + 10;
Kernel/subprojects/lai/core/object.c:                    v = string[i] - 'A' + 10;
Kernel/subprojects/lai/core/object.c:                integer = integer * 10 + (string[i] - '0');
Kernel/subprojects/lai/core/object.c:        out->type = LAI_INTEGER;
Kernel/subprojects/lai/core/object.c:        out->integer = integer;
Kernel/subprojects/lai/core/object.c:                   object->type);
Kernel/subprojects/lai/core/object.c:		lai_debug("%d", object->type);
Kernel/subprojects/lai/core/object.c:		switch(object->type) {
Kernel/subprojects/lai/core/object.c:						object->type);
Kernel/subprojects/lai/core/object.c:    switch (object->type) {
Kernel/subprojects/lai/core/object.c:            LAI_ENSURE(target->type == LAI_INTEGER);
Kernel/subprojects/lai/core/object.c:            target->integer = 0;
Kernel/subprojects/lai/core/object.c:                    target->integer <<= 4;
Kernel/subprojects/lai/core/object.c:                    target->integer |= s[i] - '0';
Kernel/subprojects/lai/core/object.c:                    target->integer <<= 4;
Kernel/subprojects/lai/core/object.c:                    target->integer |= (s[i] - 'a') + 10;
Kernel/subprojects/lai/core/object.c:                    target->integer <<= 4;
Kernel/subprojects/lai/core/object.c:                    target->integer |= (s[i] - 'A') + 10;
Kernel/subprojects/lai/core/object.c:            LAI_ENSURE(target->type == LAI_INTEGER);
Kernel/subprojects/lai/core/object.c:            target->integer = 0;
Kernel/subprojects/lai/core/object.c:            // TODO: This assumes that 64-bit integers are used.
Kernel/subprojects/lai/core/object.c:            memcpy(&target->integer, lai_exec_buffer_access(object), copy_size);
Kernel/subprojects/lai/core/object.c:                       object->type);
Kernel/subprojects/lai/core/object.c:    size_t n = src->pkg_ptr->size;
Kernel/subprojects/lai/core/object.c:        lai_obj_clone(&dest->pkg_ptr->elems[i], &src->pkg_ptr->elems[i]);
Kernel/subprojects/lai/core/object.c:    switch (source->type) {
Kernel/subprojects/lai/core/object.c:        // Afterwards, swap to the destination. This handles copy-to-self correctly.
Kernel/subprojects/lai/core/object.c:    switch (var->type) {
Kernel/subprojects/lai/core/object.c:    switch (node->type)
Kernel/subprojects/lai/core/object.c:            return lai_objecttype_obj(&node->object);
Kernel/subprojects/lai/core/opregion.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/opregion.c:        size_t access_size = LAI_MIN(num_bits - progress, 8 - in_byte_offset);
Kernel/subprojects/lai/core/opregion.c:        size_t mask = (1 << access_size) - 1;
Kernel/subprojects/lai/core/opregion.c:        size_t access_size = LAI_MIN(num_bits - progress, 8 - in_byte_offset);
Kernel/subprojects/lai/core/opregion.c:        size_t mask = (1 << access_size) - 1;
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *opregion = field->fld_region_node;
Kernel/subprojects/lai/core/opregion.c:    switch (field->fld_flags & 0xF) {
Kernel/subprojects/lai/core/opregion.c:            access_size = 1 << (32 - __builtin_clz(field->fld_size - 1));
Kernel/subprojects/lai/core/opregion.c:            if (opregion->op_address_space == ACPI_OPREGION_MEMORY)
Kernel/subprojects/lai/core/opregion.c:    if(opregion->op_override) {
Kernel/subprojects/lai/core/opregion.c:        if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:            lai_debug("lai_perform_read: %lu-bit read from overridden opregion at %lx (address space %02u)",
Kernel/subprojects/lai/core/opregion.c:                    access_size, opregion->op_base + offset, opregion->op_address_space);
Kernel/subprojects/lai/core/opregion.c:            case 8: value = opregion->op_override->readb(opregion->op_base + offset, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 16: value = opregion->op_override->readw(opregion->op_base + offset, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 32: value = opregion->op_override->readd(opregion->op_base + offset, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 64: value = opregion->op_override->readq(opregion->op_base + offset, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:        switch(opregion->op_address_space) {
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_read: %lu-bit read from MMIO at %lx", access_size, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                void *mmio = laihost_map(opregion->op_base + offset, access_size / 8);
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_read: %lu-bit read from I/O port at %lx", access_size, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                    case 8: value = laihost_inb(opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:                    case 16: value = laihost_inw(opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:                    case 32: value = laihost_ind(opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_read: %lu-bit read from PCI config of %04lx:%02lx:%02x.%02x at %lx", 
Kernel/subprojects/lai/core/opregion.c:                            access_size, seg, bbn, slot, fun, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                    case 8: value = laihost_pci_readb(seg, bbn, slot, fun, opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:                    case 16: value = laihost_pci_readw(seg, bbn, slot, fun, opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:                    case 32: value = laihost_pci_readd(seg, bbn, slot, fun, opregion->op_base + offset); break;
Kernel/subprojects/lai/core/opregion.c:    if(opregion->op_override) {
Kernel/subprojects/lai/core/opregion.c:        if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:            lai_debug("lai_perform_write: %lu-bit write of %lx to overridden opregion at %lx (address space %02u)",
Kernel/subprojects/lai/core/opregion.c:                    access_size, opregion->op_base + offset, value, opregion->op_address_space);
Kernel/subprojects/lai/core/opregion.c:            case 8: opregion->op_override->writeb(opregion->op_base + offset, value, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 16: opregion->op_override->writew(opregion->op_base + offset, value, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 32: opregion->op_override->writed(opregion->op_base + offset, value, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:            case 64: opregion->op_override->writeq(opregion->op_base + offset, value, opregion->op_userptr); break;
Kernel/subprojects/lai/core/opregion.c:        switch(opregion->op_address_space) {
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_write: %lu-bit write of %lx to MMIO at %lx", access_size, value, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                void *mmio = laihost_map(opregion->op_base + offset, access_size / 8);
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_write: %lu-bit write of %lx to I/O port at %lx", access_size, value, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                    case 8: laihost_outb(opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:                    case 16: laihost_outw(opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:                    case 32: laihost_outd(opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:                if (instance->trace & LAI_TRACE_IO)
Kernel/subprojects/lai/core/opregion.c:                    lai_debug("lai_perform_write: %lu-bit write of %lx to PCI config of %04lx:%02lx:%02x.%02x at %lx", 
Kernel/subprojects/lai/core/opregion.c:                            access_size, value, seg, bbn, slot, fun, opregion->op_base + offset);
Kernel/subprojects/lai/core/opregion.c:                    case 8: laihost_pci_writeb(seg, bbn, slot, fun, opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:                    case 16: laihost_pci_writew(seg, bbn, slot, fun, opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:                    case 32: laihost_pci_writed(seg, bbn, slot, fun, opregion->op_base + offset, value); break;
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *opregion = field->fld_region_node;
Kernel/subprojects/lai/core/opregion.c:    uint64_t offset = (field->fld_offset & ~(access_size - 1)) / 8;
Kernel/subprojects/lai/core/opregion.c:    if (opregion->op_address_space == ACPI_OPREGION_PCI)
Kernel/subprojects/lai/core/opregion.c:    while (progress < field->fld_size) {
Kernel/subprojects/lai/core/opregion.c:        uint64_t bit_offset = (field->fld_offset + progress) & (access_size - 1);
Kernel/subprojects/lai/core/opregion.c:        size_t access_bits = LAI_MIN(field->fld_size - progress, access_size - bit_offset);
Kernel/subprojects/lai/core/opregion.c:        uint64_t mask = (UINT64_C(1) << access_bits) - 1ull;
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *opregion = field->fld_region_node;
Kernel/subprojects/lai/core/opregion.c:    uint64_t offset = (field->fld_offset & ~(access_size - 1)) / 8;
Kernel/subprojects/lai/core/opregion.c:    if (opregion->op_address_space == ACPI_OPREGION_PCI)
Kernel/subprojects/lai/core/opregion.c:    while (progress < field->fld_size) {
Kernel/subprojects/lai/core/opregion.c:        uint64_t bit_offset = (field->fld_offset + progress) & (access_size - 1);
Kernel/subprojects/lai/core/opregion.c:        size_t access_bits = LAI_MIN(field->fld_size - progress, access_size - bit_offset);
Kernel/subprojects/lai/core/opregion.c:        size_t mask = ((UINT64_C(1) << access_bits) - 1) << bit_offset;
Kernel/subprojects/lai/core/opregion.c:        size_t write_flag = (field->fld_flags >> 5) & 0x0F;
Kernel/subprojects/lai/core/opregion.c:    uint64_t bytes = (field->fld_size + 7) / 8;
Kernel/subprojects/lai/core/opregion.c:        lai_read_field_internal(var.buffer_ptr->content, field);
Kernel/subprojects/lai/core/opregion.c:    if (source->type == LAI_BUFFER) {
Kernel/subprojects/lai/core/opregion.c:        lai_write_field_internal(source->buffer_ptr->content, field);
Kernel/subprojects/lai/core/opregion.c:    } else if (source->type == LAI_INTEGER){
Kernel/subprojects/lai/core/opregion.c:            buf[i] = (source->integer >> (i * 8)) & 0xFF;
Kernel/subprojects/lai/core/opregion.c:        lai_panic("Invalid variable type %u in lai_write_field", source->type);
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *index_field = idxf->idxf_index_node;
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *data_field = idxf->idxf_data_node;
Kernel/subprojects/lai/core/opregion.c:    index.integer = idxf->idxf_offset / 8; // Always byte-aligned.
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *index_field = idxf->idxf_index_node;
Kernel/subprojects/lai/core/opregion.c:    lai_nsnode_t *data_field = idxf->idxf_data_node;
Kernel/subprojects/lai/core/opregion.c:    index.integer = idxf->idxf_offset / 8; // Always byte-aligned.
Kernel/subprojects/lai/core/opregion.c:    if (field->type == LAI_NAMESPACE_FIELD)
Kernel/subprojects/lai/core/opregion.c:    else if (field->type == LAI_NAMESPACE_INDEXFIELD)
Kernel/subprojects/lai/core/opregion.c:    if (field->type == LAI_NAMESPACE_FIELD)
Kernel/subprojects/lai/core/opregion.c:    else if (field->type == LAI_NAMESPACE_INDEXFIELD)
Kernel/subprojects/lai/core/opregion.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/os_methods.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/os_methods.c:    result->type = LAI_INTEGER;
Kernel/subprojects/lai/core/os_methods.c:    result->integer = osi_return;
Kernel/subprojects/lai/core/os_methods.c:    result->type = LAI_INTEGER;
Kernel/subprojects/lai/core/os_methods.c:    result->integer = lai_implemented_version;
Kernel/subprojects/lai/core/os_methods.c:    lai_debug("_REV returned %d", result->integer);
Kernel/subprojects/lai/core/util-hash.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/util-hash.h:// Note that struct lai_hashtable is defined in <lai/internal-util.h>.
Kernel/subprojects/lai/core/util-hash.h:#include <lai/internal-util.h>
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(n >= ht->elem_capacity);
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(m >= ht->bucket_capacity);
Kernel/subprojects/lai/core/util-hash.h:        new_bucket_tab[i] = -1;
Kernel/subprojects/lai/core/util-hash.h:    for (int k = 0; k < ht->elem_capacity; k++) {
Kernel/subprojects/lai/core/util-hash.h:        if (!ht->elem_ptr_tab[k])
Kernel/subprojects/lai/core/util-hash.h:        new_elem_ptr_tab[k] = ht->elem_ptr_tab[k];
Kernel/subprojects/lai/core/util-hash.h:        new_elem_hash_tab[k] = ht->elem_hash_tab[k];
Kernel/subprojects/lai/core/util-hash.h:            int b = (ht->elem_hash_tab[k] + i) & (m - 1);
Kernel/subprojects/lai/core/util-hash.h:    if (ht->elem_capacity) {
Kernel/subprojects/lai/core/util-hash.h:        laihost_free(ht->elem_ptr_tab);
Kernel/subprojects/lai/core/util-hash.h:        laihost_free(ht->elem_hash_tab);
Kernel/subprojects/lai/core/util-hash.h:    if (ht->bucket_capacity)
Kernel/subprojects/lai/core/util-hash.h:        laihost_free(ht->bucket_tab);
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_ptr_tab = new_elem_ptr_tab;
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_hash_tab = new_elem_hash_tab;
Kernel/subprojects/lai/core/util-hash.h:    ht->bucket_tab = new_bucket_tab;
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_capacity = n;
Kernel/subprojects/lai/core/util-hash.h:    ht->bucket_capacity = m;
Kernel/subprojects/lai/core/util-hash.h:    if (!ht->elem_capacity || !ht->bucket_capacity) {
Kernel/subprojects/lai/core/util-hash.h:    } else if (ht->num_elems + 1 >= ht->elem_capacity) {
Kernel/subprojects/lai/core/util-hash.h:        int n = 2 * ht->elem_capacity;
Kernel/subprojects/lai/core/util-hash.h:        int m = 2 * ht->bucket_capacity;
Kernel/subprojects/lai/core/util-hash.h:    for (k = 0; k < ht->elem_capacity; k++)
Kernel/subprojects/lai/core/util-hash.h:        if (!ht->elem_ptr_tab[k])
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(k < ht->elem_capacity);
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_ptr_tab[k] = elem;
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_hash_tab[k] = h;
Kernel/subprojects/lai/core/util-hash.h:    ht->num_elems++;
Kernel/subprojects/lai/core/util-hash.h:        LAI_ENSURE(i < ht->bucket_capacity);
Kernel/subprojects/lai/core/util-hash.h:        int b = (h + i) & (ht->bucket_capacity - 1);
Kernel/subprojects/lai/core/util-hash.h:        if (ht->bucket_tab[b] < 0) {
Kernel/subprojects/lai/core/util-hash.h:            ht->bucket_tab[b] = k;
Kernel/subprojects/lai/core/util-hash.h:#define LAI_HASHTABLE_CHAIN_INITIALIZER {.i = -1}
Kernel/subprojects/lai/core/util-hash.h:// TODO: When searching for a non-existing hash, we alreadys walk through the entire table.
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(chain->i < ht->bucket_capacity);
Kernel/subprojects/lai/core/util-hash.h:        chain->i++;
Kernel/subprojects/lai/core/util-hash.h:        LAI_ENSURE(chain->i >= 0);
Kernel/subprojects/lai/core/util-hash.h:        if(chain->i == ht->bucket_capacity)
Kernel/subprojects/lai/core/util-hash.h:        int b = (h + chain->i) & (ht->bucket_capacity - 1);
Kernel/subprojects/lai/core/util-hash.h:        int k = ht->bucket_tab[b];
Kernel/subprojects/lai/core/util-hash.h:        if (k >= 0 && ht->elem_hash_tab[k] == h)
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(chain->i >= 0);
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(chain->i < ht->bucket_capacity);
Kernel/subprojects/lai/core/util-hash.h:    int b = (h + chain->i) & (ht->bucket_capacity - 1);
Kernel/subprojects/lai/core/util-hash.h:    int k = ht->bucket_tab[b];
Kernel/subprojects/lai/core/util-hash.h:    void *elem = ht->elem_ptr_tab[k];
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(chain->i >= 0);
Kernel/subprojects/lai/core/util-hash.h:    LAI_ENSURE(chain->i < ht->bucket_capacity);
Kernel/subprojects/lai/core/util-hash.h:    int b = (h + chain->i) & (ht->bucket_capacity - 1);
Kernel/subprojects/lai/core/util-hash.h:    int k = ht->bucket_tab[b];
Kernel/subprojects/lai/core/util-hash.h:    ht->elem_ptr_tab[k] = NULL;
Kernel/subprojects/lai/core/util-hash.h:    ht->bucket_tab[b] = -1;
Kernel/subprojects/lai/core/util-hash.h:    ht->num_elems--;
Kernel/subprojects/lai/core/util-list.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/util-list.h:// Note that struct lai_list and struct lai_list_item is defined in <lai/internal-util.h>.
Kernel/subprojects/lai/core/util-list.h:#include <lai/internal-util.h>
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *hook = &list->hook;
Kernel/subprojects/lai/core/util-list.h:    hook->next = hook;
Kernel/subprojects/lai/core/util-list.h:    hook->prev = hook;
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *hook = &list->hook;
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *tail = hook->prev;
Kernel/subprojects/lai/core/util-list.h:    item->next = hook;
Kernel/subprojects/lai/core/util-list.h:    item->prev = tail;
Kernel/subprojects/lai/core/util-list.h:    tail->next = item;
Kernel/subprojects/lai/core/util-list.h:    hook->prev = item;
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *prev = item->prev;
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *next = item->next;
Kernel/subprojects/lai/core/util-list.h:    item->prev = NULL;
Kernel/subprojects/lai/core/util-list.h:    item->next = NULL;
Kernel/subprojects/lai/core/util-list.h:    prev->next = next;
Kernel/subprojects/lai/core/util-list.h:    next->prev = prev;
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *next = list->hook.next;
Kernel/subprojects/lai/core/util-list.h:    if (next == &list->hook)
Kernel/subprojects/lai/core/util-list.h:    struct lai_list_item *next = item->next;
Kernel/subprojects/lai/core/util-list.h:    if (next == &list->hook)
Kernel/subprojects/lai/core/util-macros.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/util-macros.h:    const __typeof__(((outer_type *)0)->outer_member) *__lai_null_container_member = (inner_ptr); \
Kernel/subprojects/lai/core/util-macros.h:    (outer_type *)((char *)__lai_null_container_member - offsetof(outer_type, outer_member)); \
Kernel/subprojects/lai/core/variable.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/variable.c:    for(size_t i = 0; i < object->pkg_ptr->size; i++)
Kernel/subprojects/lai/core/variable.c:        lai_var_finalize(&object->pkg_ptr->elems[i]);
Kernel/subprojects/lai/core/variable.c:    laihost_free(object->pkg_ptr->elems);
Kernel/subprojects/lai/core/variable.c:    laihost_free(object->pkg_ptr);
Kernel/subprojects/lai/core/variable.c:    switch (object->type) {
Kernel/subprojects/lai/core/variable.c:            if (lai_rc_unref(&object->string_ptr->rc)) {
Kernel/subprojects/lai/core/variable.c:                laihost_free(object->string_ptr->content);
Kernel/subprojects/lai/core/variable.c:                laihost_free(object->string_ptr);
Kernel/subprojects/lai/core/variable.c:            if (lai_rc_unref(&object->buffer_ptr->rc)) {
Kernel/subprojects/lai/core/variable.c:                laihost_free(object->buffer_ptr->content);
Kernel/subprojects/lai/core/variable.c:                laihost_free(object->buffer_ptr);
Kernel/subprojects/lai/core/variable.c:            if (lai_rc_unref(&object->pkg_ptr->rc))
Kernel/subprojects/lai/core/variable.c:    // Move-by-swap idiom. This handles move-to-self operations correctly.
Kernel/subprojects/lai/core/variable.c:    switch (src->type) {
Kernel/subprojects/lai/core/variable.c:            lai_rc_ref(&src->string_ptr->rc);
Kernel/subprojects/lai/core/variable.c:            lai_rc_ref(&src->buffer_ptr->rc);
Kernel/subprojects/lai/core/variable.c:            lai_rc_ref(&src->pkg_ptr->rc);
Kernel/subprojects/lai/core/vsnprintf.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/core/vsnprintf.c:				len--; \
Kernel/subprojects/lai/core/vsnprintf.c:		i = (unsigned)(-((signed)i));
Kernel/subprojects/lai/core/vsnprintf.c:		*--ptr = digits[i % base];
Kernel/subprojects/lai/core/vsnprintf.c:			padding--;
Kernel/subprojects/lai/core/vsnprintf.c:			len--;
Kernel/subprojects/lai/core/vsnprintf.c:	} while ((i /= base) != 0 && (len == -1 || len));
Kernel/subprojects/lai/core/vsnprintf.c:		*--ptr = pad_with;
Kernel/subprojects/lai/core/vsnprintf.c:		padding--;
Kernel/subprojects/lai/core/vsnprintf.c:		*--ptr = '-';
Kernel/subprojects/lai/core/vsnprintf.c:			padding += *fmt++ - '0';
Kernel/subprojects/lai/core/vsnprintf.c:				char *c = num_fmt(i, 10, padding, pad_with, 1, 0, -1);
Kernel/subprojects/lai/core/vsnprintf.c:				char *c = num_fmt(i, 10, padding, pad_with, 0, 0, -1);
Kernel/subprojects/lai/core/vsnprintf.c:				char *c = num_fmt(i, 8, padding, pad_with, 0, 0, -1);
Kernel/subprojects/lai/drivers/ec.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/drivers/ec.c:    if(ecdt->ec_control.address_space != ACPI_GAS_IO) {
Kernel/subprojects/lai/drivers/ec.c:        lai_warn("Unsupported ECDT Command address space %02X", ecdt->ec_control.address_space);
Kernel/subprojects/lai/drivers/ec.c:    driver->cmd_port = ecdt->ec_control.base;
Kernel/subprojects/lai/drivers/ec.c:    if(ecdt->ec_data.address_space != ACPI_GAS_IO) {
Kernel/subprojects/lai/drivers/ec.c:        lai_warn("Unsupported ECDT Data address space %02X", ecdt->ec_data.address_space);
Kernel/subprojects/lai/drivers/ec.c:    driver->data_port = ecdt->ec_data.base;
Kernel/subprojects/lai/drivers/ec.c:    driver->data_port = crs_it.base;
Kernel/subprojects/lai/drivers/ec.c:    driver->cmd_port = crs_it.base;
Kernel/subprojects/lai/drivers/ec.c:        uint8_t status = laihost_inb(driver->cmd_port);
Kernel/subprojects/lai/drivers/ec.c:        uint8_t status = laihost_inb(driver->cmd_port);
Kernel/subprojects/lai/drivers/ec.c: * However disabling interrupts or anything to guarantee that nothing bothers us while working with the EC is not neccesary -
Kernel/subprojects/lai/drivers/ec.c: * since the EC will automatically drop out of Burst mode (See ACPI 6.3 Specification 12.3.3) if it has been idle for too long -
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->cmd_port, ACPI_EC_BURST_ENABLE); // Spec specifies that no interrupt will be generated for this command
Kernel/subprojects/lai/drivers/ec.c:    if(laihost_inb(driver->data_port) != 0x90) 
Kernel/subprojects/lai/drivers/ec.c:    while((laihost_inb(driver->cmd_port) & ACPI_EC_STATUS_BURST) == 0)
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->cmd_port, ACPI_EC_BURST_DISABLE);
Kernel/subprojects/lai/drivers/ec.c:    while((laihost_inb(driver->cmd_port) & ACPI_EC_STATUS_BURST) != 0)
Kernel/subprojects/lai/drivers/ec.c:    if(driver->cmd_port == 0 || driver->data_port == 0){
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->cmd_port, ACPI_EC_READ);
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->data_port, offset);
Kernel/subprojects/lai/drivers/ec.c:    uint8_t ret = laihost_inb(driver->data_port);
Kernel/subprojects/lai/drivers/ec.c:    if(driver->cmd_port == 0 || driver->data_port == 0){
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->cmd_port, ACPI_EC_WRITE);
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->data_port, offset);
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->data_port, value);
Kernel/subprojects/lai/drivers/ec.c:    if(driver->cmd_port == 0 || driver->data_port == 0){
Kernel/subprojects/lai/drivers/ec.c:    laihost_outb(driver->cmd_port, ACPI_EC_QUERY); // Spec specifies that no interrupt will be generated for this command
Kernel/subprojects/lai/drivers/ec.c:    return laihost_inb(driver->data_port);
Kernel/subprojects/lai/drivers/timer.c:    acpi_fadt_t *fadt = lai_current_instance()->fadt;
Kernel/subprojects/lai/drivers/timer.c:    if(fadt->pm_timer_length != 4)
Kernel/subprojects/lai/drivers/timer.c:    if(lai_current_instance()->acpi_revision >= 2 && fadt->x_pm_timer_block.base){
Kernel/subprojects/lai/drivers/timer.c:        timer_block = fadt->x_pm_timer_block;
Kernel/subprojects/lai/drivers/timer.c:        timer_block.base = fadt->pm_timer_block;
Kernel/subprojects/lai/drivers/timer.c:    if(fadt->flags & (1 << 8))
Kernel/subprojects/lai/helpers/pc-bios.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/helpers/pc-bios.c:#include <lai/helpers/pc-bios.h>
Kernel/subprojects/lai/helpers/pc-bios.c:        if (memcmp(rsdp->signature, "RSD PTR ", 8))
Kernel/subprojects/lai/helpers/pc-bios.c:        info->rsdp_address = base + off;
Kernel/subprojects/lai/helpers/pc-bios.c:        if(!rsdp->revision){
Kernel/subprojects/lai/helpers/pc-bios.c:            info->acpi_version = 1;
Kernel/subprojects/lai/helpers/pc-bios.c:            info->rsdt_address = rsdp->rsdt;
Kernel/subprojects/lai/helpers/pc-bios.c:            info->xsdt_address = 0;
Kernel/subprojects/lai/helpers/pc-bios.c:            info->acpi_version = 2;
Kernel/subprojects/lai/helpers/pc-bios.c:            info->rsdt_address = 0;
Kernel/subprojects/lai/helpers/pc-bios.c:            info->xsdt_address = xsdp->xsdt;
Kernel/subprojects/lai/helpers/pc-bios.c:    // Regions specified by ACPI: (i) first 1 KiB of EBDA, (ii) 0xE0000 - 0xFFFFF.
Kernel/subprojects/lai/helpers/pci.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/helpers/pci.c:   says the "interrupt line" field everyone trusts are simply for BIOS or OS-
Kernel/subprojects/lai/helpers/pci.c:   -specific use. Therefore, nobody should assume it contains the real IRQ. Instead,
Kernel/subprojects/lai/helpers/pci.c:    pin--;
Kernel/subprojects/lai/helpers/pci.c:                (iter.function == function || iter.function == -1) &&
Kernel/subprojects/lai/helpers/pci.c:            dest->type = ACPI_RESOURCE_IRQ;
Kernel/subprojects/lai/helpers/pci.c:            dest->base = iter.gsi;
Kernel/subprojects/lai/helpers/pci.c:            dest->irq_flags = (iter.level_triggered ? 0 : ACPI_SMALL_IRQ_EDGE_TRIGGERED)
Kernel/subprojects/lai/helpers/pci.c:    if (lai_obj_get_pkg(iter->prt, iter->i, &prt_entry))
Kernel/subprojects/lai/helpers/pci.c:    iter->i++;
Kernel/subprojects/lai/helpers/pci.c:    iter->slot = (addr >> 16) & 0xFFFF;
Kernel/subprojects/lai/helpers/pci.c:    iter->function = addr & 0xFFFF;
Kernel/subprojects/lai/helpers/pci.c:    if (iter->function == 0xFFFF)
Kernel/subprojects/lai/helpers/pci.c:        iter->function = -1;
Kernel/subprojects/lai/helpers/pci.c:    iter->pin = pin;
Kernel/subprojects/lai/helpers/pci.c:        iter->link = NULL;
Kernel/subprojects/lai/helpers/pci.c:        iter->resource_idx = 0;
Kernel/subprojects/lai/helpers/pci.c:        iter->level_triggered = 1;
Kernel/subprojects/lai/helpers/pci.c:        iter->active_low = 1;
Kernel/subprojects/lai/helpers/pci.c:        iter->gsi = gsi;
Kernel/subprojects/lai/helpers/pci.c:                iter->link = link_handle;
Kernel/subprojects/lai/helpers/pci.c:                iter->resource_idx = res_index;
Kernel/subprojects/lai/helpers/pci.c:                iter->gsi = view.gsi;
Kernel/subprojects/lai/helpers/pci.c:                iter->level_triggered = lai_resource_irq_is_level_triggered(&view);
Kernel/subprojects/lai/helpers/pci.c:                iter->active_low = lai_resource_irq_is_active_low(&view);
Kernel/subprojects/lai/helpers/pm.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/helpers/pm.c:// Param:    uint8_t state - 0-5 to correspond with states S0-S5
Kernel/subprojects/lai/helpers/pm.c:// Return:    int - 0 on success
Kernel/subprojects/lai/helpers/pm.c:    // Who knows, it might do some required firmware-specific stuff
Kernel/subprojects/lai/helpers/pm.c:    data = laihost_inw(instance->fadt->pm1a_control_block);
Kernel/subprojects/lai/helpers/pm.c:    laihost_outw(instance->fadt->pm1a_control_block, data);
Kernel/subprojects/lai/helpers/pm.c:    if(instance->fadt->pm1b_control_block) {
Kernel/subprojects/lai/helpers/pm.c:        data = laihost_inw(instance->fadt->pm1b_control_block);
Kernel/subprojects/lai/helpers/pm.c:        laihost_outw(instance->fadt->pm1b_control_block, data);
Kernel/subprojects/lai/helpers/pm.c:    if(instance->acpi_revision == 0)
Kernel/subprojects/lai/helpers/pm.c:    if(instance->acpi_revision == 1)
Kernel/subprojects/lai/helpers/pm.c:    acpi_fadt_t *fadt = instance->fadt;
Kernel/subprojects/lai/helpers/pm.c:    uint32_t fixed_flags = fadt->flags;
Kernel/subprojects/lai/helpers/pm.c:    switch(fadt->reset_register.address_space){
Kernel/subprojects/lai/helpers/pm.c:        laihost_map(fadt->reset_register.base, 1); // We only need 1 byte mapped
Kernel/subprojects/lai/helpers/pm.c:        uint8_t *reg = (uint8_t *)((uintptr_t) fadt->reset_register.base);
Kernel/subprojects/lai/helpers/pm.c:        *reg = fadt->reset_command;
Kernel/subprojects/lai/helpers/pm.c:        laihost_outb(fadt->reset_register.base, fadt->reset_command);
Kernel/subprojects/lai/helpers/pm.c:        laihost_pci_writeb(0, 0, fadt->reset_register.base >> 24, fadt->reset_register.base >> 16, fadt->reset_register.base >> 8, fadt->reset_command);
Kernel/subprojects/lai/helpers/pm.c:        lai_panic("Unknown FADT reset reg address space type: 0x%02X", fadt->reset_register.address_space);
Kernel/subprojects/lai/helpers/resource.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/helpers/resource.c:                    small_irq_mask = small_irq->irq_mask;
Kernel/subprojects/lai/helpers/resource.c:                            assume active high, edge-triggered, exclusive */
Kernel/subprojects/lai/helpers/resource.c:                                dest[count].irq_flags = small_irq->config;
Kernel/subprojects/lai/helpers/resource.c:                    dest[count].base = (uint64_t)large_irq->irq;
Kernel/subprojects/lai/helpers/resource.c:                    dest[count].irq_flags = large_irq->config;
Kernel/subprojects/lai/helpers/resource.c:    LAI_ENSURE(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    iterator->entry += iterator->skip_size;
Kernel/subprojects/lai/helpers/resource.c:    struct lai_resource_header_info info = lai_get_header_info(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    uint8_t *entry = iterator->entry;
Kernel/subprojects/lai/helpers/resource.c:            iterator->base = (entry[1] | ((entry[2] & 0x3) << 8));
Kernel/subprojects/lai/helpers/resource.c:            iterator->length = entry[3];
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->flags = entry[1];
Kernel/subprojects/lai/helpers/resource.c:            iterator->base = (entry[2] | (entry[3] << 8));
Kernel/subprojects/lai/helpers/resource.c:            iterator->alignment = entry[6];
Kernel/subprojects/lai/helpers/resource.c:            iterator->length = entry[7];
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->entry_idx = 0;
Kernel/subprojects/lai/helpers/resource.c:                iterator->flags = ACPI_SMALL_IRQ_EDGE_TRIGGERED;
Kernel/subprojects/lai/helpers/resource.c:                iterator->flags = entry[3];
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->entry_idx = 0;
Kernel/subprojects/lai/helpers/resource.c:            iterator->flags = entry[3];
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->flags = entry[3];
Kernel/subprojects/lai/helpers/resource.c:            iterator->base = (entry[4] | (entry[5] << 8) | (entry[6] << 16) | (entry[7] << 24)) & 0xFFFFFFFF;
Kernel/subprojects/lai/helpers/resource.c:            iterator->length = (entry[8] | (entry[9] << 8) | (entry[10] << 16) | (entry[11] << 24));
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:            iterator->skip_size = info.skip_size;
Kernel/subprojects/lai/helpers/resource.c:    LAI_ENSURE(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    uint8_t *entry = iterator->entry;
Kernel/subprojects/lai/helpers/resource.c:    LAI_ENSURE(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    uint8_t *entry = iterator->entry;
Kernel/subprojects/lai/helpers/resource.c:    LAI_ENSURE(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    uint8_t *entry = iterator->entry;
Kernel/subprojects/lai/helpers/resource.c:    LAI_ENSURE(iterator->entry);
Kernel/subprojects/lai/helpers/resource.c:    uint8_t *entry = iterator->entry;
Kernel/subprojects/lai/helpers/resource.c:        while(iterator->entry_idx <= 15){
Kernel/subprojects/lai/helpers/resource.c:            if(irq_mask & (1 << iterator->entry_idx)){ // It seems this entry is set
Kernel/subprojects/lai/helpers/resource.c:                iterator->gsi = iterator->entry_idx;
Kernel/subprojects/lai/helpers/resource.c:                iterator->entry_idx++;
Kernel/subprojects/lai/helpers/resource.c:                iterator->entry_idx++;
Kernel/subprojects/lai/helpers/resource.c:        if(iterator->entry_idx < interrupt_table_length){
Kernel/subprojects/lai/helpers/resource.c:            uint8_t offset = 4 * iterator->entry_idx + 5;
Kernel/subprojects/lai/helpers/resource.c:            iterator->gsi = (entry[offset] | (entry[offset + 1] << 8) | (entry[offset + 2] << 16) | (entry[offset + 3] << 24));
Kernel/subprojects/lai/helpers/resource.c:            iterator->entry_idx++;
Kernel/subprojects/lai/helpers/sci.c: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/helpers/sci.c:    if (instance->fadt->pm1a_event_block) {
Kernel/subprojects/lai/helpers/sci.c:        a = laihost_inw(instance->fadt->pm1a_event_block);
Kernel/subprojects/lai/helpers/sci.c:        laihost_outw(instance->fadt->pm1a_event_block, a);
Kernel/subprojects/lai/helpers/sci.c:    if (instance->fadt->pm1b_event_block) {
Kernel/subprojects/lai/helpers/sci.c:        b = laihost_inw(instance->fadt->pm1b_event_block);
Kernel/subprojects/lai/helpers/sci.c:        laihost_outw(instance->fadt->pm1b_event_block, b);
Kernel/subprojects/lai/helpers/sci.c:    uint16_t a = instance->fadt->pm1a_event_block + (instance->fadt->pm1_event_length / 2);
Kernel/subprojects/lai/helpers/sci.c:    uint16_t b = instance->fadt->pm1b_event_block + (instance->fadt->pm1_event_length / 2);
Kernel/subprojects/lai/helpers/sci.c:    if (instance->fadt->pm1a_event_block)
Kernel/subprojects/lai/helpers/sci.c:    if (instance->fadt->pm1b_event_block)
Kernel/subprojects/lai/helpers/sci.c:// Param:   uint32_t mode - IRQ mode (ACPI spec section 5.8.1)
Kernel/subprojects/lai/helpers/sci.c:// Return:  int - 0 on success
Kernel/subprojects/lai/helpers/sci.c:    laihost_outb(instance->fadt->smi_command_port, instance->fadt->acpi_enable);
Kernel/subprojects/lai/helpers/sci.c:        if (laihost_inw(instance->fadt->pm1a_control_block) & ACPI_ENABLED)
Kernel/subprojects/lai/helpers/sci.c:    uint16_t pm1a_cnt_block = laihost_inw(instance->fadt->pm1a_control_block);
Kernel/subprojects/lai/helpers/sci.c:    laihost_outw(instance->fadt->pm1a_control_block, pm1a_cnt_block);
Kernel/subprojects/lai/helpers/sci.c:    if(instance->fadt->pm1b_control_block){
Kernel/subprojects/lai/helpers/sci.c:        uint16_t pm1b_cnt_block = laihost_inw(instance->fadt->pm1b_control_block);
Kernel/subprojects/lai/helpers/sci.c:        laihost_outw(instance->fadt->pm1b_control_block, pm1b_cnt_block);
Kernel/subprojects/lai/helpers/sci.c:    laihost_outb(instance->fadt->smi_command_port, instance->fadt->acpi_disable);
Kernel/subprojects/lai/helpers/sci.c:            lai_panic("_STA returned non-integer object");
Kernel/subprojects/lai/include/acpispec/hw.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/acpispec/hw.h:// Embedded Controller Plug-n-Play ID
Kernel/subprojects/lai/include/acpispec/resources.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/acpispec/resources.h:    uint8_t address_space;        // these are valid --
Kernel/subprojects/lai/include/acpispec/resources.h:    uint8_t bit_width;        // -- only for --
Kernel/subprojects/lai/include/acpispec/resources.h:    uint8_t bit_offset;        // -- generic registers
Kernel/subprojects/lai/include/acpispec/tables.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/core.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/core.h:#include <lai/internal-exec.h>
Kernel/subprojects/lai/include/lai/core.h:#include <lai/internal-ns.h>
Kernel/subprojects/lai/include/lai/core.h:#include <lai/internal-util.h>
Kernel/subprojects/lai/include/lai/drivers/ec.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/drivers/timer.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/helpers/pc-bios.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/helpers/pci.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/helpers/pm.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/helpers/resource.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/helpers/sci.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/host.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/host.h:// OS-specific functions.
Kernel/subprojects/lai/include/lai/internal-exec.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/internal-exec.h:#include <lai/internal-util.h>
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-exec.h: * - Handles and references are distinct types!
Kernel/subprojects/lai/include/lai/internal-exec.h: * - References bind to the variable (LOCALx, ARGx or the namespace node),
Kernel/subprojects/lai/include/lai/internal-exec.h:    LAI_ENSURE(str->type == LAI_STRING);
Kernel/subprojects/lai/include/lai/internal-exec.h:    return str->string_ptr->content;
Kernel/subprojects/lai/include/lai/internal-exec.h:    LAI_ENSURE(buffer->type == LAI_BUFFER);
Kernel/subprojects/lai/include/lai/internal-exec.h:    return buffer->buffer_ptr->size;
Kernel/subprojects/lai/include/lai/internal-exec.h:    LAI_ENSURE(buffer->type == LAI_BUFFER);
Kernel/subprojects/lai/include/lai/internal-exec.h:    return buffer->buffer_ptr->content;
Kernel/subprojects/lai/include/lai/internal-exec.h:    return object->pkg_ptr->size;
Kernel/subprojects/lai/include/lai/internal-exec.h:    LAI_ENSURE(pkg->type == LAI_PACKAGE);
Kernel/subprojects/lai/include/lai/internal-exec.h:    lai_exec_pkg_var_load(out, pkg->pkg_ptr, i);
Kernel/subprojects/lai/include/lai/internal-exec.h:    LAI_ENSURE(pkg->type == LAI_PACKAGE);
Kernel/subprojects/lai/include/lai/internal-exec.h:    lai_exec_pkg_var_store(in, pkg->pkg_ptr, i);
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-exec.h:// ----------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-ns.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/internal-ns.h:#include <lai/internal-util.h>
Kernel/subprojects/lai/include/lai/internal-util.h: * Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h:    lai_rc_t nrefs = --(*rc_ptr);
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/include/lai/internal-util.h://---------------------------------------------------------------------------------------
Kernel/subprojects/lai/LICENSE:Copyright (C) 2018-2020 the lai authors
Kernel/subprojects/lai/meson.build:# One easy way to build LAI with custom flags (such as -ffreestanding,
Kernel/subprojects/lai/meson.build:# -mcmodel=kernel, -mno-red-zone etc.)
Kernel/subprojects/lai/meson.build:    'core/exec-operand.c',
Kernel/subprojects/lai/meson.build:    'helpers/pc-bios.c',
Kernel/subprojects/lai/README.md:  - Core, The main parser/interpreter
Kernel/subprojects/lai/README.md:  - Helpers, Some extra functions that help interfacing with the ACPI API
Kernel/subprojects/lai/README.md:- [Core API Documentation](https://github.com/qword-os/lai/wiki/Core-API-Documentation)
Kernel/subprojects/lai/README.md:- [Helper API Documentation](https://github.com/qword-os/lai/wiki/Helper-API-Documentation)
Kernel/subprojects/lai/README.md:- [Host API Documentation](https://github.com/qword-os/lai/wiki/Host-API-Documentation)
Kernel/subprojects/lai.wrap:[wrap-git]
Kernel/subprojects/lai.wrap:url = https://github.com/qword-os/lai.git
